<!DOCTYPE html><html lang="python"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在python的路上砥砺前行"><meta name="keywords" content="时间 努力 坚持"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>python 面向对象 day 09 | 和拉萨再来个约定</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python 面向对象 day 09</h1><a id="logo" href="/.">和拉萨再来个约定</a><p class="description">Life is the art of drawing sufficient conclusions form insufficient premises</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> author</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">python 面向对象 day 09</h1><div class="post-meta"><a href="/2019/12/27/study%20python%209day/#comments" class="comment-count"></a><p><span class="date">Dec 27, 2019</span><span><a href="/categories/300-lines-of-code/" class="category">300 lines of code</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>hits</i></i></span></p></div><div class="post-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">Python 面向对象</span><br><span class="line">Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</span><br><span class="line"></span><br><span class="line">如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</span><br><span class="line"></span><br><span class="line">接下来我们先来简单的了解下面向对象的一些基本特征。</span><br><span class="line"></span><br><span class="line">面向对象技术简介</span><br><span class="line">类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</span><br><span class="line">类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</span><br><span class="line">数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</span><br><span class="line">方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</span><br><span class="line">局部变量：定义在方法中的变量，只作用于当前实例的类。</span><br><span class="line">实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</span><br><span class="line">继承：即一个派生类（derived <span class="class"><span class="keyword">class</span>）继承基类（<span class="title">base</span> <span class="title">class</span>）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个<span class="title">Dog</span>类型的对象派生自<span class="title">Animal</span>类，这是模拟"是一个（<span class="title">is</span>-<span class="title">a</span>）"关系（例图，<span class="title">Dog</span>是一个<span class="title">Animal</span>）。</span></span><br><span class="line"><span class="class">实例化：创建一个类的实例，类的具体对象。</span></span><br><span class="line"><span class="class">方法：类中定义的函数。</span></span><br><span class="line"><span class="class">对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</span></span><br><span class="line"><span class="class">创建类</span></span><br><span class="line"><span class="class">使用 <span class="title">class</span> 语句来创建一个新类，<span class="title">class</span> 之后为类的名称并以冒号结尾:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">   <span class="string">'类的帮助信息'</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br><span class="line">类的帮助信息可以通过ClassName.__doc__查看。</span><br><span class="line"></span><br><span class="line">class_suite 由类成员，方法，数据属性组成。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">以下是一个简单的 Python 类的例子:</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary</span></span><br><span class="line"></span><br><span class="line">empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</span><br><span class="line"></span><br><span class="line">第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</span><br><span class="line"></span><br><span class="line">self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</span><br><span class="line"></span><br><span class="line">self代表类的实例，而非类</span><br><span class="line">类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span> print(self) print(self.__class__) t = Test() t.prt()</span><br><span class="line"></span><br><span class="line">以上实例执行结果为：</span><br><span class="line"></span><br><span class="line">&lt;__main__.Test instance at <span class="number">0x10d066878</span>&gt;</span><br><span class="line">__main__.Test</span><br><span class="line">从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__class__ 则指向类。</span><br><span class="line"></span><br><span class="line">self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(runoob)</span>:</span> print(runoob) print(runoob.__class__) t = Test() t.prt()</span><br><span class="line"></span><br><span class="line">以上实例执行结果为：</span><br><span class="line"></span><br><span class="line">&lt;__main__.Test instance at <span class="number">0x10d066878</span>&gt;</span><br><span class="line">__main__.Test</span><br><span class="line">创建实例对象</span><br><span class="line">实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。</span><br><span class="line"></span><br><span class="line">以下使用类的名称 Employee 来实例化，并通过 __init__ 方法接收参数。</span><br><span class="line"></span><br><span class="line"><span class="string">"创建 Employee 类的第一个对象"</span></span><br><span class="line">emp1 = Employee(<span class="string">"Zara"</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">"创建 Employee 类的第二个对象"</span></span><br><span class="line">emp2 = Employee(<span class="string">"Manni"</span>, <span class="number">5000</span>)</span><br><span class="line">访问属性</span><br><span class="line">您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:</span><br><span class="line"></span><br><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</span><br><span class="line">完整实例：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary "创建 Employee 类的第一个对象" emp1 = Employee("Zara", 2000) "创建 Employee 类的第二个对象" emp2 = Employee("Manni", 5000) emp1.displayEmployee() emp2.displayEmployee() print "Total Employee %d" % Employee.empCount</span></span><br><span class="line"></span><br><span class="line">执行以上代码输出结果如下：</span><br><span class="line"></span><br><span class="line">Name :  Zara ,Salary:  <span class="number">2000</span></span><br><span class="line">Name :  Manni ,Salary:  <span class="number">5000</span></span><br><span class="line">Total Employee <span class="number">2</span></span><br><span class="line">你可以添加，删除，修改类的属性，如下所示：</span><br><span class="line"></span><br><span class="line">emp1.age = <span class="number">7</span>  <span class="comment"># 添加一个 'age' 属性</span></span><br><span class="line">emp1.age = <span class="number">8</span>  <span class="comment"># 修改 'age' 属性</span></span><br><span class="line"><span class="keyword">del</span> emp1.age  <span class="comment"># 删除 'age' 属性</span></span><br><span class="line">你也可以使用以下函数的方式来访问属性：</span><br><span class="line"></span><br><span class="line">getattr(obj, name[, default]) : 访问对象的属性。</span><br><span class="line">hasattr(obj,name) : 检查是否存在一个属性。</span><br><span class="line">setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</span><br><span class="line">delattr(obj, name) : 删除属性。</span><br><span class="line">hasattr(emp1, <span class="string">'age'</span>) <span class="comment"># 如果存在 'age' 属性返回 True。 getattr(emp1, 'age') # 返回 'age' 属性的值 setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8 delattr(emp1, 'age') # 删除属性 'age'</span></span><br><span class="line"></span><br><span class="line">Python内置类属性</span><br><span class="line">__dict__ : 类的属性（包含一个字典，由类的数据属性组成）</span><br><span class="line">__doc__ :类的文档字符串</span><br><span class="line">__name__: 类名</span><br><span class="line">__module__: 类定义所在的模块（类的全名是<span class="string">'__main__.className'</span>，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）</span><br><span class="line">__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</span><br><span class="line">Python内置类属性调用实例如下：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print "Total Employee %d" % Employee.empCount def displayEmployee(self): print "Name : ", self.name, ", Salary: ", self.salary print "Employee.__doc__:", Employee.__doc__ print "Employee.__name__:", Employee.__name__ print "Employee.__module__:", Employee.__module__ print "Employee.__bases__:", Employee.__bases__ print "Employee.__dict__:", Employee.__dict__</span></span><br><span class="line"></span><br><span class="line">执行以上代码输出结果如下：</span><br><span class="line"></span><br><span class="line">Employee.__doc__: 所有员工的基类</span><br><span class="line">Employee.__name__: Employee</span><br><span class="line">Employee.__module__: __main__</span><br><span class="line">Employee.__bases__: ()</span><br><span class="line">Employee.__dict__: &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'displayCount'</span>: &lt;function displayCount at <span class="number">0x10a939c80</span>&gt;, <span class="string">'empCount'</span>: <span class="number">0</span>, <span class="string">'displayEmployee'</span>: &lt;function displayEmployee at <span class="number">0x10a93caa0</span>&gt;, <span class="string">'__doc__'</span>: <span class="string">'\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb'</span>, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x10a939578</span>&gt;&#125;</span><br><span class="line">python对象销毁(垃圾回收)</span><br><span class="line">Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</span><br><span class="line"></span><br><span class="line">在 Python 内部记录着所有使用中的对象各有多少引用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个内部跟踪变量，称为一个引用计数器。</span><br><span class="line"></span><br><span class="line">当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为<span class="number">0</span> 时， 它被垃圾回收。但是回收不是<span class="string">"立即"</span>的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</span><br><span class="line"></span><br><span class="line">a = <span class="number">40</span>      <span class="comment"># 创建对象  &lt;40&gt;</span></span><br><span class="line">b = a       <span class="comment"># 增加引用， &lt;40&gt; 的计数</span></span><br><span class="line">c = [b]     <span class="comment"># 增加引用.  &lt;40&gt; 的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a       <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">b = <span class="number">100</span>     <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">-1</span>   <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">垃圾回收机制不仅针对引用计数为<span class="number">0</span>的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">析构函数 __del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print class_name, "销毁" pt1 = Point() pt2 = pt1 pt3 = pt1 print id(pt1), id(pt2), id(pt3) # 打印对象的id del pt1 del pt2 del pt3</span></span><br><span class="line"></span><br><span class="line">以上实例运行结果如下：</span><br><span class="line"></span><br><span class="line"><span class="number">3083401324</span> <span class="number">3083401324</span> <span class="number">3083401324</span></span><br><span class="line">Point 销毁</span><br><span class="line">注意：通常你需要在单独的文件中定义一个类，</span><br><span class="line"></span><br><span class="line">类的继承</span><br><span class="line">面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。</span><br><span class="line"></span><br><span class="line">通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。</span><br><span class="line"></span><br><span class="line">继承语法</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 派生类名<span class="params">(基类名)</span></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">在<span class="title">python</span>中继承中的一些特点：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：<span class="title">python</span> 子类继承父类构造函数说明。</span></span><br><span class="line"><span class="class">2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 <span class="title">self</span> 参数变量。区别在于类中调用普通函数时并不需要带上 <span class="title">self</span> 参数</span></span><br><span class="line"><span class="class">3、<span class="title">Python</span> 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</span></span><br><span class="line"><span class="class">如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">语法：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SubClassName</span> <span class="params">(ParentClass1[, ParentClass2, ...])</span>:</span></span><br><span class="line">    ...</span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Parent: # 定义父类 parentAttr = 100 def __init__(self): print "调用父类构造函数" def parentMethod(self): print '调用父类方法' def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print "父类属性 :", Parent.parentAttr class Child(Parent): # 定义子类 def __init__(self): print "调用子类构造方法" def childMethod(self): print '调用子类方法' c = Child() # 实例化子类 c.childMethod() # 调用子类的方法 c.parentMethod() # 调用父类方法 c.setAttr(200) # 再次调用父类的方法 - 设置属性值 c.getAttr() # 再次调用父类的方法 - 获取属性值</span></span><br><span class="line"></span><br><span class="line">以上代码执行结果如下：</span><br><span class="line"></span><br><span class="line">调用子类构造方法</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br><span class="line">父类属性 : <span class="number">200</span></span><br><span class="line">你可以继承多个类</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>        <span class="comment"># 定义类 A</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>         <span class="comment"># 定义类 B</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span>   <span class="comment"># 继承类 A 和 B</span></span><br><span class="line">.....</span><br><span class="line">你可以使用issubclass()或者isinstance()方法来检测。</span><br><span class="line"></span><br><span class="line">issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)</span><br><span class="line">isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。</span><br><span class="line">方法重写</span><br><span class="line">如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class Parent: # 定义父类 def myMethod(self): print '调用父类方法' class Child(Parent): # 定义子类 def myMethod(self): print '调用子类方法' c = Child() # 子类实例 c.myMethod() # 子类调用重写方法</span></span><br><span class="line"></span><br><span class="line">执行以上代码输出结果如下：</span><br><span class="line"></span><br><span class="line">调用子类方法</span><br><span class="line">基础重载方法</span><br><span class="line">下表列出了一些通用的功能，你可以在自己的类重写：</span><br><span class="line"></span><br><span class="line">序号	方法, 描述 &amp; 简单的调用</span><br><span class="line"><span class="number">1</span>	__init__ ( self [,args...] )</span><br><span class="line">构造函数</span><br><span class="line">简单的调用方法: obj = className(args)</span><br><span class="line"><span class="number">2</span>	__del__( self )</span><br><span class="line">析构方法, 删除一个对象</span><br><span class="line">简单的调用方法 : <span class="keyword">del</span> obj</span><br><span class="line"><span class="number">3</span>	__repr__( self )</span><br><span class="line">转化为供解释器读取的形式</span><br><span class="line">简单的调用方法 : repr(obj)</span><br><span class="line"><span class="number">4</span>	__str__( self )</span><br><span class="line">用于将值转化为适于人阅读的形式</span><br><span class="line">简单的调用方法 : str(obj)</span><br><span class="line"><span class="number">5</span>	__cmp__ ( self, x )</span><br><span class="line">对象比较</span><br><span class="line">简单的调用方法 : cmp(obj, x)</span><br><span class="line">运算符重载</span><br><span class="line">Python同样支持运算符重载，实例如下：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print v1 + v2</span></span><br><span class="line"></span><br><span class="line">以上代码执行结果如下所示:</span><br><span class="line"></span><br><span class="line">Vector(<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">类属性与方法</span><br><span class="line">类的私有属性</span><br><span class="line">__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</span><br><span class="line"></span><br><span class="line">类的方法</span><br><span class="line">在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</span><br><span class="line"></span><br><span class="line">类的私有方法</span><br><span class="line">__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python # -*- coding: UTF-8 -*- class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print self.__secretCount counter = JustCounter() counter.count() counter.count() print counter.publicCount print counter.__secretCount # 报错，实例不能访问私有变量</span></span><br><span class="line"></span><br><span class="line">Python 通过改变名称来包含类名:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">print</span> counter.__secretCount  <span class="comment"># 报错，实例不能访问私有变量</span></span><br><span class="line">AttributeError: JustCounter instance has no attribute <span class="string">'__secretCount'</span></span><br><span class="line">Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性，参考以下实例：</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>:</span></span><br><span class="line">    __site = <span class="string">"www.runoob.com"</span></span><br><span class="line"></span><br><span class="line">runoob = Runoob()</span><br><span class="line"><span class="keyword">print</span> runoob._Runoob__site</span><br><span class="line">执行以上代码，执行结果如下：</span><br><span class="line"></span><br><span class="line">www.runoob.com</span><br><span class="line">单下划线、双下划线、头尾双下划线说明：</span><br><span class="line">__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。</span><br><span class="line"></span><br><span class="line">_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <span class="keyword">from</span> module <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>copyright_author: Yan XiGun</p><p>copyright_link: <a href="https://yanxigun99.github.io/2019/12/27/study python 9day/">https://yanxigun99.github.io/2019/12/27/study python 9day/</a></p><p>copyright_notice: copyright_details</p></blockquote></div><div class="tags"><a href="/tags/python/">python</a></div><div class="post-share"><div class="social-share"><span>shareto:</span></div></div><div class="post-nav"><a href="/2019/12/27/study%20python%209day-8/" class="pre">python XML day 09-8</a><a href="/2019/12/26/study%20python%208day-1/" class="next">python 条件语句 循环语句 day 08-1</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">contents</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/hello-world/">Welcome to my Blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/01/study%20python%2044%20day/">study java day 44</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/31/study%20python%2043%20day/">study java day 43</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/study%20python%2042%20day/">study java day 42</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/29/study%20python%2041%20day/">study java day 41</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/study%20python%2040%20day/">study java day 40</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/27/study%20python%2039%20day/">study java day 39</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/26/study%20python%2038%20day/">study java day 38</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/25/study%20python%2037%20day/">study java day 37</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/24/study%20python%2036%20day/">study java day 36</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/300-lines-of-code/">300 lines of code</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/code/">code</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">java 排序算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">java 知识点总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-%E8%AF%BE%E7%A8%8B/">java 课程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">java 课程笔记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-%E9%A1%B9%E7%9B%AE/">java 项目</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">9</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/MYSQL/" style="font-size: 15px;">MYSQL</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 15px;">项目</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">java 课程笔记</a> <a href="/tags/java-%E9%A1%B9%E7%9B%AE/" style="font-size: 15px;">java 项目</a> <a href="/tags/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" style="font-size: 15px;">java 知识点总结</a> <a href="/tags/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 15px;">java 排序算法</a> <a href="/tags/java-%E8%AF%BE%E7%A8%8B/" style="font-size: 15px;">java 课程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">43</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">31</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="https://www.nowcoder.com/" title="牛客网" target="_blank">牛客网</a><ul></ul><a href="https://www.ximalaya.com/" title="喜马拉雅" target="_blank">喜马拉雅</a><ul></ul><a href="https://www.csdn.net/" title="CSDN" target="_blank">CSDN</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">baidusitemap</a> |  <a href="/atom.xml">footer_rss</a> |  <a href="/about/">contact_author</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Yan XiGun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>