{"meta":{"title":"和拉萨再来个约定","subtitle":"Life is the art of drawing sufficient conclusions form insufficient premises","description":"在python的路上砥砺前行","author":"Yan XiGun","url":"https://yanxigun99.github.io"},"pages":[{"title":"about","date":"2020-01-13T11:34:52.000Z","updated":"2020-01-13T11:35:15.317Z","comments":true,"path":"about/index.html","permalink":"https://yanxigun99.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-13T11:34:03.000Z","updated":"2020-01-13T11:34:30.755Z","comments":false,"path":"categories/index.html","permalink":"https://yanxigun99.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-13T11:29:51.000Z","updated":"2020-01-13T11:30:48.911Z","comments":false,"path":"tags/index.html","permalink":"https://yanxigun99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Welcome to my Blog","slug":"hello-world","date":"2020-12-20T12:00:00.000Z","updated":"2020-01-15T00:51:59.079Z","comments":true,"path":"2020/12/20/hello-world/","link":"","permalink":"https://yanxigun99.github.io/2020/12/20/hello-world/","excerpt":"","text":"Welcome to My Blog! from here,you can get some information about Python. Blogger is a beginner in Python study,So we can learn programming together.Come to compare, who have been on the way to learn code last longer. Coding study links学习博客: codingdict 菜鸟教程：runoob 牛客网: nowcoder 网三学院：w3school Favorite Languagepython java git myspl linux vim pycharm The best web1print('github.com') More info: Github My learning web1print('python web') More info: learncode Learn basic grammar1print('runoob.com') More info: runoob Leisure APP1print('www.ximalaya.com/') More info: ximalaya","categories":[],"tags":[],"keywords":[]},{"title":"CSDN 干货大集","slug":"study python 63 day","date":"2020-02-19T12:00:00.000Z","updated":"2020-02-19T12:09:24.696Z","comments":true,"path":"2020/02/19/study python 63 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/19/study%20python%2063%20day/","excerpt":"","text":"CSDN干货大集：URL:click","categories":[{"name":"csdn干货","slug":"csdn干货","permalink":"https://yanxigun99.github.io/categories/csdn%E5%B9%B2%E8%B4%A7/"}],"tags":[{"name":"csdn干货","slug":"csdn干货","permalink":"https://yanxigun99.github.io/tags/csdn%E5%B9%B2%E8%B4%A7/"}],"keywords":[{"name":"csdn干货","slug":"csdn干货","permalink":"https://yanxigun99.github.io/categories/csdn%E5%B9%B2%E8%B4%A7/"}]},{"title":"study java day 62 JDBC功能-9","slug":"study python 62 day","date":"2020-02-18T12:00:00.000Z","updated":"2020-02-19T12:06:37.830Z","comments":true,"path":"2020/02/18/study python 62 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/18/study%20python%2062%20day/","excerpt":"","text":"java 第九个代码模型：JDBC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.util.Date;/** * 虽然在JDBC中存在有Statement接口，但是从实际来讲，Statement接口存在有严重的操作缺陷，是不能再 * 实际工作中使用的,实际过程中我们使用PreparedStatement * @author Administrator * */public class test9 &#123; private static final String DBDRIVER=\"oracle.jdbc.driver.OrackeDriver\"; private static final String DBURL=\"jdbc:oracle:thin:@localhost:1521:mldn\"; private static final String USER=\"scott\"; private static final String PASSWORD=\"tiger\"; public static void main(String[] args) throws Exception &#123; String name=\"Mr'SMITH\"; Date birthday=new Date(); int age=18; String note=\"是个歪果仁\"; //第一步：加载数据库驱动程序，此时不需要实例化，因为会由容器自己负责管理 Class.forName(DBDRIVER); //第二步：连接数据库 Connection conn=DriverManager.getConnection(DBURL,USER,PASSWORD); //在编写SQL的过程中，如果太长的时候需要增加换行，那么请一定记住前后加上空格 String sql=\" INSERT INTO member(mid,name,birthday,age,note) VALUES \" +\" (myseq.nextval,?,?,?,?) \"; //第三步：进行数据库的数据操作，执行完整的SQL PreparedStatement stmt=conn.prepareStatement(sql); stmt.setString(1, name); stmt.setDate(2, new java.sql.Date(birthday.getTime())); stmt.setInt(3, age); stmt.setString(4, note); int len=stmt.executeUpdate(sql);//执行sql返回根性的数据行 System.out.println(\"影响的数据行\"+len); //第四步；关闭数据库 conn.close(); /** * 实现查询功能 * * //第一步：加载数据库驱动程序，此时不需要实例化，因为会由容器自己负责管理 Class.forName(DBDRIVER); //第二步：连接数据库 Connection conn=DriverManager.getConnection(DBURL,USER,PASSWORD); //在编写SQL的过程中，如果太长的时候需要增加换行，那么请一定记住前后加上空格 String sql=\"SELECT mid,name,birthday,age,note FROM member\"; //第三步：进行数据库的数据操作，执行完整的SQL PreparedStatement stmt=conn.prepareStatement(sql); ResultSet rs=stmt.executeQuery(); while(rs.next())&#123; int mid=rs.getInt(1); String name=rs.getString(2); Date birthday=rs.getDate(3); int age=rs.getInt(4); String note=rs.getString(5); System.out.println(mid+\",\"+name+\",\"+birthday+\",\"+age+\",\"+note); &#125; //第四步；关闭数据库 conn.close(); */ /** * 实现查询功能2 * * //第一步：加载数据库驱动程序，此时不需要实例化，因为会由容器自己负责管理 * String keyWord=\"李\"; Class.forName(DBDRIVER); //第二步：连接数据库 Connection conn=DriverManager.getConnection(DBURL,USER,PASSWORD); //在编写SQL的过程中，如果太长的时候需要增加换行，那么请一定记住前后加上空格 String sql=\"SELECT mid,name,birthday,age,note FROM member where name LIKE ?\"; //第三步：进行数据库的数据操作，执行完整的SQL PreparedStatement stmt=conn.prepareStatement(sql); stmt.setString(1,\"%\"+keyWord+\"%\"); ResultSet rs=stmt.executeQuery(); while(rs.next())&#123; int mid=rs.getInt(1); String name=rs.getString(2); Date birthday=rs.getDate(3); int age=rs.getInt(4); String note=rs.getString(5); System.out.println(mid+\",\"+name+\",\"+birthday+\",\"+age+\",\"+note); &#125; //第四步；关闭数据库 conn.close(); */ /** * 分页显示 * * //第一步：加载数据库驱动程序，此时不需要实例化，因为会由容器自己负责管理 * String keyWord=\"\"; * int currentPage=1; * int lineSize=5; Class.forName(DBDRIVER); //第二步：连接数据库 Connection conn=DriverManager.getConnection(DBURL,USER,PASSWORD); //在编写SQL的过程中，如果太长的时候需要增加换行，那么请一定记住前后加上空格 String sql=\"SELECT * FROM (\" +\"SELCET mid,name,dirthday,age,note ROWNUM rn\" +\"FROM member\" +\"WHERE name LIKE ? AND ROWNUM&lt;=?) temp\" +\"WHERE temp.rn &gt;?\"; //第三步：进行数据库的数据操作，执行完整的SQL PreparedStatement stmt=conn.prepareStatement(sql); stmt.setString(1,\"%\"+keyWord+\"%\"); stmt.setInt(2,currentPage*lineSize); stmt.setInt(3,(currentPage-1)*lineSize); ResultSet rs=stmt.executeQuery(); while(rs.next())&#123; int mid=rs.getInt(1); String name=rs.getString(2); Date birthday=rs.getDate(3); int age=rs.getInt(4); String note=rs.getString(5); System.out.println(mid+\",\"+name+\",\"+birthday+\",\"+age+\",\"+note); &#125; //第四步；关闭数据库 conn.close(); */ /** *统计数据量 * * //第一步：加载数据库驱动程序，此时不需要实例化，因为会由容器自己负责管理 * String keyWord=\"\"; Class.forName(DBDRIVER); //第二步：连接数据库 Connection conn=DriverManager.getConnection(DBURL,USER,PASSWORD); //在编写SQL的过程中，如果太长的时候需要增加换行，那么请一定记住前后加上空格 String sql=\"SELECT COUNT(mid) FROM member WHERE name LIKE ?\"; //第三步：进行数据库的数据操作，执行完整的SQL PreparedStatement stmt=conn.prepareStatement(sql); stmt.setString(1,\"%\"+keyWord+\"%\"); ResultSet rs=stmt.executeQuery(); if(rs.next())&#123; int count=rs.getInt(1); System.out.println(count); &#125; //第四步；关闭数据库 conn.close(); */ &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 61 第八个代码模型","slug":"study python 61 day","date":"2020-02-17T12:00:00.000Z","updated":"2020-02-19T12:04:54.662Z","comments":true,"path":"2020/02/17/study python 61 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/17/study%20python%2061%20day/","excerpt":"","text":"java 第八个代码模型：Map使用Iterator123456789101112131415161718192021222324252627282930313233package test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/** * 代码模型八：map使用Iterator * @author Administrator *Map 集合保存的数据目的是为了查询使用，Collection保存数据的目的是为了输出使用 *Map使用Iterator接口输出的步骤以及具体实现代码要掌握 *HashMap可以保存null,HashMap不能保存null，key重复会导致覆盖 */public class test8 &#123; public static void main(String[] args) &#123; Map&lt;String,Integer&gt; map=new HashMap&lt;String,Integer&gt;(); map.put(\"壹\", 1); map.put(\"贰\",2); map.put(\"叁\",3); System.out.println(map); //将Map集合变为Set集合，目的是为了使用iterator（）方法 //1、将Map变为Set Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set=map.entrySet(); //2、设置Iterator Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter=set.iterator(); //3、取出数据 while(iter.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; me=iter.next(); System.out.println(me.getKey()+\"=\"+me.getValue()); &#125; &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 60 第七个代码模型","slug":"study python 60 day","date":"2020-02-16T12:00:00.000Z","updated":"2020-02-18T11:41:30.727Z","comments":true,"path":"2020/02/16/study python 60 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/16/study%20python%2060%20day/","excerpt":"","text":"java 第七个代码模型：io使用模型12345678910111213141516171819202122232425262728293031323334package test;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;/** * 第七个代码模型：IO使用模型 * @author Administrator *字节输入流：InputStream功能不足被Scanner解决了 *字符输入流：Reader类的功能不足被BufferdReader解决了 *字节输出流：OutputStream类的功能不足被PrintStream解决了 *字符输出流：Writer类的功能不足被PrintWriter解决了 * */public class test7 &#123; public static void main(String[] args) throws Exception&#123; //1、第一要输出的文件路径 File file=new File(\"E:\"+File.separator+\"demo\"); //1、此时由于 目录不存在，所以文件不能够输出，那么应该首先创建目录 if(!file.getParentFile().exists()) &#123;//文件目录不存在 file.getParentFile().mkdirs();//创建目录 &#125; //2、应该使用OutputStream和其子类进行对象的实例化，此时目录存在，文件还不存在 OutputStream output=new FileOutputStream(file); //3、要进行文件内容的输出 String str=\"好好学习，天天向上\"; byte data[]=str.getBytes();//将字符串转换为字节数组 output.write(data);//将内容输出 //4、资源操作的最后一步，一定要关闭 output.close(); &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 59 实战：文件拷贝","slug":"study python 59 day","date":"2020-02-15T12:00:00.000Z","updated":"2020-02-18T09:03:49.617Z","comments":true,"path":"2020/02/15/study python 59 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/15/study%20python%2059%20day/","excerpt":"","text":"java 实战：文件拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package test;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;/**实战 * 题目：模拟DOS系统的文件拷贝程序，实现字节流的综合使用 * @author Administrator *具体要求： *在DOS系统之中文件拷贝的命令:copy源文件路径 目标文件路径 *如果要想实现文件拷贝工作 *1、将所有的文件内容一次性读取进程序，然后依次输出 * 需要开辟一个与文件大小一样的数组，但是文件过大呢？程序就崩溃了 *2、采用边读边输出的方式，那么现在就不会占用我们过大的内存空间 *由于现在要拷贝二进制数据，那么我们一定使用字节流会合适一些 */public class CopyDemo &#123; public static void main(String[] args)throws Exception &#123; long begin=System.currentTimeMillis(); if(args.length!=2) &#123;//初始化参数个数不是两个 System.out.println(\"命令执行错误\"); System.exit(1);//程序退出执行 &#125; //如果输入参数正确，那么应该进行文件的验证 File inFile=new File(args[0]);//第一个参数原源文件路径 if(!inFile.exists()) &#123;//源文件不存在， System.out.println(\"文件不存在，请确认路径\"); System.exit(1);//程序退出 &#125; //如果此时源文件正确，那么久需要定义输出文件，同时要考虑到输出文件有目录 File outFile=new File(args[1]); if(!outFile.getParentFile().exists()) &#123;//输出文件不存在 outFile.getParentFile().mkdirs();//创建输出文件 &#125; //实现文件内容拷贝 InputStream input=new FileInputStream(inFile); OutputStream output=new FileOutputStream(outFile); /**实现文件拷贝(这种拷贝熟读太慢)时间576ms int temp=0;//保存每次读取的内容 while((temp=input.read())!=-1) &#123;//每次读取单个字节 output.write(temp);//输出单个字节 &#125; */ //改良方法时间：2ms int temp=0;//保存每次读取的个数 byte data[]=new byte[1024];//每次读取1024个字节 while((temp=input.read(data))!=-1) &#123; output.write(data,0,temp);//输出数组 &#125; input.close(); output.close(); long end=System.currentTimeMillis(); System.out.println(\"拷贝所花的时间：\"+(end-begin)); &#125;&#125;","categories":[{"name":"java 实战","slug":"java-实战","permalink":"https://yanxigun99.github.io/categories/java-%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java 实战","slug":"java-实战","permalink":"https://yanxigun99.github.io/tags/java-%E5%AE%9E%E6%88%98/"}],"keywords":[{"name":"java 实战","slug":"java-实战","permalink":"https://yanxigun99.github.io/categories/java-%E5%AE%9E%E6%88%98/"}]},{"title":"study java day 58 正则表达式","slug":"study python 58 day","date":"2020-02-14T12:00:00.000Z","updated":"2020-02-13T12:01:02.084Z","comments":true,"path":"2020/02/14/study python 58 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/14/study%20python%2058%20day/","excerpt":"","text":"java 正则表达式123456789101112131415161718192021222324252627282930313233343536373839404142package test;/** * * @author Administrator *正则表达式： *1、单个字符（数量:1）： * 字符：表示由一位字符所组成 * \\\\：表示转义字符“\\“ * \\t：表示一个”\\t“符号 * \\n：表示换行符号 *2、字符集(数量1) * [abc]:表示可能是字符a或者字符b或者字符c的任意一位； * [^abc]:表示不是a\\b\\c的任意一位 * [a-z]:所有的小写字母 * [a-zA-Z]:表示任意一位字符，不区分大小写 * [0-9]:表示任意的一位数字 *3、简化的字符集表达式（数量1）： * .：表示任意的以为字符 * \\d：等价于”[0-9]“,属于简化写法 * \\D：等价与”[^0-9]“ * \\s：表示任意的空白字符，例如：”\\t“,\"\\n\" * \\S：表示任意的非空白字符 * \\w: 等价于”[a-zA-Z0-9]“,表示由任意的字母、数字、_所组成 * \\W: 等价于”[^a-zA-Z0-9]“ *4、边界匹配（不要再java中使用，在javascript里使用） * ^:正则的开始 * $:正则的结束 *5、数量表达式 * 正则？：表示此正则可以出现0或者1次 * 正则+：表示此正则可以出现1次或者1次以上 * 正则*：表示此正则可以出现0次或者1次或者多次 * 正则&#123;n&#125;：表示此正则出现n次 * 正则&#123;n，&#125;：表示此正则出现n次以上 * 正则&#123;n，m&#125;：表示此正则出现n到m次 *6、逻辑运算： * 正则1正则2：正则1判断完成之后继续判断正则2 * 正则1|正则2：正则1或者正则2有一组满足即可 * （正则）：将多个正则作为一组，可以为这一组单独设置出现的次数 */public class test6 &#123;&#125;","categories":[{"name":"java 正则表达式","slug":"java-正则表达式","permalink":"https://yanxigun99.github.io/categories/java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"java 正则表达式","slug":"java-正则表达式","permalink":"https://yanxigun99.github.io/tags/java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"keywords":[{"name":"java 正则表达式","slug":"java-正则表达式","permalink":"https://yanxigun99.github.io/categories/java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"study java day 57 第五个代码模型","slug":"study python 57 day","date":"2020-02-13T12:00:00.000Z","updated":"2020-02-13T10:57:16.099Z","comments":true,"path":"2020/02/13/study python 57 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/13/study%20python%2057%20day/","excerpt":"","text":"java的第五个代码模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package test;import java.text.SimpleDateFormat;import java.util.Date;/** * 在之前一直在编写简单java类，但是所编写的数据表与简单java类的转换里面缺少了Date数据类型，所以本 * 部分属于简单java类的最后一块重要的拼版 * 在java里面提供有一个java.util.Date的类，它直接表示当前的如期时间。 * @author Administrator * Date类重要方法： * 无参构造：public Date(); * 有参构造：public Date(long date)接收long形数据 * 转换为long形：public long getTime(); * *第六个代码模型：SimpleDateFormat（日期格式化） *java.text是一个专门实现国际化程序的开发包，而SimpleDateFormat是一个专门处理时间格式的工具类， *将Date型对象转换为String型显示。 *方法： *构造方法：public SimpleDateFormat(String pattern),需要转换格式 *将Date转换为String：public final String format(Date date) *将String转换为Date：public Date parse(String source) throws ParseException *转换单位：年（yyyy），月（MM），日（dd），时（HH），分（mm），秒（ss）,毫秒（SSS） * * *总结： * Date和String类之间的转换依靠的是SumpleDateFormat * String和基本类型之间的转换依靠的是包装类与String.valueof(); * long和Date转换依靠的是Date类提供的构造方法和getTime（）方法 * */public class test5 &#123; public static void main(String[] args) &#123;// Date date=new Date();//直接输出当前时间// System.out.println(date);// long cur=System.currentTimeMillis();//取得当前时间 long形// Date date1=new Date(cur);//long转换Date// System.out.println(date1);// System.out.println(date1.getTime());//Date转换long Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String str=sdf.format(date); System.out.println(str); String str1=\"2001-11-11 11:11:11\"; Date date1=sdf.parse(str1); System.out.println(date1); &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 56 多线程实战","slug":"study python 56 day","date":"2020-02-12T12:00:00.000Z","updated":"2020-02-13T10:10:48.193Z","comments":true,"path":"2020/02/12/study python 56 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/12/study%20python%2056%20day/","excerpt":"","text":"java的多线程实战经典模型（生产者与消费者）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package test;//生产者和消费者（经典多线程模型）//Object类对多线程的支持/** * 问题引出： * 生产者和消费者是两个不同的现场类对象 * 生产者负责产生数据，消费者负责取走数据 * 生产者每生产完一组数据之后，消费者就要取走一组数据 * 需要加上同步才可以解决数据错位问题 * @author Administrator * 面试题：请解释sleep（）和wait（）的区别 * sleep（）是Thread类定义的方法，wait（）是Object类定义的方法 * sleep（）可以设置休眠时间，一到时间自动唤醒，而wait（）需要等待notify（）进行唤醒 * */class Info&#123; private String title; private String content; private boolean flag=true; //flag=true表示可以生产，但是不可以取出 //flag=false表示可以取出，不可以生产 public synchronized void set(String title,String content) &#123; if(this.flag==false) &#123; try &#123; super.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.title=title; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.content=content; this.flag=false;//修改生产标记 super.notify(); &#125; public synchronized void get() &#123; if(this.flag==true) &#123; try &#123; super.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.title+\"-\"+this.content); this.flag=true; super.notify(); &#125;&#125;class Productor implements Runnable&#123; private Info info; public Productor(Info info) &#123; this.info=info; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i%2==0) &#123; this.info.set(\"one\",\"123\"); &#125;else &#123; this.info.set(\"two\",\"456\"); &#125; &#125; &#125;&#125;class Customer implements Runnable&#123; private Info info; public Customer(Info info) &#123; this.info=info; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; this.info.get(); &#125; &#125;&#125;public class test4 &#123; public static void main(String[] args) &#123; Info info=new Info(); new Thread(new Productor(info)).start(); new Thread(new Customer(info)).start(); &#125;&#125;","categories":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/tags/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"keywords":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}]},{"title":"study java day 55 设计模式-多例模式","slug":"study python 55 day","date":"2020-02-11T12:00:00.000Z","updated":"2020-02-13T10:10:57.744Z","comments":true,"path":"2020/02/11/study python 55 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/11/study%20python%2055%20day/","excerpt":"","text":"java的多例设计模式1234567891011121314151617181920212223242526package test;//构造方法私有化（多例设计模式）class Sex&#123; private String title; private static final Sex MALE=new Sex(\"男\"); private static final Sex FEMALE=new Sex(\"女\"); private Sex(String title) &#123;//构造私有化 this.title=title; &#125; public String toString() &#123; return this.title; &#125; public static Sex getInstance(String ch) &#123; switch(ch) &#123; case \"man\":return MALE; case \"woman\":return FEMALE; default:return null; &#125; &#125;&#125;public class test3 &#123; public static void main(String[] args) &#123; Sex sex=Sex.getInstance(\"man\"); System.out.println(sex); &#125;&#125;","categories":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"study java day 54 设计模式-单例模式","slug":"study python 54 day","date":"2020-02-10T12:00:00.000Z","updated":"2020-02-12T05:46:40.742Z","comments":true,"path":"2020/02/10/study python 54 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/10/study%20python%2054%20day/","excerpt":"","text":"java的单例设计模式1234567891011121314151617181920212223242526272829303132333435363738394041package test;//构造方法私有化（单例设计模式）//两种形式：饿汉式和懒汉式//饿汉式class Singleton&#123; private static final Singleton INSTANCE=new Singleton();//内部实例化 private Singleton() &#123;&#125;//构造方法私有化 public static Singleton getInstance() &#123; return INSTANCE; &#125; public void print() &#123; System.out.println(\"hello world!\"); &#125;&#125;//懒汉式//class Singleton&#123;// private static final Singleton instance;// private Singleton() &#123;&#125;//构造方法私有化// public static Singleton getInstance() &#123;// if(instance==null) &#123;// instance=new Singleton();//第一次调用时才创建// &#125;// return instance;// &#125;// public void print() &#123;// System.out.println(\"hello world!\");// &#125;//&#125;public class test &#123; public static void main(String[] args) &#123; Singleton s=null; s=Singleton.getInstance();//直接调用static属性 s.print(); &#125;&#125;//代码意义：如果现在要控制一个类中实例化对象产生个数，首先要锁定的是类中的构造方法，//因为在实例化任何对象都要使用构造方法，如果锁住，就无法产生新的实例化对象。//可是既然需要一个实例化对象，我们就可以在类的内部使用static方式来定义，static方法返回//唯一的一个对象，这样外部不管调用多少次 ，那么最终只有一个实例化对象产生，这就//属于单例模式（Singleton）。","categories":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"study java day 53 代码模型-5","slug":"study python 53 day","date":"2020-02-09T12:00:00.000Z","updated":"2020-02-12T05:16:51.169Z","comments":true,"path":"2020/02/09/study python 53 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/09/study%20python%2053%20day/","excerpt":"","text":"java第五个代码模型—-异常的使用格式123456789101112131415161718192021222324252627package test;//第五个代码模型：异常的使用格式class MyMath&#123; //此时表示div（）方法上如果出现异常交给被调用处处理 public static int div(int x,int y) throws Exception &#123; int result=0; System.out.println(\"1、除法计算开始\"); try &#123; result=x/y; &#125;catch(Exception e) &#123; throw e;//继续抛出异常 &#125;finally &#123; System.out.println(\"2、除法计算结束\"); &#125; return result; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; try &#123; System.out.println(MyMath.div(10, 0)); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 52 包和jar","slug":"study python 52 day","date":"2020-02-08T12:00:00.000Z","updated":"2020-02-12T02:20:25.572Z","comments":true,"path":"2020/02/08/study python 52 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/08/study%20python%2052%20day/","excerpt":"","text":"java包和jar概念123456789101112131415161718192021222324252627282930313233343536package test;//java本身提供了大量的程序开发包，还有其它第三方提供的大量开发包在java开发里面，//有如下的一些常见的系统包：// java.lang：包含了String Object Integer等类，从JDK1.1开始自动导入// java.lang.refelect:反射开发包；// java.util:java工具包，提供大量的工具类，如链表// java.util.regex:正则工具包// java.text:国际化处理程序包// java.io:进行输入 输出处理以及文件操作// java.net:网络编程开发包// java.sql:数据库程序开发包// java.applet：Applet程序开发包（已经不用了）可以使用Canvas绘图（html5功能）// Applet是java在网页上嵌套的程序，可以使用Applet做一些动态的效果，// 是采用绘图的方式完成显示的。// Application是在主方法中运行，通过命令行执行。// java.awt javax.swing:图形界面的开发包，主要功能是提供单机版程序界面编写的// JDK1.0主要推出的是awt开发包，但是这个开发包使用了大量Windows图像函数：// JDK1.2隆重推出了javax.swing开发包，是一个轻量级（java自己编写的，不在使用windows）// java从此更名为java2////jar命令：// 在任何一个项目里面一定存在大量*.class文件，如果直接交给用户使用，会造成文件过多，// 并且会导致程序没有结构，所以在交付给用户使用前，会使用jar命令对文件进行压缩，压缩// 单位都是以包为主的。// // 在以后开发时，会使用大量的第三方jar文件，使用之前必须配置CLASSPATH才可以加载// SET CLASSPATH=.;E:\\mydemo\\my.jar////总结：// 以后开发程序必须要有包的存在// 如果包冲突了的时候要写上完整的类名称// 以后使用第三方的jar文件必须配置CLASSPATH// public class myPackage &#123;&#125;","categories":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/tags/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"keywords":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}]},{"title":"study java day 50 设计模式-工厂模式","slug":"study python 50 day","date":"2020-02-07T12:00:00.000Z","updated":"2020-02-12T01:00:42.718Z","comments":true,"path":"2020/02/07/study python 50 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/07/study%20python%2050%20day/","excerpt":"","text":"java的工厂设计模式123456789101112131415161718192021222324252627282930313233343536package test7;//工厂设计模式interface Fruit&#123; public void eat();&#125;class Apple implements Fruit&#123; public void eat() &#123; System.out.println(\"***吃苹果\"); &#125;&#125;class Orange implements Fruit&#123; public void eat() &#123; System.out.println(\"***吃橘子\"); &#125;&#125;class Factory&#123; public static Fruit getInstance(String className) &#123; if(\"apple\".equals(className)) &#123; return new Apple(); &#125;else if(\"orange\".equals(className)) &#123; return new Orange(); &#125;else &#123; return null; &#125; &#125;&#125;public class test7 &#123; public static void main(String []args) &#123; Fruit f1=Factory.getInstance(\"Orange\"); Fruit f2=Factory.getInstance(\"Apple\"); f1.eat(); f2.eat(); &#125;&#125;","categories":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"study java day 51 继承知识点实战","slug":"study python 51 day","date":"2020-02-07T12:00:00.000Z","updated":"2020-02-12T01:02:22.142Z","comments":true,"path":"2020/02/07/study python 51 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/07/study%20python%2051%20day/","excerpt":"","text":"java继承知识点实战1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package test6;//实战---复习继承知识点class Array&#123;//数组类 private int data[]; private int foot;//表示数组操作脚标 public Array(int len) &#123; if(len&gt;0) &#123;//至少有元素 this.data=new int[len];//开辟数组 &#125;else &#123; this.data=new int[1];//维持一个长度数组 &#125; &#125; public boolean add(int num) &#123;//加入数据 if(this.foot&lt;this.data.length) &#123; this.data[this.foot++]=num; return true; &#125; return false; &#125; public int[] getData() &#123;//取出数据 return this.data; &#125; &#125;class SortArray extends Array&#123;//排序类 //Array类里面没有无参数构造 public SortArray(int len) &#123; //这样父类中data数组就可以初始化 super(len);//明确调用父类的有参构造 &#125; //重写父类方法覆写 public int[] getData() &#123; java.util.Arrays.sort(super.getData()); return super.getData(); &#125;&#125;class ReverseArray extends Array&#123; public ReverseArray(int len) &#123; super(len); &#125; public int[] getData() &#123; int center=super.getData().length/2; int head=0; int tail=super.getData().length-1; for (int i = 0; i &lt; center; i++) &#123; int temp=super.getData()[head]; super.getData()[head]=super.getData()[tail]; super.getData()[tail]=temp; head++; tail--; &#125; return super.getData(); &#125;&#125;public class test6 &#123; public static void main(String []args) &#123; ReverseArray arr=new ReverseArray(3); System.out.println(arr.add(10)); System.out.println(arr.add(50)); System.out.println(arr.add(30)); int[] temp=arr.getData(); for (int i = 0; i &lt; temp.length; i++) &#123; System.out.println(temp[i]); &#125; &#125; &#125;","categories":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/tags/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}],"keywords":[{"name":"java 知识点实战","slug":"java-知识点实战","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AE%9E%E6%88%98/"}]},{"title":"study java day 49 设计模式-代理模式","slug":"study python 49 day","date":"2020-02-06T12:00:00.000Z","updated":"2020-02-12T00:59:41.472Z","comments":true,"path":"2020/02/06/study python 49 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/06/study%20python%2049%20day/","excerpt":"","text":"java的代理设计模式1234567891011121314151617181920212223242526272829303132333435363738package test8;//代理设计模式interface Subject&#123; public void make();&#125;class RealSubject implements Subject&#123; public void make() &#123; System.out.println(\"皇帝陛下正在XX\"); &#125;&#125;class ProxySubject implements Subject&#123; //要接收一个真实主题的操作对象 private Subject subject; public ProxySubject(Subject subject) &#123; this.subject=subject; &#125; public void prepare() &#123; System.out.println(\"为临幸做准备\"); &#125; public void make() &#123; this.prepare(); this.subject.make(); this.destory(); &#125; public void destory() &#123; System.out.println(\"把娘娘搬走了，伺候皇帝洗澡\"); &#125;&#125;public class test8 &#123; public static void main(String args[]) &#123; //代理涉及模式核心就在于有一个主题操作接口（可能有多种方法）核心业务 //主题只完成我们核心功能，例如：吃饭 //而我们代理主题负责完成所有与核心主题有关的辅助性操作 Subject sub=new ProxySubject(new RealSubject()); sub.make(); &#125;&#125;","categories":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://yanxigun99.github.io/categories/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"study java day 48 代码模型-4","slug":"study python 48 day","date":"2020-02-05T12:00:00.000Z","updated":"2020-02-12T00:58:37.455Z","comments":true,"path":"2020/02/05/study python 48 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/05/study%20python%2048%20day/","excerpt":"","text":"java的第四个代码模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246package test9;//每一个链表实际上就是由多个节点所组成的class Link&#123;//链表类 //之所以定义内部类，主要是让其为Link类服务 private class Node&#123;//定义节点类 private Object data;//数据 private Node next;//引用关系 public Node(Object data) &#123; this.data=data; &#125; //实现节点添加 //第一次调用（Link）：this=Link.root //第二次调用（Node）：this=Link.root.next public void addNode(Node newNode) &#123; if(this.next==null) &#123; this.next=newNode;//保存根节点 &#125;else &#123; this.next.addNode(newNode);//向后保存 &#125; &#125; public Object getNode(int index) &#123; if(Link.this.foot++==index) &#123; return this.data; &#125;else &#123; return this.next.getNode(index); &#125; &#125; public boolean containsNode(Object data) &#123; if(data.equals(this.data)) &#123; return true; &#125;else &#123; if(this.next!=null) &#123; return this.next.containsNode(data); &#125;else &#123; return false; &#125; &#125; &#125; public void setNode(int index,Object data) &#123; if(Link.this.foot++==index) &#123; this.data=data; &#125;else &#123; this.next.setNode(index, data); &#125; &#125; //要传递上一个节点以及要删除的数据 public void removeNode(Node previous,Object data) &#123; if(data.equals(this.data)) &#123; previous.next=this.next; &#125;else &#123; this.next.removeNode(this, data); &#125; &#125; public void toArrayNode() &#123; Link.this.retArray[Link.this.foot++]=this.data; if(this.next!=null) &#123; this.next.toArrayNode(); &#125; &#125; &#125; //================以上为内部类============================= private Node root;//需要跟节点 private int count=0; private int foot=0; private Object[] retArray; public void add(Object data) &#123; if(data==null) &#123;//假设不许为空 return; &#125; Node newNode=new Node(data); if(this.root==null) &#123; this.root=newNode;//设置根节点 &#125;else &#123; this.root.addNode(newNode);//根节点存在，其它节点交给Node保存 &#125; this.count++; &#125; public int size() &#123; return this.count; &#125; public boolean isEmpty() &#123; return this.count==0; &#125; public Object get(int index) &#123; if(index&gt;this.count) &#123; return null; &#125; this.foot=0;//表示从前向后查询 return this.root.getNode(index); &#125; public boolean contains(Object data) &#123; //现在没有要查询的数据，或者跟节点没有数据 if(data==null||this.root==null) &#123; return false; &#125; return this.root.containsNode(data); &#125; public void set(int index,Object data) &#123; if(index&gt;this.count) &#123; return;//结束方法调用 &#125; this.foot=0; this.root.setNode(index,data); &#125; public Object[] toArray() &#123; if(this.root==null) &#123; return null; &#125; this.retArray=new Object[this.count]; this.root.toArrayNode(); return this.retArray; &#125; public void remove(Object data) &#123; if(this.contains(data)) &#123; if(data.equals(this.root.data)) &#123; this.root=this.root.next; &#125;else &#123; this.root.next.removeNode(this.root, data); &#125; this.count--; &#125; &#125;&#125;//========================宠物商店实例===================================//第四个代码模型：接口的使用//整合链表应用。同时进一步巩固接口的作用（标准）。//题目：实现一个宠物商店的模型，一个宠物商店可以保存多个宠物信息（名字和年龄）//可以实现宠物的上架、下架和模糊查询功能；//利用可用链表类功能interface Pet&#123; public String getName(); public int getAge();&#125;class PetShop&#123; private Link pets=new Link(); public void add(Pet pet) &#123; this.pets.add(pet); &#125; public void delete(Pet pet) &#123; this.pets.remove(pet); &#125; //模糊查询返回多个结果 public Link search(String keyWord) &#123; Link result=new Link(); Object obj[]=this.pets.toArray(); for (int i = 0; i &lt; obj.length; i++) &#123; Pet p=(Pet)obj[i]; if(p.getName().contains(keyWord)) &#123; result.add(p); &#125; &#125; return result; &#125;&#125;//定义猫类class Cat implements Pet&#123; private String name; private int age; public Cat(String name,int age) &#123; this.name=name; this.age=age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125; public boolean equals(Object obj) &#123; if(this==obj) &#123; return true; &#125; if(obj==null) &#123; return false; &#125; if(!(obj instanceof Cat)) &#123; return false; &#125; Cat c=(Cat)obj; if(this.name.equals(c.name)&amp;&amp;this.age==c.age) &#123; return true; &#125; return false; &#125; public String toString() &#123; return \"猫的名字\"+this.name+\"，年龄\"+this.age; &#125;&#125;//狗的类class Dog implements Pet&#123; private String name; private int age; public Dog(String name,int age) &#123; this.name=name; this.age=age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125; public boolean equals(Object obj) &#123; if(this==obj) &#123; return true; &#125; if(obj==null) &#123; return false; &#125; if(!(obj instanceof Dog)) &#123; return false; &#125; Dog c=(Dog)obj; if(this.name.equals(c.name)&amp;&amp;this.age==c.age) &#123; return true; &#125; return false; &#125; public String toString() &#123; return \"狗的名字\"+this.name+\"，年龄\"+this.age; &#125;&#125;//测试类public class test9 &#123; public static void main(String[] args) &#123; PetShop shop=new PetShop(); shop.add(new Cat(\"猫1\",10)); shop.add(new Cat(\"猫2\",8)); shop.add(new Cat(\"猫3\",9)); shop.add(new Dog(\"狗1\",10)); shop.add(new Dog(\"狗2\",8)); shop.add(new Dog(\"狗3\",9)); shop.delete(new Dog(\"狗1\",10)); Link all=shop.search(\"狗\"); Object obj[]=all.toArray(); for (int i = 0; i &lt; obj.length; i++) &#123; System.out.println(obj[i]); &#125; &#125;&#125;//总结：完成了一个现实关系的模拟//扩展：一个停车场可用停放多辆车// 一个公园里可以种多种树// 一个动物园有多种动物","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 47 代码模型-3","slug":"study python 47 day","date":"2020-02-04T12:00:00.000Z","updated":"2020-02-12T00:57:35.863Z","comments":true,"path":"2020/02/04/study python 47 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/04/study%20python%2047%20day/","excerpt":"","text":"java的第三个代码模型123456789101112131415161718192021222324252627282930313233343536373839404142package test10;//第三个代码模型：对象比较//如果现在判断两个数字是否相等，可以使用“==”//如果判断两个字符串是否相等，可以使用“equals”//对象=数据集合，那么进行比较一定要依次比较所有的属性class Book&#123; private String title; private double price; public Book(String title,double price) &#123; this.title=title; this.price=price; &#125; //本类接收本类对象，只有在对象比较里面才会使用这个形式的代码 //两个功能：带回了需要比较的信息，方便访问 public boolean compare(Book book) &#123; if(book==null) &#123; return false; &#125; if(this==book) &#123; return true; &#125; if(this.title.equals(book.title)&amp;&amp;this.price==book.price) &#123; return true; &#125;else &#123; return false; &#125; &#125; public String getTitle() &#123; return this.title; &#125; public double getPrice() &#123; return this.price; &#125;&#125;public class test10 &#123; public static void main(String args[]) &#123; Book b1=new Book(\"Java\",7.2); Book b2=new Book(\"Java\",7.2); System.out.println(b1.compare(b2)); &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 46 代码模型-2","slug":"study python 46 day","date":"2020-02-03T12:00:00.000Z","updated":"2020-02-04T13:56:53.212Z","comments":true,"path":"2020/02/03/study python 46 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/03/study%20python%2046%20day/","excerpt":"","text":"java的第二个代码模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package test2;//第二种代码模型，简单java类的扩充//要求通过java程序描述dept-emp关系，使用字段：// dept：deptno,dname,loc;// emp:enpno,ename,job,sal,comm,deptno,mgr//在dept-emp表的关系里面存在如下关系：// 一个部门有多个雇员// 一个雇员有一个或者零个领导//第一步：实现基本字段的转换//第二步：外键关系 //一个雇员属于一个部门，应该在雇员里面保存部门信息 //一个部门有多个雇员，要用对象数组表示，修改Dept类 //一个雇员属于一个领导（领导也是一个雇员）//第三步：设置并取得数据// 对于这种映射的方式一定要分两步完成：// 第一步：根据结构设置数据// 第二步：根据结构取出数据 class Dept&#123; private int deptno; private String dname; private String loc; private Emp emps[];//多个雇员 public void setEmps(Emp [] emps) &#123; this.emps=emps; &#125; public Emp[] getEmps() &#123; return this.emps; &#125; public int getDeptno() &#123; return deptno; &#125; public void setDeptno(int deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public Dept(int deptno, String dname, String loc) &#123; super(); this.deptno = deptno; this.dname = dname; this.loc = loc; &#125; public Dept() &#123; &#125; public String getInfo() &#123; return \"部门编号\"+this.deptno+\",名字\"+this.dname+\",位置\"+this.loc; &#125; &#125;class Emp&#123; private int empno; private String ename; private String job; private double sal; private double comm; private Emp mgr;//表示对于部门领导 public void setMgr(Emp mgr) &#123; this.mgr=mgr; &#125; public Emp getMgr() &#123; return this.mgr; &#125; private Dept dept;//表示对于的部门信息 public void setDept(Dept dept) &#123; this.dept=dept; &#125; public Dept getDept() &#123; return this.dept; &#125; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public double getSal() &#123; return sal; &#125; public void setSal(double sal) &#123; this.sal = sal; &#125; public double getComm() &#123; return comm; &#125; public void setComm(double comm) &#123; this.comm = comm; &#125; public Emp(int empno, String ename, String job, double sal, double comm) &#123; super(); this.empno = empno; this.ename = ename; this.job = job; this.sal = sal; this.comm = comm; &#125; public Emp() &#123; &#125; public String getInfo() &#123; return \"员工编号\"+this.empno+\"雇员名称\"+this.ename+\"雇员职位\"+this.job+\"雇员工资\"+this.sal+\"雇员佣金\"+this.comm; &#125; &#125;public class test2 &#123; public static void main(String []args) &#123; //第一步：设置数据 //1.产生独立对象 Dept dept=new Dept(10,\"kaifa\",\"new your\");//部门信息 Emp ea=new Emp(7361,\"huahua\",\"qiaodaima\",800,0.00);//一个雇员信息 Emp eb=new Emp(7323,\"tom\",\"money\",1000,1.00);//一个雇员信息 Emp ec=new Emp(7345,\"xiaohua\",\"caiwu\",900,2.00);//一个雇员信息 //2.设置雇员和领导关系 ea.setMgr(eb); eb.setMgr(ec); //3.设置雇员和部门关系 ea.setDept(dept); eb.setDept(dept); ec.setDept(dept); dept.setEmps(new Emp[] &#123;ea,eb,ec&#125;);//一个部门有多个雇员 //第二步：取出数据 //1.通过雇员找到领导信息和部门信息 System.out.println(ea.getInfo()); System.out.println(\"\\t|-\"+ea.getMgr().getInfo()); System.out.println(\"\\t|-\"+ea.getDept().getInfo()); //2.根据部门找到每个雇员以及每个雇员的领导信息 System.out.println(\"------------------\"); System.out.println(dept.getInfo()); for (int i = 0; i &lt; dept.getEmps().length; i++) &#123; System.out.println(\"\\t|-\"+dept.getEmps()[i].getInfo()); if(dept.getEmps()[i].getMgr()!=null) &#123; System.out.println(\"\\t\\t|-\"+dept.getEmps()[i].getMgr().getInfo()); &#125; &#125; &#125;&#125;//总结：可以将任意给出的数据表直接转换为类的形式，并可以设置或取出所有数据//存在问题:增加和删除雇员比较麻烦 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test3;//一对多关系题目1//题目：省份---城市//第一步：先写出基本字段class Province&#123; private int pid; private String name; private City cities[]; public void setCities(City cities[]) &#123; this.cities=cities; &#125; public City[] getCities() &#123; return this.cities; &#125; //setter，getter和无参构造略 public Province(int pid,String name) &#123; this.pid=pid; this.name=name; &#125; public String getInfo() &#123; return \"省份编号\"+this.pid+\"省份名称\"+this.name; &#125;&#125;class City&#123; private int cid; private String name; private Province province; public void setProvince(Province province) &#123; this.province=province; &#125; public Province getProvince() &#123; return this.province; &#125; //setter，getter和无参构造略 public City(int cid,String name) &#123; this.cid=cid; this.name=name; &#125; public String getInfo() &#123; return \"城市编号\"+this.cid+\"城市名称\"+this.name; &#125; &#125;public class test3 &#123; public static void main(String [] args) &#123; Province pro=new Province(1,\"河北省\"); City c1=new City(1001,\"唐山\"); City c2=new City(1002,\"秦皇岛\"); City c3=new City(1003,\"石家庄\"); c1.setProvince(pro); c2.setProvince(pro); c3.setProvince(pro); pro.setCities(new City[] &#123;c1,c2,c3&#125;); System.out.println(c2.getProvince().getInfo()); for (int i = 0; i &lt; pro.getCities().length; i++) &#123; System.out.println(pro.getCities()[i].getInfo()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package test4;//一对多题目2：类型---子类型---商品//可以通过一个类型找到它对应的全部子类型//可以通过一个类型找到它的所有商品，以及每个商品对应的子类型；//可以通过一个子类型找到所有对应的全部商品class Item&#123; private int iid; private String name; private String note; private Subitem subitems[]; private Product products[]; public Item(int iid,String name,String note) &#123; this.iid=iid; this.name=name; this.note=note; &#125; public void setSubitems(Subitem subitems[]) &#123; this.subitems=subitems; &#125; public Subitem [] getSubitems() &#123; return this.subitems; &#125; public void setProducts(Product [] products) &#123; this.products=products; &#125; public Product [] getProducts() &#123; return this.products; &#125; public String getInfo() &#123; return \"类型编号\"+this.iid+\"类型名称\"+this.name+\"类型描述\"+this.note; &#125;&#125;class Subitem&#123; private int sid; private String name; private String note; private Item item; private Product products[]; public Subitem(int sid,String name,String note) &#123; this.sid=sid; this.name=name; this.note=note; &#125; public void setItem(Item item) &#123; this.item=item; &#125; public Item getItem() &#123; return this.item; &#125; public void setProducts(Product[] products) &#123; this.products=products; &#125; public Product [] getProducts() &#123; return this.products; &#125; public String getInfo() &#123; return \"子类型编号\"+this.sid+\"子类型名称\"+this.name+\"子类型描述\"+this.note; &#125;&#125;class Product&#123; private int pid; private String name; private double price; private Item item; private Subitem subitem; public Product(int pid,String name,double price) &#123; this.pid=pid; this.name=name; this.price=price; &#125; public void setItem(Item item) &#123; this.item=item; &#125; public Item getItem() &#123; return this.item; &#125; public void setSubitem(Subitem subitem) &#123; this.subitem=subitem; &#125; public Subitem getSubitems() &#123; return this.subitem; &#125; public String getInfo() &#123; return \"产品编号\"+this.pid+\"产品名称\"+this.name+\"产品价格\"+this.price; &#125;&#125;public class test4 &#123; public static void main(String[] args) &#123; Item item=new Item(1,\"厨房用具\",\"-\"); Subitem suba=new Subitem(1001,\"厨具\",\"-\"); Subitem subb=new Subitem(1003,\"刀具\",\"-\"); Subitem subc=new Subitem(1002,\"餐具\",\"-\"); Product proa=new Product(90001,\"蒸锅\",500); Product prob=new Product(90002,\"炒锅\",1000); Product proc=new Product(90003,\"菜刀\",1500); Product prod=new Product(90004,\"小刀\",80); Product proe=new Product(90005,\"青花瓷\",800); Product prof=new Product(90006,\"水晶筷子\",8000); suba.setItem(item); subb.setItem(item); subc.setItem(item); item.setSubitems(new Subitem[] &#123;suba,subb,subc&#125;); proa.setSubitem(suba); proa.setItem(item); prob.setSubitem(suba); prob.setItem(item); proc.setSubitem(subb); proc.setItem(item); prod.setSubitem(subb); prod.setItem(item); proe.setSubitem(subc); proe.setItem(item); prof.setSubitem(subc); prof.setItem(item); suba.setProducts(new Product [] &#123;proa,prob&#125;); subb.setProducts(new Product [] &#123;proc,prod&#125;); subc.setProducts(new Product [] &#123;proe,prof&#125;); item.setProducts(new Product[] &#123;proa,prob,proc,prod,proe,prof&#125;); System.out.println(item.getInfo()); for (int i = 0; i &lt; item.getSubitems().length; i++) &#123; System.out.println(item.getSubitems()[i].getInfo()); &#125; System.out.println(\"-------------------\"); System.out.println(item.getInfo()); for (int i = 0; i &lt; item.getProducts().length; i++) &#123; System.out.println(\"\\t\"+item.getProducts()[i].getInfo()); System.out.println(\"\\t\\t\"+item.getProducts()[i].getSubitems().getInfo()); &#125; System.out.println(\"-------------------\"); System.out.println(subb.getInfo()); for (int i = 0; i &lt; subb.getProducts().length; i++) &#123; System.out.println(subb.getProducts()[i].getInfo()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package test5;//多对多关系-题目3class Admin&#123; private String aid; private String password; private Role role; public Admin(String aid, String password) &#123; this.aid = aid; this.password = password; &#125; public void setRole(Role role) &#123; this.role=role; &#125; public Role getRole() &#123; return this.role; &#125; public String getInfo() &#123; return \"管理员编号\"+this.aid+\"， 管理员密码\"+this.password; &#125; &#125;class Role&#123; private int rid; private String title; private Admin admins[]; private Group groups []; public Role(int rid, String title) &#123; this.rid = rid; this.title = title; &#125; public void setGroups(Group [] groups) &#123; this.groups=groups; &#125; public Group [] getGroups() &#123; return this.groups; &#125; public void setAdmins(Admin [] admins) &#123; this.admins=admins; &#125; public Admin [] getAdmins() &#123; return this.admins; &#125; public String getInfo() &#123; return \"角色编号\"+this.rid+\"， 角色名称\"+this.title; &#125;&#125;class Group&#123; private int gid; private String title; private Role roles[]; private Action actions []; public Group(int gid, String title) &#123; this.gid = gid; this.title = title; &#125; public void setActions(Action [] actions) &#123; this.actions=actions; &#125; public Action [] getActions() &#123; return this.actions; &#125; public void setRoles(Role [] roles) &#123; this.roles=roles; &#125; public Role[] getRoles() &#123; return this.roles; &#125; public String getInfo() &#123; return \"权限组编号\"+this.gid+\"， 权限组名称\"+this.title; &#125;&#125;class Action&#123; private int aid; private String title; private String url; private Group group; public Action(int aid, String title, String url) &#123; this.aid = aid; this.title = title; this.url = url; &#125; public void setGroup(Group group) &#123; this.group=group; &#125; public Group getGroup() &#123; return this.group; &#125; public String getInfo() &#123; return \"权限编号\"+this.aid+\"， 权限名称\"+this.title+\"权限地址\"+this.url; &#125;&#125;public class test5 &#123; public static void main(String[] args) &#123; Admin a1=new Admin(\"admin\",\"hello\"); Admin a2=new Admin(\"mldn\",\"hello\"); Admin a3=new Admin(\"ayou\",\"hello\"); Role r1=new Role(1,\"系统管理员\"); Role r2=new Role(2,\"信息管理员\"); Group g1=new Group(10,\"信息管理\"); Group g2=new Group(11,\"用户管理\"); Group g3=new Group(12,\"数据信息管理\"); Group g4=new Group(13,\"接口信息管理\"); Group g5=new Group(14,\"备份信息管理\"); Action ac1=new Action(1001,\"新闻发布\",\"-\"); Action ac2=new Action(1002,\"新闻列表\",\"-\"); Action ac3=new Action(1003,\"新闻审核\",\"-\"); Action ac4=new Action(1004,\"增加用户\",\"-\"); Action ac5=new Action(1005,\"用户列表\",\"-\"); Action ac6=new Action(1006,\"登录日志\",\"-\"); Action ac7=new Action(1007,\"雇员数据\",\"-\"); Action ac8=new Action(1008,\"部门数据\",\"-\"); Action ac9=new Action(1009,\"公司数据\",\"-\"); Action ac10=new Action(1010,\"服务传输\",\"-\"); Action ac11=new Action(1011,\"短信平台\",\"-\"); Action ac12=new Action(1012,\"全部备份\",\"-\"); Action ac13=new Action(1013,\"局部备份\",\"-\"); a1.setRole(r1); a2.setRole(r2); a3.setRole(r2); r1.setAdmins(new Admin[] &#123;a1&#125;); r2.setAdmins(new Admin[] &#123;a1,a2&#125;); r1.setGroups(new Group[] &#123;g1,g2,g3,g4,g5&#125;); r2.setGroups(new Group [] &#123;g1,g2&#125;); g1.setRoles(new Role[] &#123;r1,r2&#125;); g2.setRoles(new Role[] &#123;r1,r2&#125;); g3.setRoles(new Role[] &#123;r1&#125;); g4.setRoles(new Role [] &#123;r1&#125;); g5.setRoles(new Role [] &#123;r1&#125;); g1.setActions(new Action[] &#123;ac1,ac2,ac3&#125;); g2.setActions(new Action[] &#123;ac4,ac5,ac6&#125;); g3.setActions(new Action[] &#123;ac7,ac8,ac9&#125;); g4.setActions(new Action[] &#123;ac10,ac11&#125;); g5.setActions(new Action[] &#123;ac12,ac13&#125;); ac1.setGroup(g1); ac2.setGroup(g1); ac3.setGroup(g1); ac4.setGroup(g2); ac5.setGroup(g2); ac6.setGroup(g2); ac7.setGroup(g3); ac8.setGroup(g3); ac9.setGroup(g3); ac10.setGroup(g4); ac11.setGroup(g4); ac12.setGroup(g5); ac13.setGroup(g5); System.out.println(a1.getInfo()); System.out.println(\"\\t-|\"+a1.getRole().getInfo()); for (int i = 0; i &lt; a1.getRole().getGroups().length; i++) &#123; System.out.println(\"\\t\\t-|\"+a1.getRole().getGroups()[i].getInfo()); for (int j = 0; j &lt; a1.getRole().getGroups()[i].getActions().length; j++) &#123; System.out.println(\"\\t\\t\\t-|\"+a1.getRole().getGroups()[i].getActions()[j].getInfo()); &#125; &#125; System.out.println(\"-------------\"); System.out.println(g2.getInfo()); for (int i = 0; i &lt; g2.getRoles().length; i++) &#123; System.out.println(\"\\t-|\"+g2.getRoles()[i].getInfo()); for (int j = 0; j &lt; g2.getRoles()[i].getAdmins().length; j++) &#123; System.out.println(\"\\t\\t-|\"+g2.getRoles()[i].getAdmins()[j].getInfo()); &#125; &#125; &#125;&#125;","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 45 代码模型-1","slug":"study python 45 day","date":"2020-02-02T12:00:00.000Z","updated":"2020-02-04T01:56:55.687Z","comments":true,"path":"2020/02/02/study python 45 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/02/study%20python%2045%20day/","excerpt":"","text":"java的第一个代码模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package test;//第一个代码模型：简单java类。//具体内容：实现一个雇员类，里面包含有雇员、姓名、基本工资、佣金。//这种功能的类在开发过程中较叫简单java类，因为这些类里面不会包含过于复杂的程序逻辑//对于简单java类而言，现在给予它的第一种开发要求：// 类名称必须存在有意义，例如：BOOK、Emp；// 类之中所有的属性必须private封装，封装后的属性必须提供setter和getter；// 类之中可以提供任意多个构造方法，但是必须保留一个无参构造方法；// 类之中不允许出现任何的输出语句，所有信息输出必须交给被调用处输出；// 类之中需要提供一个取得对象完整信息的方法，占定位getInfo；//与数据库的关系 //类名称=表名称 //属性名称（类型）=表字段（类型） //一个实例化对象=一行记录 //多个实例化对象（对象数组）=多行记录（外键）； //引用关系=外键约束class Emp&#123; private int empno; private String ename; private String job; private double sal; private double comm; public Emp() &#123; &#125; public Emp(int emp,String ena,String j,double s,double c) &#123; empno=emp; ename=ena; job=j; sal=s; comm=c; &#125; public void setEmpno(int e) &#123; empno=e; &#125; public void setEname(String e) &#123; ename=e; &#125; public void setJob(String j) &#123; job=j; &#125; public void setSal(double d) &#123; sal=d; &#125; public void setComm(double d) &#123; comm=d; &#125; public int getEmpno() &#123; return empno; &#125; public String getEname() &#123; return ename; &#125; public String getJob() &#123; return job; &#125; public double getSal() &#123; return sal; &#125; public double getComm() &#123; return comm; &#125; public String getInfo() &#123; return \"雇员变化：\"+empno+\"\\n\"+ \"雇员名称：\"+ename+\"\\n\"+ \"雇员职位：\"+job+\"\\n\"+ \"雇员工资：\"+sal+\"\\n\"+ \"佣 金：\"+comm+\"\\n\"; &#125;&#125;//测试程序//在所有类之中的setter和getter类可能不会使用到，但是依然要存在//所有的setter方法除了具备设置属性内容外，也具备有修改属性内容的特性public class test&#123; public static void main(String[] args) &#123; Emp e=new Emp(123,\"huahua\",\"web\",3000.0,1.0); System.out.println(e.getInfo()); System.out.println(\"姓名\"+e.getEname()); e.setEname(\"xiaodong\"); System.out.println(e.getInfo()); System.out.println(e.getEname()); &#125;&#125;//总结：简单java类是日后我们程序的千分之一的组成部分，//也是最重要的组成部分。","categories":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/tags/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}],"keywords":[{"name":"java 代码模型","slug":"java-代码模型","permalink":"https://yanxigun99.github.io/categories/java-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"study java day 44","slug":"study python 44 day","date":"2020-02-01T12:00:00.000Z","updated":"2020-02-01T12:19:56.278Z","comments":true,"path":"2020/02/01/study python 44 day/","link":"","permalink":"https://yanxigun99.github.io/2020/02/01/study%20python%2044%20day/","excerpt":"","text":"排序算法java 小白修理手册笔记：知识点回顾","categories":[{"name":"java 课程","slug":"java-课程","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"java 课程","slug":"java-课程","permalink":"https://yanxigun99.github.io/tags/java-%E8%AF%BE%E7%A8%8B/"}],"keywords":[{"name":"java 课程","slug":"java-课程","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B/"}]},{"title":"study java day 43","slug":"study python 43 day","date":"2020-01-31T12:00:00.000Z","updated":"2020-01-31T08:55:29.984Z","comments":true,"path":"2020/01/31/study python 43 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/31/study%20python%2043%20day/","excerpt":"","text":"排序算法java 排序算法：最全知识点","categories":[{"name":"java 排序算法","slug":"java-排序算法","permalink":"https://yanxigun99.github.io/categories/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java 排序算法","slug":"java-排序算法","permalink":"https://yanxigun99.github.io/tags/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"java 排序算法","slug":"java-排序算法","permalink":"https://yanxigun99.github.io/categories/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"study java day 42","slug":"study python 42 day","date":"2020-01-30T12:00:00.000Z","updated":"2020-01-31T08:52:38.366Z","comments":true,"path":"2020/01/30/study python 42 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/30/study%20python%2042%20day/","excerpt":"","text":"多人聊天系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232import java.awt.*;import java.awt.event.*;import java.io.*;import java.net.*;//客户端public class ChatClient extends Frame &#123; Socket s = null; //申明创建客户端端口 DataOutputStream dos = null;//申明数据输出流 DataInputStream dis = null;//申明数据输入流 private boolean bConnected = false;//判断是否连接的变量 TextField tfTxt = new TextField();//输入域 TextArea taContent = new TextArea();//显示域 Thread tRecv = new Thread(new RecvThread()); //创建线程 //main程序入口 public static void main(String[] args) &#123; new ChatClient().launchFrame(); &#125; public void launchFrame() &#123; //窗口位置和大小 setLocation(400, 300); this.setSize(300, 300); //以南北方式划分输入域和显示域 add(tfTxt, BorderLayout.SOUTH); add(taContent, BorderLayout.NORTH); pack(); //监听是否关闭窗口-----关闭窗口退出服务 this.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent arg0) &#123; disconnect(); System.exit(0); &#125; &#125;); //监听输入域 tfTxt.addActionListener(new TFListener()); //边框可见 setVisible(true); //连接服务器请求 connect(); //启动线程 tRecv.start(); &#125; //连接服务器方法 public void connect() &#123; try &#123; s = new Socket(\"127.0.0.1\", 8888);//指定连接的服务器地址和端口号 dos = new DataOutputStream(s.getOutputStream());//连接后创建输出流 dis = new DataInputStream(s.getInputStream());//连接后创建输入流System.out.println(\"connected!\"); bConnected = true;//连接成功标志 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //断开连接关闭流方法 public void disconnect() &#123; try &#123; dos.close(); dis.close(); s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //输入域监听器 private class TFListener implements ActionListener &#123; public void actionPerformed(ActionEvent e) &#123; String str = tfTxt.getText().trim();//输入内容提取 taContent.setText(str);//输入内容显示在显示域 tfTxt.setText(\"\");//输入域清空 try &#123;//System.out.println(s); dos.writeUTF(str);//用输出流输出内容给客户端 dos.flush();//刷新输出流 //dos.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; private class RecvThread implements Runnable &#123; public void run() &#123; try &#123; while(bConnected) &#123;//判断是否连接成功 String str = dis.readUTF();//输入流提取信息 //System.out.println(str); taContent.setText(taContent.getText() + str + '\\n');//信息显示在显示域 &#125; &#125; catch (SocketException e) &#123; System.out.println(\"退出了，bye!\"); &#125; catch (EOFException e) &#123; System.out.println(\"推出了，bye - bye!\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;===========================import java.io.*;import java.net.*;import java.util.*;//服务器端public class ChatServer &#123; boolean started = false; //申明判断变量 ServerSocket ss = null;//申明服务器端口 List&lt;Client&gt; clients = new ArrayList&lt;Client&gt;();//申明list集合，存放多个客户 public static void main(String[] args) &#123; new ChatServer().start(); &#125; //封装所以方法 public void start() &#123; try &#123; ss = new ServerSocket(8888);//创建8888端口 started = true;//端口创建成功标志 &#125; catch (BindException e) &#123; System.out.println(\"端口使用中....\"); System.out.println(\"请关掉相关程序并重新运行服务器！\"); System.exit(0); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; while(started) &#123; Socket s = ss.accept();//接受客户端连接 Client c = new Client(s);//创建client实例System.out.println(\"a client connected!\"); new Thread(c).start();//该client所对应的线程启动 clients.add(c);//将其加入list集合 //dis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //创建client类 实现多线程 class Client implements Runnable &#123; //申明socket、输入流、输出流、判断连接成功变量 private Socket s; private DataInputStream dis = null; private DataOutputStream dos = null; private boolean bConnected = false; //实例初始化 public Client(Socket s) &#123; this.s = s; try &#123; //创建输入输出流，将判断是否成功的连接变量设为成功 dis = new DataInputStream(s.getInputStream()); dos = new DataOutputStream(s.getOutputStream()); bConnected = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //消息发送方法，如果客户端已经退出，则把其从集合里移除 public void send(String str) &#123; try &#123; dos.writeUTF(str);//消息通过输出流发送 &#125; catch (IOException e) &#123; clients.remove(this); System.out.println(\"对方退出了！我从List里面去掉了！\"); //e.printStackTrace(); &#125; &#125; public void run() &#123; try &#123; //连接只要成功就一直执行 while(bConnected) &#123; String str = dis.readUTF();//通过输入流读取消息System.out.println(str); for(int i=0; i&lt;clients.size(); i++) &#123; Client c = clients.get(i);//从集合取出 c.send(str);//发送//System.out.println(\" a string send !\"); &#125; &#125; &#125; catch (EOFException e) &#123; System.out.println(\"Client closed!\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(dis != null) dis.close(); if(dos != null) dos.close(); if(s != null) &#123; s.close(); //s = null; &#125; &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/tags/java-%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}]},{"title":"study java day 41","slug":"study python 41 day","date":"2020-01-29T12:00:00.000Z","updated":"2020-01-31T08:48:33.145Z","comments":true,"path":"2020/01/29/study python 41 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/29/study%20python%2041%20day/","excerpt":"","text":"知识点总结java I/O流：最全知识点 java 异常捕获和处理：最全知识点 java 集合：最全知识点 java 基础类库：最全知识点 java 核心基础总结：最全知识点","categories":[{"name":"java 知识点总结","slug":"java-知识点总结","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"java 知识点总结","slug":"java-知识点总结","permalink":"https://yanxigun99.github.io/tags/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"java 知识点总结","slug":"java-知识点总结","permalink":"https://yanxigun99.github.io/categories/java-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}]},{"title":"study java day 40","slug":"study python 40 day","date":"2020-01-28T12:00:00.000Z","updated":"2020-01-31T07:50:18.313Z","comments":true,"path":"2020/01/28/study python 40 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/28/study%20python%2040%20day/","excerpt":"","text":"简单的登录界面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import javax.swing.*; 2 import java.awt.*; 3 4 public class Homework&#123; 5 6 public static void main(String[] args)&#123; 7 8 JFrame frame = new JFrame(); 9 10 JPanel panel1 = new JPanel();11 JPanel panel2 = new JPanel();12 JLabel label0 = new JLabel(\" 学生成绩管理系统\");13 JLabel label1 = new JLabel(\"用户名:\");14 JLabel label2 = new JLabel(\"密码:\");15 JTextField jtf = new JTextField(10);16 JPasswordField jpf = new JPasswordField(10);17 JButton button1 = new JButton(\"登录\");18 JButton button2 = new JButton(\"取消\");19 20 Font font1 = new Font(\"SansSerif\",Font.BOLD,50);21 Font font2 = new Font(\"SansSerif\",Font.BOLD,25);22 Font font3 = new Font(\"SansSerif\",Font.BOLD,35);23 ImageIcon icon1 = new ImageIcon(\"1.png\");24 ImageIcon icon2 = new ImageIcon(\"2.png\");25 ImageIcon icon3 = new ImageIcon(\"3.png\");26 ImageIcon icon4 = new ImageIcon(\"4.png\");27 ImageIcon icon5 = new ImageIcon(\"5.png\");28 29 frame.add(panel1);30 panel1.setSize(600, 150);31 panel1.setBackground(Color.CYAN);32 panel1.setLayout(new BorderLayout());33 panel1.add(label0,BorderLayout.CENTER);34 label0.setFont(font1);35 label0.setForeground(Color.BLUE);36 37 frame.add(panel2);38 panel2.setSize(460, 220);39 panel2.setLocation(60, 200);40 panel2.setLayout(new GridLayout(3,2,20,35));41 panel2.add(label1);42 panel2.add(jtf);43 panel2.add(label2);44 panel2.add(jpf);45 panel2.add(button1);46 panel2.add(button2);47 label1.setFont(font2);48 label2.setFont(font2);49 button1.setFont(font3);50 button2.setFont(font3);51 label1.setIcon(icon2);52 label2.setIcon(icon3);53 button1.setIcon(icon4);54 button2.setIcon(icon5);55 label1.setForeground(Color.BLUE);56 label2.setForeground(Color.BLUE);57 button1.setForeground(Color.BLUE);58 button2.setForeground(Color.BLUE);59 60 61 frame.setTitle(\"用户登录\");62 frame.setIconImage(icon1.getImage());63 frame.setSize(600,500);64 frame.setLocation(400, 300);65 frame.setLayout(null);66 frame.setResizable(false);67 frame.setVisible(true);68 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);69 &#125;70 &#125;","categories":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/tags/java-%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}]},{"title":"study java day 39","slug":"study python 39 day","date":"2020-01-27T12:00:00.000Z","updated":"2020-01-31T07:49:04.459Z","comments":true,"path":"2020/01/27/study python 39 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/27/study%20python%2039%20day/","excerpt":"","text":"java课程设计—-人事管理系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306主界面代码： 1 package PersonSystem; 2 3 import java.awt.*; 4 import java.awt.event.*; 5 import javax.swing.*; 6 import javax.swing.event.*; 7 import javax.swing.tree.*; 8 import java.net.*; 9 /** 10 * 11 * 人事管理系统主界面 12 * 13 */ 14 public class HrMain extends JFrame implements ActionListener,TreeSelectionListener 15 &#123; 16 Dimension faceSize = new Dimension(650,450); 17 Image icon; 18 //建立JTree菜单 19 JTree tree; 20 DefaultMutableTreeNode root;//人事管理系统 21 DefaultMutableTreeNode node1;//人员基本信息维护 22 DefaultMutableTreeNode node2;//部门信息管理 23 DefaultMutableTreeNode node3;//人员调动管理 24 DefaultMutableTreeNode node4;//人员考核管理 25 DefaultMutableTreeNode node5;//劳资管理 26 DefaultMutableTreeNode leafnode; 27 TreePath treePath; 28 29 //主界面面板 30 public static JSplitPane splitPane; 31 JPanel panel1; 32 JPanel panel2; 33 JPanel panel3; 34 JLabel welcome = new JLabel(); 35 JScrollPane scrollPane; 36 /** 37 * 程序初始化函数 38 */ 39 public HrMain() 40 &#123; 41 enableEvents(AWTEvent.WINDOW_EVENT_MASK); 42 this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 43 this.pack(); 44 this.setSize(faceSize); 45 this.setTitle(\"人事管理系统\"); 46 icon = getImage(\"icon.png\"); 47 this.setIconImage(icon);//设置程序图标 48 this.setResizable(false); 49 try&#123; 50 Init(); 51 &#125; 52 catch(Exception e)&#123; 53 e.printStackTrace(); 54 &#125; 55 &#125; 56 /** 57 * 程序初始化函数 58 */ 59 private void Init() throws Exception 60 &#123; 61 //添加JTree菜单 62 root = new DefaultMutableTreeNode(\"人事管理系统\"); 63 node1 = new DefaultMutableTreeNode(\"基本信息管理\"); 64 node2 = new DefaultMutableTreeNode(\"人员调动管理\"); 65 node3 = new DefaultMutableTreeNode(\"人员考核管理\"); 66 node4 = new DefaultMutableTreeNode(\"劳资管理\"); 67 //人员基本信息 68 root.add(node1); 69 leafnode = new DefaultMutableTreeNode(\"添加人员信息\"); 70 node1.add(leafnode); 71 leafnode = new DefaultMutableTreeNode(\"修改人员信息\"); 72 node1.add(leafnode); 73 leafnode = new DefaultMutableTreeNode(\"删除人员信息\"); 74 node1.add(leafnode); 75 leafnode = new DefaultMutableTreeNode(\"查询人员信息\"); 76 node1.add(leafnode); 77 leafnode = new DefaultMutableTreeNode(\"部门管理\"); 78 node1.add(leafnode); 79 //人员调动 80 root.add(node2); 81 leafnode = new DefaultMutableTreeNode(\"人员调动\"); 82 node2.add(leafnode); 83 leafnode = new DefaultMutableTreeNode(\"调动历史查询\"); 84 node2.add(leafnode); 85 //人员考核管理 86 root.add(node3); 87 leafnode = new DefaultMutableTreeNode(\"人员考核\"); 88 node3.add(leafnode); 89 leafnode = new DefaultMutableTreeNode(\"考核历史查询\"); 90 node3.add(leafnode); 91 //劳资管理 92 root.add(node4); 93 leafnode = new DefaultMutableTreeNode(\"劳资分配管理\"); 94 node4.add(leafnode); 95 leafnode = new DefaultMutableTreeNode(\"劳资历史查询\"); 96 node4.add(leafnode); 97 //生成左侧的JTree 98 tree = new JTree(root); 99 scrollPane = new JScrollPane(tree);100 scrollPane.setPreferredSize(new Dimension(150,400));101 tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);102 //生成JPanel103 panel1 = new JPanel();104 panel2 = new JPanel();105 panel3 = new JPanel();106 panel1.add(scrollPane);107 welcome.setText(\"欢迎使用人事管理系统\");108 welcome.setFont(new Font(\"Dialog\",0,16));109 panel3.add(welcome);110 //生成JSplitPane并设置参数111 splitPane = new JSplitPane();112 splitPane.setOneTouchExpandable(false);113 splitPane.setContinuousLayout(true);114 splitPane.setPreferredSize(new Dimension(150,400));115 splitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);116 splitPane.setLeftComponent(panel1);117 splitPane.setRightComponent(panel3);118 splitPane.setDividerSize(2);119 splitPane.setDividerLocation(161);120 //生成主界面121 this.setContentPane(splitPane);122 this.setVisible(true);123 //添加事件侦听124 tree.addTreeSelectionListener(this);125 //关闭程序时的操作126 this.addWindowListener(127 new WindowAdapter()&#123;128 public void windowClosing(WindowEvent e)&#123;129 System.exit(0);130 &#125;131 &#125;132 );133 &#125;134 /**135 * 事件处理136 */137 public void actionPerformed(ActionEvent e)&#123;138 139 &#125;140 /**141 * JTree事件处理142 */143 public void valueChanged(TreeSelectionEvent tse)144 &#123;145 DefaultMutableTreeNode dnode = (DefaultMutableTreeNode)tse.getPath().getLastPathComponent();146 System.out.println(\"dnode=\"+dnode);147 String node_str = dnode.toString();148 if(node_str == \"人事管理系统\")&#123;149 splitPane.setRightComponent(panel3);150 &#125;151 //人员基本信息树152 else if(node_str == \"基本信息管理\")&#123;153 //当选中后展开或关闭叶子节点154 treePath = new TreePath(node1.getPath());155 if(tree.isExpanded(treePath))156 tree.collapsePath(treePath);157 else158 tree.expandPath(treePath);159 &#125;160 else if(node_str == \"添加人员信息\")&#123;161 Node11Panel node11Panel = new Node11Panel();162 splitPane.setRightComponent(node11Panel);163 &#125;164 else if(node_str == \"修改人员信息\")&#123;165 Node12Panel node12Panel = new Node12Panel();166 splitPane.setRightComponent(node12Panel);167 &#125;168 else if(node_str == \"删除人员信息\")&#123;169 Node13Panel node13Panel = new Node13Panel();170 splitPane.setRightComponent(node13Panel);171 &#125;172 else if(node_str == \"查询人员信息\")&#123;173 Node14Panel node14Panel = new Node14Panel();174 splitPane.setRightComponent(node14Panel);175 &#125;176 else if(node_str == \"部门管理\")&#123;177 Node15Panel node15Panel = new Node15Panel();178 splitPane.setRightComponent(node15Panel);179 &#125;180 //人员调动管理树181 else if(node_str == \"人员调动管理\")&#123;182 //当选中后展开或关闭叶子节点183 treePath = new TreePath(node2.getPath());184 if(tree.isExpanded(treePath))185 tree.collapsePath(treePath);186 else187 tree.expandPath(treePath);188 &#125;189 else if(node_str == \"人员调动\")&#123;190 Node21Panel node21Panel = new Node21Panel();191 splitPane.setRightComponent(node21Panel);192 &#125;193 else if(node_str == \"调动历史查询\")&#123;194 Node22Panel node22Panel = new Node22Panel();195 splitPane.setRightComponent(node22Panel);196 &#125;197 //人员考核管理树198 else if(node_str == \"人员考核管理\")&#123;199 //当选中后展开或关闭叶子节点200 treePath = new TreePath(node3.getPath());201 if(tree.isExpanded(treePath))202 tree.collapsePath(treePath);203 else204 tree.expandPath(treePath);205 &#125;206 else if(node_str == \"人员考核\")&#123;207 Node31Panel node31Panel = new Node31Panel();208 splitPane.setRightComponent(node31Panel);209 &#125;210 else if(node_str == \"考核历史查询\")&#123;211 Node32Panel node32Panel = new Node32Panel();212 splitPane.setRightComponent(node32Panel);213 &#125;214 //劳资管理树215 else if(node_str == \"劳资管理\")&#123;216 //当选中后展开或关闭叶子节点217 treePath = new TreePath(node4.getPath());218 if(tree.isExpanded(treePath))219 tree.collapsePath(treePath);220 else221 tree.expandPath(treePath);222 &#125;223 else if(node_str == \"劳资分配管理\")&#123;224 Node41Panel node41Panel = new Node41Panel();225 splitPane.setRightComponent(node41Panel);226 &#125;227 else if(node_str == \"劳资历史查询\")&#123;228 Node42Panel node42Panel = new Node42Panel();229 splitPane.setRightComponent(node42Panel);230 &#125;231 &#125;232 /**233 * 通过给定的文件名获得图像234 */235 Image getImage(String filename)236 &#123;237 URLClassLoader urlLoader = (URLClassLoader)this.getClass().getClassLoader();238 URL url = null;239 Image image = null;240 url = urlLoader.findResource(filename);241 image = Toolkit.getDefaultToolkit().getImage(url);242 MediaTracker mediatracker = new MediaTracker(this);243 try&#123;244 mediatracker.addImage(image, 0);245 mediatracker.waitForID(0);246 &#125;247 catch(InterruptedException _ex)&#123;248 image = null;249 &#125;250 if(mediatracker.isErrorID(0))&#123;251 image = null;252 &#125;253 return image;254 &#125;255 &#125; 主类代码： 1 package PersonSystem; 2 3 import javax.swing.UIManager; 4 import java.awt.*; 5 6 /** 7 * 人事管理系统运行主类 8 */ 9 10 public class HrMS 11 &#123;12 boolean packFrame = false;13 public HrMS()14 &#123;15 HrMain frame = new HrMain();16 if(packFrame)&#123;17 frame.pack();18 &#125;19 else&#123;20 frame.validate();21 &#125;22 //设置运行时窗口的位置23 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();24 Dimension frameSize = frame.getSize();25 if(frameSize.height &gt; screenSize.height)&#123;26 frameSize.height = screenSize.height;27 &#125;28 if(frameSize.width &gt; screenSize.width)&#123;29 frameSize.width = screenSize.width;30 &#125;31 frame.setLocation((screenSize.width - frameSize.width)/2,(screenSize.height - frameSize.height)/2);32 frame.setVisible(true);33 &#125;34 public static void main(String[] args)35 &#123;36 try&#123;37 UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());38 &#125;39 catch(Exception e)&#123;40 e.printStackTrace();41 &#125;42 new HrMS();43 &#125;44 &#125; 人事管理系统—-数据库操作类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284连接数据库类主要代码： 1 package PersonSystem; 2 3 import java.sql.*; 4 /** 5 * 6 * 连接数据库的类 7 * 8 */ 9 public class Database 10 &#123; 11 private Statement stmt = null; 12 ResultSet rs = null; 13 private Connection conn = null; 14 String sql; 15 String strurl = \"jdbc:odbc:HrMS\"; 16 17 public Database()&#123; 18 &#125; 19 /** 20 * 打开数据库连接 21 */ 22 public void OpenConn() throws Exception 23 &#123; 24 try&#123; 25 Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\"); 26 conn=DriverManager.getConnection(strurl); 27 &#125; 28 catch(Exception e)&#123; 29 System.err.println(\"OpenConn:\"+e.getMessage()); 30 &#125; 31 &#125; 32 /** 33 * 执行SQL语句，返回结果集rs 34 */ 35 public ResultSet executeQuery(String sql) 36 &#123; 37 stmt = null; 38 rs = null; 39 try&#123; 40 stmt=conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY); 41 rs=stmt.executeQuery(sql); 42 &#125; 43 catch(SQLException e)&#123; 44 System.err.println(\"executeQuery:\"+e.getMessage()); 45 &#125; 46 return rs; 47 &#125; 48 /** 49 * 执行SQL语句 50 */ 51 public void executeUpdate(String sql) 52 &#123; 53 stmt = null; 54 rs = null; 55 try&#123; 56 stmt=conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY); 57 rs=stmt.executeQuery(sql); 58 conn.commit(); 59 &#125; 60 catch(SQLException e)&#123; 61 System.err.println(\"executeUpdate:\"+e.getMessage()); 62 &#125; 63 &#125; 64 public void closeStmt() 65 &#123; 66 try&#123; 67 stmt.close(); 68 &#125; 69 catch(SQLException e)&#123; 70 System.err.println(\"closeStmt:\"+e.getMessage()); 71 &#125; 72 &#125; 73 /** 74 * 关闭数据库连接 75 */ 76 public void closeConn()&#123; 77 try&#123; 78 conn.close(); 79 &#125; 80 catch(SQLException ex)&#123; 81 System.err.println(\"aq.closeConn:\"+ex.getMessage()); 82 &#125; 83 &#125; 84 /** 85 * 转换编码 86 */ 87 public static String toGBK(String str) 88 &#123; 89 try&#123; 90 if(str==null) 91 str = \"\"; 92 else 93 str = new String(str.getBytes(\"ISO-8859-1\"),\"GBK\"); 94 &#125; 95 catch(Exception e)&#123; 96 System.out.println(e); 97 &#125; 98 return str; 99 &#125;100 &#125; 有关人员信息数据库操作的类主要代码： 1 package PersonSystem; 2 3 //import java.util.*; 4 import java.sql.*; 5 import javax.swing.*; 6 /** 7 * 8 * 有关人员信息数据库操作的类 9 * 10 */ 11 public class PersonBean 12 &#123; 13 String sql; 14 ResultSet rs = null; 15 16 String field1; //PersonID 17 String field2; //Name 18 String field3; //Sex 19 String field4; //Birth 20 String field5; //Nat 21 String field6; //Address 22 String field7; //DeptID 23 String field8; //Salary 24 String field9; //Assess 25 String field10; //Other 26 27 String colName; //列名 28 String colValue; //列值 29 String colValue2; //列值 30 31 /** 32 * 添加信息 33 */ 34 public void add(String f1,String f2,String f3,String f4,String f5, 35 String f6,String f7,String f8,String f9,String f10) 36 &#123; 37 Database DB = new Database(); 38 39 this.field1 = f1; 40 this.field2 = f2; 41 this.field3 = f3; 42 this.field4 = f4; 43 this.field5 = f5; 44 this.field6 = f6; 45 this.field7 = f7; 46 this.field8 = f8; 47 this.field9 = f9; 48 this.field10 = f10; 49 50 if(field2 == null||field2.equals(\"\"))&#123; 51 JOptionPane.showMessageDialog(null, \"请输入员工姓名\",\"错误\",JOptionPane.ERROR_MESSAGE); 52 return; 53 &#125; 54 else if(field3 == null||field3.equals(\"\"))&#123; 55 JOptionPane.showMessageDialog(null, \"请输入性别\",\"错误\",JOptionPane.ERROR_MESSAGE); 56 return; 57 &#125; 58 else if(field4 == null||field4.equals(\"\"))&#123; 59 JOptionPane.showMessageDialog(null, \"请输入出生年月\",\"错误\",JOptionPane.ERROR_MESSAGE); 60 return; 61 &#125; 62 else if(field5 == null||field5.equals(\"\"))&#123; 63 JOptionPane.showMessageDialog(null, \"请输入民族\",\"错误\",JOptionPane.ERROR_MESSAGE); 64 return; 65 &#125; 66 else if(field6 == null||field6.equals(\"\"))&#123; 67 JOptionPane.showMessageDialog(null, \"请输入地址\",\"错误\",JOptionPane.ERROR_MESSAGE); 68 return; 69 &#125; 70 else if(field7 == null||field7.equals(\"\"))&#123; 71 JOptionPane.showMessageDialog(null, \"请输入部门\",\"错误\",JOptionPane.ERROR_MESSAGE); 72 return; 73 &#125; 74 else if(field8 == null||field8.equals(\"\"))&#123; 75 JOptionPane.showMessageDialog(null, \"请输入薪酬\",\"错误\",JOptionPane.ERROR_MESSAGE); 76 return; 77 &#125; 78 else&#123; 79 sql = \"insert into Person(PersonID,Name,Sex,Birth,Nat,Address,DeptID,Salary,Assess,Other)\" 80 +\"values('\"+field1+\"','\"+field2+\"','\"+field3+\"','\"+field4+\"','\"+field5+\"',\" 81 + \"'\"+field6+\"','\"+field7+\"','\"+field8+\"','\"+field9+\"','\"+field10+\"')\"; 82 try&#123; 83 DB.OpenConn(); 84 DB.executeUpdate(sql); 85 JOptionPane.showMessageDialog(null, \"成功添加一条记录！\"); 86 &#125; 87 catch(Exception e)&#123; 88 System.out.println(e); 89 JOptionPane.showMessageDialog(null, \"保存失败\",\"错误\",JOptionPane.ERROR_MESSAGE); 90 &#125; 91 finally&#123; 92 DB.closeStmt(); 93 DB.closeConn(); 94 &#125; 95 &#125; 96 &#125; 97 98 /** 99 * 修改信息100 */101 public void modify(String f1,String f2,String f3,String f4,String f5,102 String f6,String f7,String f8,String f9,String f10)103 &#123;104 Database DB = new Database();105 106 this.field1 = f1;107 this.field2 = f2;108 this.field3 = f3;109 this.field4 = f4;110 this.field5 = f5;111 this.field6 = f6;112 this.field7 = f7;113 this.field8 = f8;114 this.field9 = f9;115 this.field10 = f10;116 117 if(field2 == null||field2.equals(\"\"))&#123;118 JOptionPane.showMessageDialog(null, \"请输入员工姓名\",\"错误\",JOptionPane.ERROR_MESSAGE);119 return;120 &#125;121 else if(field3 == null||field3.equals(\"\"))&#123;122 JOptionPane.showMessageDialog(null, \"请输入性别\",\"错误\",JOptionPane.ERROR_MESSAGE);123 return;124 &#125;125 else if(field4 == null||field4.equals(\"\"))&#123;126 JOptionPane.showMessageDialog(null, \"请输入出生年月\",\"错误\",JOptionPane.ERROR_MESSAGE);127 return;128 &#125;129 else if(field5 == null||field5.equals(\"\"))&#123;130 JOptionPane.showMessageDialog(null, \"请输入民族\",\"错误\",JOptionPane.ERROR_MESSAGE);131 return;132 &#125;133 else if(field6 == null||field6.equals(\"\"))&#123;134 JOptionPane.showMessageDialog(null, \"请输入地址\",\"错误\",JOptionPane.ERROR_MESSAGE);135 return;136 &#125;137 else if(field7 == null||field7.equals(\"\"))&#123;138 JOptionPane.showMessageDialog(null, \"请输入部门\",\"错误\",JOptionPane.ERROR_MESSAGE);139 return;140 &#125;141 else if(field8 == null||field8.equals(\"\"))&#123;142 JOptionPane.showMessageDialog(null, \"请输入薪酬\",\"错误\",JOptionPane.ERROR_MESSAGE);143 return;144 &#125;145 else&#123;146 sql = \"update Person set Name= '\"+field2+\"',\"+\"Sex='\"+field3+\"','\"+\"Birth='\"+field4+\"','\"147 +\"Nat='\"+field5+\"','\"+\"Address='\"+field6+\"','\"+\"'\"+\"DeptID='\"+field7+\"','\"+\"Salary='\"+field8+\"','\"148 +\"Assess='\"+field9+\"','\"+\"Other='\"+field10+\"','\"+\"where PersonID='\"+field1+\"\";149 try&#123;150 DB.OpenConn();151 DB.executeUpdate(sql);152 JOptionPane.showMessageDialog(null, \"成功修改一条新的记录！\");153 &#125;154 catch(Exception e)&#123;155 System.out.println(e);156 JOptionPane.showMessageDialog(null, \"更新失败\",\"错误\",JOptionPane.ERROR_MESSAGE);157 &#125;158 finally&#123;159 DB.closeStmt();160 DB.closeConn();161 &#125;162 &#125;163 &#125;164 /**165 * 删除信息166 */167 public void delete(String f1)168 &#123;169 Database DB = new Database();170 this.field1 = f1;171 172 sql = \"delect from Person where PersonID =\"+field1+\"\";173 try&#123;174 DB.OpenConn();175 DB.executeUpdate(sql);176 JOptionPane.showMessageDialog(null, \"成功删除一条记录！\");177 &#125;178 catch(Exception e)&#123;179 System.out.println(e);180 JOptionPane.showMessageDialog(null, \"删除失败\",\"错误\",JOptionPane.ERROR_MESSAGE);181 &#125;182 finally&#123;183 DB.closeStmt();184 DB.closeConn();185 &#125;186 &#125;187 /**188 * 根据编号查询信息189 */190 public String[] search(String f1)191 &#123;192 Database DB = new Database();193 this.field1 = f1;194 String[] s = new String[10];195 sql = \"select * from Person where PersonID = \"+field1+\"\";196 try&#123;197 DB.OpenConn();198 DB.executeUpdate(sql);199 if(rs.next())&#123;200 s[0] = rs.getString(\"PersonID\");201 s[1] = rs.getString(\"Name\");202 s[2] = rs.getString(\"Sex\");203 s[3] = rs.getString(\"Birth\");204 s[4] = rs.getString(\"Nat\");205 s[5] = rs.getString(\"Address\");206 s[6] = rs.getString(\"DeptID\");207 s[7] = rs.getString(\"Salary\");208 s[8] = rs.getString(\"Assess\");209 s[9] = rs.getString(\"Other\");210 &#125;211 else212 s = null;213 &#125;214 catch(Exception e)&#123;215 &#125;216 finally&#123;217 DB.closeStmt();218 DB.closeConn();219 &#125;220 return s;221 &#125;222 /**223 * 人员记录综合查询（查询所有记录）224 */225 public String[][] searchAllForNode()226 &#123;227 Database DB = new Database();228 String[][] sn = null;229 int row = 0;230 int i = 0;231 sql = \"select PersonID,Name,Sex,Dept.DeptID as DeptID,B_Dept,S_Dept,Salary,Assess \"232 + \"from Dept,Person where Dept.DeptID = Person.DeptID order by PersonID\";233 try&#123;234 DB.OpenConn();235 rs = DB.executeQuery(sql);236 if(rs.last())&#123;237 row = rs.getRow();238 &#125;239 if(row==0)&#123;240 sn = new String[1][6];241 sn[0][0] = \" \";242 sn[0][1] = \" \";243 sn[0][2] = \" \";244 sn[0][3] = \" \";245 sn[0][4] = \" \";246 sn[0][5] = \" \";247 &#125;248 else&#123;249 sn = new String[row][6];250 rs.first();251 rs.previous();252 while(rs.next())&#123;253 sn[i][0] = rs.getString(\"PersonID\");254 sn[i][1] = rs.getString(\"Name\");255 sn[i][2] = rs.getString(\"Sex\");256 sn[i][3] = rs.getString(\"B_Dept\")+\"-\"+rs.getString(\"S_Dept\");257 sn[i][4] = rs.getString(\"Salary\");258 sn[i][5] = rs.getString(\"Assess\");259 i++;260 &#125;261 &#125;262 &#125;263 catch(Exception e)&#123;264 265 &#125;266 finally&#123;267 DB.closeStmt();268 DB.closeConn();269 &#125;270 return sn;271 &#125;272 /**273 * 修改信息274 */275 public void updateDept(String f1,String f7)276 &#123;277 Database DB = new Database();278 this.field1 = f1;279 this.field7 = f7;280 281 sql = \"update Person set DeptID = \"+field7+\"where PersonID =\"+field1;282 try&#123;283 DB.OpenConn();284 DB.executeUpdate(sql);285 JOptionPane.showMessageDialog(null, \"人员调动成功！\");286 &#125;287 catch(Exception e)&#123;288 System.out.println(e);289 JOptionPane.showMessageDialog(null, \"更新失败\",\"错误\",JOptionPane.ERROR_MESSAGE);290 &#125;291 finally&#123;292 DB.closeStmt();293 DB.closeConn();294 &#125;295 &#125;296 /**297 * 修改信息298 */299 public void updateSalary(String f1,String f8)300 &#123;301 Database DB = new Database();302 this.field1 = f1;303 this.field8 = f8;304 305 sql = \"update Person set Salary ='\"+field8+\"'where PersonID =\"+field1;306 try&#123;307 DB.OpenConn();308 DB.executeUpdate(sql);309 JOptionPane.showMessageDialog(null, \"劳资更改成功！\");310 &#125;311 catch(Exception e)&#123;312 System.out.println(e);313 JOptionPane.showMessageDialog(null, \"更新失败\",\"错误\",JOptionPane.ERROR_MESSAGE);314 &#125;315 finally&#123;316 DB.closeStmt();317 DB.closeConn();318 &#125;319 &#125;320 /**321 * 修改信息322 */323 public void updateAssess(String f1,String f9)324 &#123;325 Database DB = new Database();326 this.field1 = f1;327 this.field8 = f9;328 329 sql = \"update Person set Assess ='\"+field9+\"'where PersonID =\"+field1;330 try&#123;331 DB.OpenConn();332 DB.executeUpdate(sql);333 JOptionPane.showMessageDialog(null, \"人员考核成功！\");334 &#125;335 catch(Exception e)&#123;336 System.out.println(e);337 JOptionPane.showMessageDialog(null, \"更新失败\",\"错误\",JOptionPane.ERROR_MESSAGE);338 &#125;339 finally&#123;340 DB.closeStmt();341 DB.closeConn();342 &#125;343 &#125;344 /**345 * 人员信息综合查询346 */347 public String[][] searchAll()348 &#123;349 Database DB = new Database();350 String[][] sn = null;351 int row = 0;352 int i = 0;353 sql = \"select * from Person order by PersonID\";354 try&#123;355 DB.OpenConn();356 rs = DB.executeQuery(sql);357 if(rs.last())&#123;358 row = rs.getRow();359 &#125;360 if(row==0)&#123;361 sn = new String[1][6];362 sn[0][0] = \" \";363 sn[0][1] = \" \";364 sn[0][2] = \" \";365 sn[0][3] = \" \";366 sn[0][4] = \" \";367 sn[0][5] = \" \";368 &#125;369 else&#123;370 sn = new String[row][6];371 rs.first();372 rs.previous();373 while(rs.next())&#123;374 sn[i][0] = rs.getString(\"PersonID\");375 sn[i][1] = rs.getString(\"Name\");376 sn[i][2] = rs.getString(\"Sex\");377 sn[i][3] = rs.getString(\"Nat\");378 sn[i][4] = rs.getString(\"Address\");379 DeptBean dp = new DeptBean();380 sn[i][5] = dp.getDeptStr(rs.getString(\"DeptID\"));381 i++;382 &#125;383 &#125;384 &#125;385 catch(Exception e)&#123;386 387 &#125;388 finally&#123;389 DB.closeStmt();390 DB.closeConn();391 &#125;392 return sn;393 &#125;394 /**395 * 获得新的ID396 */397 public int getId()398 &#123;399 Database DB = new Database();400 int ID = 1;401 sql = \"select max(PersonID) from Person\";402 try&#123;403 DB.OpenConn();404 rs = DB.executeQuery(sql);405 if(rs.next())&#123;406 ID = rs.getInt(1) + 1;407 &#125;408 else409 ID = 1;410 &#125;411 catch(Exception e)&#123;412 413 &#125;414 finally&#123;415 DB.closeStmt();416 DB.closeConn();417 &#125;418 return ID;419 &#125;420 /**421 * 取得DeptID422 */423 public String getDeptId(String f1)424 &#123;425 Database DB = new Database();426 sql = \"select DeptID from Person where personID = \"+f1;427 String deptid = null;428 try&#123;429 DB.OpenConn();430 rs = DB.executeQuery(sql);431 if(rs.next())&#123;432 deptid = rs.getString(\"DeptID\");433 &#125;434 else435 deptid = \"\";436 &#125;437 catch(Exception e)&#123;438 439 &#125;440 finally&#123;441 DB.closeStmt();442 DB.closeConn();443 &#125;444 return deptid;445 &#125;446 /**447 * 取得Name448 */449 public String getName(String f1)450 &#123;451 Database DB = new Database();452 sql = \"select Name from Person where personID = \"+f1;453 String name = null;454 try&#123;455 DB.OpenConn();456 rs = DB.executeQuery(sql);457 if(rs.next())&#123;458 name = rs.getString(\"DeptID\");459 &#125;460 else461 name = \"\";462 &#125;463 catch(Exception e)&#123;464 465 &#125;466 finally&#123;467 DB.closeStmt();468 DB.closeConn();469 &#125;470 return name;471 &#125;472 /**473 * 获得表中的所有编号474 */475 public String[] getAllId()476 &#123;477 String[] s = null;478 int row = 0;479 int i = 0;480 Database DB = new Database();481 sql = \"select PersonID,name from Person order by PersonID\";482 try&#123;483 DB.OpenConn();484 rs = DB.executeQuery(sql);485 if(rs.last())&#123;486 row = rs.getRow();487 &#125;488 if(row == 0)&#123;489 s = null;490 &#125;491 else&#123;492 s = new String[row];493 rs.first();494 rs.previous();495 while(rs.next())&#123;496 s[i] = rs.getString(1)+\"-\"+rs.getShort(2);497 i++;498 &#125;499 &#125;500 &#125;501 catch(Exception e)&#123;502 System.out.println(e);503 &#125;504 finally&#123;505 DB.closeStmt();506 DB.closeConn();507 &#125;508 return s;509 &#125;510 &#125;有关部门信息数据库操作的类主要代码： 1 package PersonSystem; 2 3 //import java.util.*; 4 import java.sql.*; 5 import javax.swing.*; 6 7 /** 8 * 9 * 有关部门信息数据库操作的类 10 * 11 */ 12 public class DeptBean 13 &#123; 14 String sql; 15 ResultSet rs = null; 16 17 String field1; //DeptID 18 String field2; //B_Dept 19 String field3; //S_Dept 20 21 String colName; //列名 22 String colValue; //列值 23 String colValue2; //列值 24 25 /** 26 * 添加信息 27 */ 28 public void add(String f1,String f2,String f3) 29 &#123; 30 Database DB = new Database(); 31 32 this.field1 = f1; 33 this.field2 = f2; 34 this.field3 = f3; 35 36 if(field2 == null||field2.equals(\"\"))&#123; 37 JOptionPane.showMessageDialog(null, \"请输入一级部门名称\",\"错误\",JOptionPane.ERROR_MESSAGE); 38 return; 39 &#125; 40 else if(field3 == null||field3.equals(\"\"))&#123; 41 JOptionPane.showMessageDialog(null, \"请输入二级部门名称\",\"错误\",JOptionPane.ERROR_MESSAGE); 42 return; 43 &#125; 44 else&#123; 45 sql = \"insert into Dept(DeptID,B_Dept,S_Dept) values('\"+field1+\"','\"+field2+\"','\"+field3+\"')\"; 46 try&#123; 47 DB.OpenConn(); 48 DB.executeUpdate(sql); 49 JOptionPane.showMessageDialog(null, \"成功添加一条新的记录！\"); 50 &#125; 51 catch(Exception e)&#123; 52 System.out.println(e); 53 JOptionPane.showMessageDialog(null, \"保存失败\",\"错误\",JOptionPane.ERROR_MESSAGE); 54 &#125; 55 finally&#123; 56 DB.closeStmt(); 57 DB.closeConn(); 58 &#125; 59 &#125; 60 &#125; 61 /** 62 * 修改信息 63 */ 64 public void modify(String f1,String f2,String f3) 65 &#123; 66 Database DB = new Database(); 67 68 this.field1 = f1; 69 this.field2 = f2; 70 this.field3 = f3; 71 72 if(field2 == null||field2.equals(\"\"))&#123; 73 JOptionPane.showMessageDialog(null, \"请输入一级部门名称\",\"错误\",JOptionPane.ERROR_MESSAGE); 74 return; 75 &#125; 76 else if(field3 == null||field3.equals(\"\"))&#123; 77 JOptionPane.showMessageDialog(null, \"请输入二级部门名称\",\"错误\",JOptionPane.ERROR_MESSAGE); 78 return; 79 &#125; 80 else&#123; 81 sql = \"update Dept set B_Dept = '\"+field2+\"',S_Dept = '\"+field3+\"' where DeptID = \"+field1+\"\"; 82 try&#123; 83 DB.OpenConn(); 84 DB.executeUpdate(sql); 85 JOptionPane.showMessageDialog(null, \"成功修改一条新的记录！\"); 86 &#125; 87 catch(Exception e)&#123; 88 System.out.println(e); 89 JOptionPane.showMessageDialog(null, \"更新失败\",\"错误\",JOptionPane.ERROR_MESSAGE); 90 &#125; 91 finally&#123; 92 DB.closeStmt(); 93 DB.closeConn(); 94 &#125; 95 &#125; 96 &#125; 97 /** 98 * 删除信息 99 */100 public void delete(String f1)101 &#123;102 Database DB = new Database();103 this.field1 = f1;104 105 sql = \"delect from Dept where DeptID =\"+field1+\"\";106 try&#123;107 DB.OpenConn();108 DB.executeUpdate(sql);109 JOptionPane.showMessageDialog(null, \"成功删除一条记录！\");110 &#125;111 catch(Exception e)&#123;112 System.out.println(e);113 JOptionPane.showMessageDialog(null, \"删除失败\",\"错误\",JOptionPane.ERROR_MESSAGE);114 &#125;115 finally&#123;116 DB.closeStmt();117 DB.closeConn();118 &#125;119 &#125;120 /**121 * 根据编号查询信息122 */123 public String[] search(String f1)124 &#123;125 Database DB = new Database();126 this.field1 = f1;127 String[] s = new String[10];128 sql = \"select * from Dept where DeptID = \"+field1+\"\";129 try&#123;130 DB.OpenConn();131 DB.executeUpdate(sql);132 if(rs.next())&#123;133 s[0] = rs.getString(\"DeptID\");134 s[1] = rs.getString(\"B_Dept\");135 s[2] = rs.getString(\"S_Dept\");136 &#125;137 else138 s = null;139 &#125;140 catch(Exception e)&#123;141 &#125;142 finally&#123;143 DB.closeStmt();144 DB.closeConn();145 &#125;146 return s;147 &#125;148 /**149 * 查询所有记录150 */151 public String[][] searchAll()152 &#123;153 Database DB = new Database();154 String[][] sn = null;155 int row = 0;156 int i = 0;157 sql = \"select * from Dept order by DeptID\";158 try&#123;159 DB.OpenConn();160 rs = DB.executeQuery(sql);161 if(rs.last())&#123;162 row = rs.getRow();163 &#125;164 if(row==0)&#123;165 sn = new String[1][3];166 sn[0][0] = \" \";167 sn[0][1] = \" \";168 sn[0][2] = \" \";169 &#125;170 else&#123;171 sn = new String[row][3];172 rs.first();173 rs.previous();174 while(rs.next())&#123;175 sn[i][0] = rs.getString(\"DeptID\");176 sn[i][1] = rs.getString(\"B_Dept\");177 sn[i][2] = rs.getString(\"S_Dept\");178 i++;179 &#125;180 &#125;181 &#125;182 catch(Exception e)&#123;183 184 &#125;185 finally&#123;186 DB.closeStmt();187 DB.closeConn();188 &#125;189 return sn;190 &#125;191 /**192 * 为人事管理提供查询193 */194 @SuppressWarnings(\"null\")195 public String[] searchAllForNode()196 &#123;197 Database DB = new Database();198 String[] sn = null;199 int row = 0;200 int i = 0;201 sql = \"select * from Dept order by DeptID\";202 try&#123;203 DB.OpenConn();204 rs = DB.executeQuery(sql);205 if(rs.last())&#123;206 row = rs.getRow();207 &#125;208 if(row==0)&#123;209 sn[0] = \"\";210 sn[1] = \"\";211 sn[2] = \"\";212 &#125;213 else&#123;214 sn = new String[row];215 rs.first();216 rs.previous();217 while(rs.next())&#123;218 sn[i] = rs.getString(\"DeptID\")+\"-\"+rs.getString(\"B_Dept\")+\"-\"+rs.getString(\"S_Dept\");219 i++;220 &#125;221 &#125;222 &#125;223 catch(Exception e)&#123;224 225 &#125;226 finally&#123;227 DB.closeStmt();228 DB.closeConn();229 &#125;230 return sn;231 &#125;232 /**233 * 人员记录综合查询（按ID查询）234 */235 public String[][] searchAll(String f1)236 &#123;237 this.field1 = f1;238 Database DB = new Database();239 String[][] sn = null;240 int row = 0;241 int i = 0;242 sql = \"select * from Dept where DeptID=\"+field1+\" order by DeptID\";243 try&#123;244 DB.OpenConn();245 rs = DB.executeQuery(sql);246 if(rs.last())&#123;247 row = rs.getRow();248 &#125;249 if(row==0)&#123;250 sn = null;251 &#125;252 else&#123;253 sn = new String[row][6];254 rs.first();255 rs.previous();256 while(rs.next())&#123;257 sn[i][0] = rs.getString(\"DeptID\");258 sn[i][1] = rs.getString(\"B_Dept\");259 sn[i][2] = rs.getString(\"S_Dept\");260 i++;261 &#125;262 &#125;263 &#125;264 catch(Exception e)&#123;265 266 &#125;267 finally&#123;268 DB.closeStmt();269 DB.closeConn();270 &#125;271 return sn;272 &#125;273 /**274 * 获得新的ID275 */276 public int getId()277 &#123;278 Database DB = new Database();279 int ID = 1;280 sql = \"select max(DeptID) from Dept\";281 try&#123;282 DB.OpenConn();283 rs = DB.executeQuery(sql);284 if(rs.next())&#123;285 ID = rs.getInt(1) + 1;286 &#125;287 else288 ID = 1;289 &#125;290 catch(Exception e)&#123;291 292 &#125;293 finally&#123;294 DB.closeStmt();295 DB.closeConn();296 &#125;297 return ID;298 &#125;299 /**300 * 获得表中的所有编号301 */302 public String[] getAllId()303 &#123;304 String[] s = null;305 int row = 0;306 int i = 0;307 Database DB = new Database();308 sql = \"select DeptID from DeptType order by DeptID\";309 try&#123;310 DB.OpenConn();311 rs = DB.executeQuery(sql);312 if(rs.last())&#123;313 row = rs.getRow();314 &#125;315 if(row == 0)&#123;316 s = null;317 &#125;318 else&#123;319 s = new String[row];320 rs.first();321 rs.previous();322 while(rs.next())&#123;323 s[i] = rs.getString(1);324 i++;325 &#125;326 &#125;327 &#125;328 catch(Exception e)&#123;329 System.out.println(e);330 &#125;331 finally&#123;332 DB.closeStmt();333 DB.closeConn();334 &#125;335 return s;336 &#125;337 /**338 * 根据编号查询信息339 */340 public String getDeptStr(String f1)341 &#123;342 Database DB = new Database();343 this.field1 = f1;344 String s = \"\";345 sql = \"select * from Dept where DeptID =\"+field1+\"\";346 try&#123;347 DB.OpenConn();348 rs = DB.executeQuery(sql);349 if(rs.next())&#123;350 s = rs.getString(\"B_Dept\")+\"-\"+rs.getString(\"S_Dept\");351 &#125;352 else353 s = null;354 &#125;355 catch(Exception e)&#123;356 357 &#125;358 finally&#123;359 DB.closeStmt();360 DB.closeConn();361 &#125;362 return s;363 &#125;364 &#125;有历史流水数据库操作的类主要代码： 1 package PersonSystem; 2 3 //import java.util.*; 4 import java.sql.*; 5 import javax.swing.*; 6 import java.text.DateFormat; 7 8 /** 9 * 10 * 有历史流水数据库操作的类 11 * 12 */ 13 public class HistrjnBean 14 &#123; 15 String sql; 16 ResultSet rs = null; 17 18 String field1; //JourNo 19 String field2; //FromAcc 20 String field3; //OldInfo 21 String field4; //NewInfo 22 String field5; //ChgTime 23 String field6; //RegDate 24 String field7; //PersonID 25 26 String colName; //列名 27 String colValue; //列值 28 String colValue2; //列值 29 30 /** 31 * 添加信息 32 */ 33 public void add(String f1,String f2,String f3,String f4,String f5,String f6,String f7) 34 &#123; 35 Database DB = new Database(); 36 37 this.field1 = f1; 38 this.field2 = f2; 39 this.field3 = f3; 40 this.field4 = f4; 41 this.field5 = f5; 42 this.field6 = f6; 43 this.field7 = f7; 44 45 sql = \"insert into Histrjn(JourNo,FromAcc,OldInfo,NewInfo,ChgTime,RegDate,PersonID)\" 46 +\"values('\"+field1+\"','\"+field2+\"','\"+field3+\"','\"+field4+\"','\"+field5+\"',\" 47 + \"'\"+field6+\"','\"+field7+\"')\"; 48 try&#123; 49 DB.OpenConn(); 50 DB.executeUpdate(sql); 51 &#125; 52 catch(Exception e)&#123; 53 System.out.println(e); 54 JOptionPane.showMessageDialog(null, \"保存失败\",\"错误\",JOptionPane.ERROR_MESSAGE); 55 &#125; 56 finally&#123; 57 DB.closeStmt(); 58 DB.closeConn(); 59 &#125; 60 &#125; 61 /** 62 * 查询所有记录 63 */ 64 public String[][] searchAllForDept() 65 &#123; 66 Database DB = new Database(); 67 DeptBean deptBean = new DeptBean(); 68 69 String[][] sn = null; 70 int row = 0; 71 int i = 0; 72 sql = \"select * from Histrjn,Person where Fromacc='人员调动' and \" 73 + \"Person.PersonID=Histrjn.PersonID order by Histrjn.PersonID,ChgTime\"; 74 try&#123; 75 DB.OpenConn(); 76 rs = DB.executeQuery(sql); 77 if(rs.last())&#123; 78 row = rs.getRow(); 79 &#125; 80 if(row==0)&#123; 81 sn = new String[1][6]; 82 sn[0][0] = \" \"; 83 sn[0][1] = \" \"; 84 sn[0][2] = \" \"; 85 sn[0][3] = \" \"; 86 sn[0][4] = \" \"; 87 sn[0][5] = \" \"; 88 &#125; 89 else&#123; 90 sn = new String[row][6]; 91 rs.first(); 92 rs.previous(); 93 while(rs.next())&#123; 94 sn[i][0] = rs.getString(\"JourNo\"); 95 sn[i][1] = rs.getString(\"Name\"); 96 sn[i][2] = deptBean.getDeptStr(rs.getString(\"OldInfo\")); 97 sn[i][3] = deptBean.getDeptStr(rs.getString(\"NewInfo\")); 98 sn[i][4] = rs.getString(\"ChgTime\"); 99 sn[i][5] = rs.getString(\"RegDate\");100 i++;101 &#125;102 &#125;103 &#125;104 catch(Exception e)&#123;105 106 &#125;107 finally&#123;108 DB.closeStmt();109 DB.closeConn();110 &#125;111 return sn;112 &#125;113 /**114 * 查询所有记录115 */116 public String[][] searchAllForSalary()117 &#123;118 Database DB = new Database();119 120 String[][] sn = null;121 int row = 0;122 int i = 0;123 sql = \"select * from Histrjn,Person where Fromacc='劳资分配' and \"124 + \"Person.PersonID=Histrjn.PersonID order by Histrjn.PersonID,ChgTime\";125 try&#123;126 DB.OpenConn();127 rs = DB.executeQuery(sql);128 if(rs.last())&#123;129 row = rs.getRow();130 &#125;131 if(row==0)&#123;132 sn = new String[1][6];133 sn[0][0] = \" \";134 sn[0][1] = \" \";135 sn[0][2] = \" \";136 sn[0][3] = \" \";137 sn[0][4] = \" \";138 sn[0][5] = \" \";139 &#125;140 else&#123;141 sn = new String[row][6];142 rs.first();143 rs.previous();144 while(rs.next())&#123;145 sn[i][0] = rs.getString(\"JourNo\");146 sn[i][1] = rs.getString(\"Name\");147 sn[i][2] = rs.getString(\"OldInfo\");148 sn[i][3] = rs.getString(\"NewInfo\");149 sn[i][4] = rs.getString(\"ChgTime\");150 sn[i][5] = rs.getString(\"RegDate\");151 i++;152 &#125;153 &#125;154 &#125;155 catch(Exception e)&#123;156 157 &#125;158 finally&#123;159 DB.closeStmt();160 DB.closeConn();161 &#125;162 return sn;163 &#125;164 /**165 * 查询所有记录166 */167 public String[][] searchAllForAssess()168 &#123;169 Database DB = new Database();170 171 String[][] sn = null;172 int row = 0;173 int i = 0;174 sql = \"select * from Histrjn,Person where Fromacc='人员考核' and \"175 + \"Person.PersonID=Histrjn.PersonID order by Histrjn.PersonID,ChgTime\";176 try&#123;177 DB.OpenConn();178 rs = DB.executeQuery(sql);179 if(rs.last())&#123;180 row = rs.getRow();181 &#125;182 if(row==0)&#123;183 sn = new String[1][6];184 sn[0][0] = \" \";185 sn[0][1] = \" \";186 sn[0][2] = \" \";187 sn[0][3] = \" \";188 sn[0][4] = \" \";189 sn[0][5] = \" \";190 &#125;191 else&#123;192 sn = new String[row][6];193 rs.first();194 rs.previous();195 while(rs.next())&#123;196 sn[i][0] = rs.getString(\"JourNo\");197 sn[i][1] = rs.getString(\"Name\");198 sn[i][2] = rs.getString(\"OldInfo\");199 sn[i][3] = rs.getString(\"NewInfo\");200 sn[i][4] = rs.getString(\"ChgTime\");201 sn[i][5] = rs.getString(\"RegDate\");202 i++;203 &#125;204 &#125;205 &#125;206 catch(Exception e)&#123;207 208 &#125;209 finally&#123;210 DB.closeStmt();211 DB.closeConn();212 &#125;213 return sn;214 &#125;215 /**216 * 获得新的ID217 */218 public int getId()219 &#123;220 Database DB = new Database();221 int ID = 1;222 sql = \"select max(JourNo) from Histrjn\";223 try&#123;224 DB.OpenConn();225 rs = DB.executeQuery(sql);226 if(rs.next())&#123;227 ID = rs.getInt(1) + 1;228 &#125;229 else230 ID = 1;231 &#125;232 catch(Exception e)&#123;233 234 &#125;235 finally&#123;236 DB.closeStmt();237 DB.closeConn();238 &#125;239 return ID;240 &#125;241 /**242 * 获得新的ID243 */244 public int getChgTime(String f2,String f7)245 &#123;246 Database DB = new Database();247 int ID = 1;248 sql = \"select max(ChgTime) from Histrjn where FromAcc='\"+f2+\"' and PersonID=\"+f7;249 System.out.println(\"sql=\"+sql);250 try&#123;251 DB.OpenConn();252 rs = DB.executeQuery(sql);253 if(rs.next())&#123;254 ID = rs.getInt(1) + 1;255 &#125;256 else257 ID = 1;258 &#125;259 catch(Exception e)&#123;260 261 &#125;262 finally&#123;263 DB.closeStmt();264 DB.closeConn();265 &#125;266 return ID;267 &#125;268 /**269 * 判断是否有记录270 */271 public boolean isRows(String f7)272 &#123;273 Database DB = new Database();274 275 boolean have = true;276 sql = \"select * from Histrjn where PersonID=\"+f7;277 try&#123;278 DB.OpenConn();279 rs = DB.executeQuery(sql);280 if(rs.next())&#123;281 have = false;282 &#125;283 &#125;284 catch(Exception e)&#123;285 286 &#125;287 finally&#123;288 DB.closeStmt();289 DB.closeConn();290 &#125;291 return have;292 &#125;293 &#125;","categories":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/tags/java-%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"java 项目","slug":"java-项目","permalink":"https://yanxigun99.github.io/categories/java-%E9%A1%B9%E7%9B%AE/"}]},{"title":"study java day 38","slug":"study python 38 day","date":"2020-01-26T12:00:00.000Z","updated":"2020-01-31T07:41:33.450Z","comments":true,"path":"2020/01/26/study python 38 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/26/study%20python%2038%20day/","excerpt":"","text":"起头并进完成任务—-多线程（一）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187多线程（Multithread）指的是在单个进程中同时运行多个不同的线程，执行不同的任务。多线程意味着一个程序的多行语句块并发执行。一、实现多线程1.通过继承Thread类实现多线程。Thread类来自java.lang包，在Thread类中定义了run()方法，想要实现多线程，必须覆写run()方法。然后使用该类的对象调用start()方法，来激活一个线程。 1 class ThreadDemo extends Thread 2 &#123; 3 public void run() 4 &#123; 5 for(int i=0;i&lt;2;++i) 6 &#123; 7 System.out.println(\"ThreadDemo在运行！\"); 8 try 9 &#123;10 Thread.sleep(1000);11 &#125;12 catch(InterruptedException e)13 &#123;14 e.printStackTrace();15 &#125;16 &#125;17 &#125;18 &#125;19 20 public class ThreadTest21 &#123;22 public static void main(String[] args)23 &#123;24 new ThreadDemo().start();//激活一个新的线程25 for(int j=0;j&lt;2;++j)26 &#123;27 System.out.println(\"main方法在运行！\");28 try29 &#123;30 Thread.sleep(1000);//睡眠1s31 &#125;32 catch(InterruptedException e)33 &#123;34 e.printStackTrace();35 &#125;36 &#125;37 &#125;38 &#125;输出结果：main方法在运行！ThreadDemo在运行！main方法在运行！ThreadDemo在运行！上述例子中的InterruptedException，表示中断异常类，Thread.sleep()和Object.wait()都可以抛出这类中断异常，printStackTrace()方法输出异常信息，这样就可以很清楚的看到两个线程交替执行的结果。如果去掉异常处理语句，那么运行结果如下：main方法在运行！main方法在运行！ThreadDemo在运行！ThreadDemo在运行！这个运行结果貌似不是多线程并发执行，但事实上因为循环次数过少，线程运行并没有超过时间片t，所以先把main方法执行的主线程的for循环执行完毕，再转去执行ThreadDemod的线程。（具体的会在第二部分线程的状态中叙述）2.通过Runnable接口实现多线程。 因为接口可以实现多继承的原因，Runnable接口实现多线程机制更加常用。 1 class RunnableDemo implements Runnable 2 &#123; 3 public void run() 4 &#123; 5 for(int i=0;i&lt;2;++i) 6 &#123; 7 System.out.println(\"RunnableDemo在运行！\"); 8 try 9 &#123;10 Thread.sleep(1000);11 &#125;12 catch(InterruptedException e)13 &#123;14 e.printStackTrace();15 &#125;16 &#125;17 &#125;18 &#125;19 20 public class ThreadTest21 &#123;22 public static void main(String[] args)23 &#123;24 RunnableDemo r = new RunnableDemo();25 new Thread(r).start();//使用Thread类的start()方法启动线程26 for(int i=0;i&lt;2;++i)27 &#123;28 System.out.println(\"main方法在运行！\");29 try30 &#123;31 Thread.sleep(1000);32 &#125;33 catch(InterruptedException e)34 &#123;35 e.printStackTrace();36 &#125;37 &#125;38 &#125;39 &#125;值得一提的是，Runnable接口中只有一个run()方法，所以激活一个新线程仍然使用Thread类的start()方法。new Thread(r).start();Thread类的构造方法，可以将一个Runnable接口（及其子类）的实例化对象作为参数去实例化Thread类对象。3.两种多线程实现机制的联系与区别联系：Thread类实现Runnable接口，即Thread类是Runnable的一个子类。区别：Thread类很难实现资源共享，每个Thread实例都是在独自运行自己的线程，但能通过静态变量实现资源共享；Runnable接口可以直接达到资源共享的目的。***注意：事实上，上述两个示例程序的运行结果都不唯一，这个错误就是和线程运行的时间片和相关临界区有关。二、线程的状态每个Java程序都有一个默认的主线程，对于Java应用程序，主线程是main方法执行的线程。要想实现多线程，必须在主线程中创建新的线程对象。1.线程具有5种状态：创建、就绪、运行、阻塞、终止。关系如下图： 创建：ThreadDemo t = new ThreadDemo();就绪：t.start();运行：执行run()方法。阻塞：暂时停止执行，原因可能是：调用sleep()、调用wait()、发生I/O阻塞、调用join()方法、不能获得对象锁。终止：线程执行完毕。2.线程的优先级Thread类定义的常量来设置优先级：MAX_PRIORITY（10）、NORM_PRIORITY（5）、MIN_PRIORITY（1）。三、操作线程的方法操作线程的主要方法在Thread类中，下面介绍一些常用的方法：1.getName()和setName()取得和设置线程名称Thread t = Thread.currentThread();//静态方法，返回当前正在运行的线程String name = t.getName();//取得线程的名称t.setName(\"线程2—1\");//设置线程的名称2.isAlive()方法——判断线程是否启动ThreadDemo t = new ThreadDemo();Boolean b = t.isAlive();//true或false3.setDaemon()方法——转变为守护线程ThreadDemo t = new ThreadDemo();t.setDaemon(true);//设置守护线程,必须在start()方法前面t.start();当进程中只剩下守护线程的时候，进程才会结束。4.join()方法——线程联合try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;a线程正在运行——b.join();——a线程挂起，b线程强制运行——b线程运行结束——a线程继续运行。5.interrupt()方法——线程中断 isInterrupt()方法——判断线程是否处于中断状态t.interrupt();Boolean b = t.isInterrupted();当一个线程运行时，另一个线程可以调用另外一个线程对应的interrupt()方法来中断它。***注意：调用interrupt()方法并不会使正在执行的线程停止执行，它只对调用wait、join、sleep等方法或由于I/O操作等原因受阻的线程产生影响，使其退出暂停执行的状态。 即：interrupt()对正在运行的线程是不起作用的，只有对阻塞的线程有效。 线程死锁、同步和通信—-多线程（二）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196一、多线程同步上一篇随笔中，我曾遇到对多线程程序的多次运行结果不一致的情况，这主要是因为没有对这些线程在访问临界资源做必要的控制，而接下来就用线程的同步来解决这个问题。1.同步代码块 1 class RunnableDemo implements Runnable 2 &#123; 3 private int tickets=5; 4 public void run() 5 &#123; 6 while(true) 7 &#123; 8 synchronized(this)//同步代码块语法定义如下 9 &#123;10 if(tickets&lt;=0) break;11 try&#123;12 Thread.sleep(100);13 &#125;14 catch(Exception e)&#123;15 e.printStackTrace();16 &#125;17 System.out.println(Thread.currentThread().getName()+\"出售票：\"+tickets);18 tickets -= 1;19 &#125;20 &#125;21 &#125;22 &#125;23 24 public class ThreadTest25 &#123;26 public static void main(String[] args)27 &#123;28 RunnableDemo r = new RunnableDemo();29 new Thread(r).start();30 new Thread(r).start();31 new Thread(r).start();32 new Thread(r).start();33 &#125;34 &#125;在同一时刻只能由一个线程进入同步代码块内运行，只有当该线程离开同步代码块后，其他线程才能进入同步代码块内运行。2.同步方法即：把上述例子中同步代码块的内容，专门封装在一个方法里，通过在run()方法中调用创建的方法实现相应的功能。 1 class RunnableDemo implements Runnable 2 &#123; 3 private int tickets=5; 4 public void run() 5 &#123; 6 while(tickets&gt;0) 7 &#123; 8 sale(); 9 &#125;10 &#125;11 public synchronized void sale()//同步方法12 &#123;13 if(tickets&gt;0)&#123;14 try&#123;15 Thread.sleep(100);16 &#125;17 catch(Exception e)&#123;18 e.printStackTrace();19 &#125;20 System.out.println(Thread.currentThread().getName()+\"出售票：\"+tickets);21 tickets -= 1;22 &#125;23 &#125;24 &#125;25 26 public class ThreadTest27 &#123;28 public static void main(String[] args)29 &#123;30 RunnableDemo r = new RunnableDemo();31 new Thread(r).start();32 new Thread(r).start();33 new Thread(r).start();34 new Thread(r).start();35 &#125;36 &#125; 二、死锁如果有一组进程（或线程），线程1 已经占据资源R1，并持有资源R1上的锁，而且正在等待资源R2开锁；线程2已经占据资源R2，并拥有资源R2上的锁，却正在等待R1开锁。那么这两个线程都不释放自己占据的资源，同时申请不到对方资源上的锁，它们只能永远等待下去。这种现象就叫做死锁。预防死锁的一种方法：利用有序资源分配策略——要求线程申请资源必须按照以编号上升的次序依次申请。三、线程间通信同属于一个进程的多个线程，是共享地址空间的，它们可以相互通信，共同协作来完成指定任务。Java是通过Object类的wait()、notify()、notifyAll()这几个方法来实现线程间的通信。wait():线程进入睡眠状态，直到其他线程进入并调用notify()或notifyAll()为止。notify():唤醒在该同步代码块中第1个调用wait()的线程。notifyAll():唤醒在该同步代码块中所有调用wait()的线程，高优先级最先被唤醒。 1 class Producer implements Runnable 2 &#123; 3 Person q = null; 4 public Producer(Person q) 5 &#123; 6 this.q=q; 7 &#125; 8 @Override 9 public void run()10 &#123;11 for(int i=0;i&lt;10;i++)12 &#123;13 if(i%2==0)14 &#123;15 q.set(\"张三\",\"男\");16 &#125;17 else&#123;18 q.set(\"李四\",\"女\");19 &#125;20 &#125;21 &#125;22 &#125;23 class Consumer implements Runnable24 &#123;25 Person q = null;26 public Consumer(Person q)27 &#123;28 this.q=q;29 &#125;30 @Override31 public void run() 32 &#123;33 for(int i=0;i&lt;10;++i)34 &#123;35 q.get();36 &#125;37 &#125;38 &#125;39 class Person40 &#123;41 private String name = \"李四\";42 private String sex = \"女\";43 private boolean bFull = false;//当Consumer线程取走数据后，false44 public synchronized void set(String name,String sex)45 &#123;46 if(bFull)47 &#123;48 try49 &#123;50 wait();//后来的线程要等待51 &#125;catch(InterruptedException e)&#123;52 e.printStackTrace();53 &#125;54 &#125;55 this.name = name;56 this.sex = sex;57 bFull = true;//当Producer线程放入数据后，true58 notify();//唤醒最先到达的线程59 &#125;60 public synchronized void get()61 &#123;62 if(!bFull)63 &#123;64 try&#123;65 wait();66 &#125;catch(InterruptedException e)&#123;67 e.printStackTrace();68 &#125;69 &#125;70 System.out.println(name+\"——&gt;\"+sex);71 bFull = false;72 notify();73 &#125;74 &#125;75 public class ThreadCommunation76 &#123;77 public static void main(String[] args)78 &#123;79 Person q = new Person();80 new Thread(new Producer(q)).start();81 new Thread(new Consumer(q)).start();82 &#125;83 &#125;***注意：wait()、notify()、notifyAll()这三个方法必须在synchronized方法中调用，该线程必须得到该对象的所有权。四、线程的生命周期控制线程生命周期的方法：suspend()、resume()、stop()方法，但是这三个方法都不推荐使用。若想控制线程的生命周期，推荐使用在run()方法中添加循环条件的方法来实现对线程生命周期的控制。 文件I/O操作—-File类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374在java.io包之中，File类是唯一一个与文件本身有关的操作类。它定义了一些与平台无关的方法来操作文件，通过调用File类提供的各种方法，能够完成创建、删除文件，重命名文件，判断文件的读写权限及文件是否存在，设置和查询文件创建时间、权限的等操作。1.File对象的生成File(String directoryPath)——File F1 = new File(\"/\");//创建指定文件或目录路径的File对象File(String directoryPath,String filename)——File F2 = new File(\"/\",\"abc.txt\");//创建由File对象和指定文件名的File对象File(File dirObj,String filename)——File F3 = new File(F1,\"abc.txt\");//创建指定文件目录路径和文件名的File对象2.File方法的使用 1 import java.io.File; 2 3 public class FileDemo 4 &#123; 5 public static void main(String[] args) 6 &#123; 7 File f = new File(\"c:\\\\1.txt\"); 8 if(f.exists())//测试当前文件是否存在 9 &#123;10 f.delete();//删除当前对象指定的文件11 &#125;12 else13 &#123;14 try15 &#123;16 f.createNewFile();17 &#125;18 catch(Exception e)19 &#123;20 System.out.println(e.getMessage());21 &#125;22 &#125;23 System.out.println(\"文件名：\"+f.getName());//取得文件名24 System.out.println(\"文件路径：\"+f.getPath());//取得文件路径25 System.out.println(\"绝对路径：\"+f.getAbsolutePath());//得到绝对路径名26 /*27 * .....28 * 很多类似的方法，不一一列举了，需要的时候再来查找使用29 */30 &#125;31 &#125;3.分隔符常量public static final String separatorFile file = new File(\"c:\"+File.separator+\"1.txt\");//要定义的操作文件路径4.RandomAccessFile——随机访问文件类RandomAccessFile类的构造方法：RandomAccessFile(File file,String mode)//创建随机存储文件流，文件属性由参数File对象指定 RandomAccessFile(String name,String mode)//创建随机存储文件流，文件属性由参数name指定mode值及其含义：”r“、”rw“、”rws“、”rwd“。4.字节流与字符流（1）.字节输出流——OutputStream（2）.字节输入流——InputStream（3）.字符输出流——Writer（4）.字符输入流——Reader（5）.字节流与字符流的转换5.内存操作流6.打印流 JDBC使用—-Mysql数据库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071一、MySQL数据库安装与数据库连接驱动程序设置在官网中下载MySQL：https://dev.mysql.com/downloads/mysql/下载JDBC驱动包：https://dev.mysql.com/downloads/connector/j/配置系统环境变量，CLASSPATH变量：D:\\Java\\安装包\\mysql-connector-java-5.1.7-bin.jar （即驱动程序路径）。二、连接MySQL数据库通过Connection接口完成，具有连接数据库和控制数据源的作用。1.通过Class类中的静态方法forName()加载数据库的驱动程序。public static final String DBDRIVER = \"com.mysql.jdbc.Driver\";Class.forName(DBDRIVER);或者直接加载：Class.forName(\"com.mysql.jdbc.Driver\");//驱动程序的jar包2.通过DriverManager类的静态方法getConnection()进行数据库的连接。连接时需要输入输入数据库的连接地址、用户名、密码。//连接地址由各个数据库生产商单独提供，所以要单独记住，每种数据库都不同public static final String DBURL = \"jdbc:mysql://localhost:3306/studentInfo\";public static final String DBUSER = \"root\";//连接数据库的用户名public static final String DBPASS = \"123456\";//连接数据库的密码con = DriverManager.getConnection(DBURL,DBUSER,DBPASS);或者直接进行连接：Connection con = null;con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/studentInfo\",\"root\",\"123456\");3.通过Connection接口接收连接。System.out.println(con);//成功连接后返回一个Connection对象当成功连接后，getConnection()会返回一个对象，JDBC主要通过这个对象与数据库进行沟通。此时如果输出一个对象，表明连接成功了。4.关闭数据库con.close();//操作之后必须关闭数据库三、操作MySQL数据库 使用Statement接口，对数据库进行增加、修改、查询和删除操作。1.增加数据Statement stmt = null;//导入java.sql.Statement，表示数据库的更新操作stmt = con.createStatement();//Statement接口需要Connection接口进行实例化//执行SQL语句，调用executeUpdate()方法stmt.executeUpdate(\"INSERT INTO student(sno,sname,age,address) VALUES ('2015025501','Mary',20,'山西')\");//增加2.修改数据stmt.executeUpdate(\"UPDATE student SET sname='Tom',age=21,address='安徽' WHERE sno='2015025501'\");//修改3.查询数据复制代码ResultSet result = null;//导入java.sql.ResultSet，表示接收数据库的查询结果//执行SQL语句，调用executeQuery()方法result = stmt.executeQuery(\"SELECT * FROM student\");//查询所有信息while(result.next())//是否有下一行数据&#123; String sno = result.getString(1);//根据索引号调出信息 String sname = result.getString(\"sname\");//根据字段名称调出信息 int age = result.getInt(3); String address = result.getString(4); System.out.println(sno+\"__\"+sname+\"__\"+age+\" \"+address);//打印查询结果&#125;4.删除数据//只需要修改SQL语句就能实现相应功能stmt.executeUpdate(\"delete from student WHERE sno='2015025501'\");上述需要用到SQL语句，所以也要把数据库知识学好。 上述需要用到SQL语句，所以也要把数据库知识学好。（转入链接：数据库基础知识、数据库查询知识、高级查询） java网页小程序—-java applet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Java Applet是编译过的Java程序，可以在所有支持Java的浏览器中运行。1.Applet的使用import java.applet.Applet;import java.awt.Graphics;public class AppletDemo extends Applet &#123; @Override public void paint(Graphics g) &#123; g.drawString(\"Hello Applet!\", 5, 30);//绘制文本 g.drawArc(80,50,40,40,20,360);//绘制一个圆形 &#125;&#125;2.Applet程序HTML文件的编写&lt;html&gt; &lt;head&gt; &lt;title&gt;Applet&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;applet CODE = \"AppletDemo.class\" width = \"300\" height = \"100\"&gt;&lt;/applet&gt; &lt;/body&gt;&lt;html&gt;3.Applet常用方法import java.applet.Applet;import java.awt.Graphics;public class AppletDemo extends Applet &#123; String mystring = \"\"; @Override public void paint(Graphics g) &#123; g.drawString(mystring, 5, 30); &#125; public void init() &#123; mystring = mystring + \"正在初始化...\"; repaint(); &#125; public void start() &#123; mystring = mystring + \"正在开始启动程序...\"; repaint(); &#125; public void stop() &#123; mystring = mystring + \"正在停止执行程序...\"; repaint(); &#125; public void destroy() &#123; mystring = mystring + \"正在回收资源...\"; repaint(); &#125;&#125;4.从HTML文件向Java小程序传递参数传递的参数必须在HTML文件中声明，并且在Applet初始化时进行读取。参数使用&lt;applet&gt;标签的子标签&lt;param&gt;声明，且不需要结束标签。&lt;param name=param_name value=param_value&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Parameters&lt;/title&gt;&lt;/head&gt;&lt;body&gt;This is a message.&lt;br&gt;&lt;applet code=”ParamPass.class” width=”400” height=”100”&gt; &lt;param name=”fontname” value=”DialogInput” /&gt; &lt;param name=”fontsize” value=”24” /&gt;&lt;/applet&gt;&lt;/body&gt;&lt;/html&gt; 1 import java.awt.Font; 2 import java.awt.Graphics; 3 import javax.swing.JApplet; 4 import javax.swing.JPanel; 5 6 public class ParamPass extends JApplet 7 &#123; 8 private Font f; 9 private int size;10 private String name;11 public void init()12 &#123;13 name = getParameter(\"fontname\");14 size = Integer.parseInt(getParameter(\"fontsize\"));15 f = new Font(name,Font.BOLD,size);16 add(new MyPanel());17 &#125;18 class MyPanel extends JPanel19 &#123;20 public void paintComponent(Graphics g)21 &#123;22 super.paintComponent(g);23 g.setFont(f);24 g.drawString(\"This is a message.\", 50, 50);25 &#125;26 &#125;27 &#125;以上内容仅仅是对Applet的相关概念、使用Applet程序的基本方法以及在HTML代码中嵌入Applet程序等基础的内容的了解。 Map和List集合嵌套取值1234567891011121314151617181920212223242526272829303132333435遍历List的方法：List&lt;User&gt; list = new ArrayList();list = userMapper.getUserList();//从数据库取得list值for(User user : list)&#123; user.toString();//循环取出所有的user信息 user.getUserName();//循环取出list中的所有用户名的值&#125;for(int i = 0;i&lt;list.size();i++)&#123; User user = list.get(i);//按索引取得user信息 user.getUserName();//循环取出list中的所有用户名的值&#125;​​Map的value值为List：Map&lt;String , List&lt;String&gt;&gt; map = new HashMap&lt;String ,List&lt;String&gt;&gt;();//取出List的值List&lt;String&gt; list = map.get(key);for(String s : list)&#123; s.toString();//循环取出list中所有值信息&#125;​List的值为Map：List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();//取出Map的键值对for(Map&lt;String,Object&gt; map : list)&#123; //keySet()方法，获取map集合的所有键的set集合 Iterator&lt;String&gt; it = map.keySet().iterator(); while(it.hasNext())&#123; String key = it.next();//迭代器取出key值 System.out.println(map.get(key));//根据key值获得相应的value值 &#125;&#125;","categories":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/tags/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"study java day 37","slug":"study python 37 day","date":"2020-01-25T12:00:00.000Z","updated":"2020-01-31T07:24:05.292Z","comments":true,"path":"2020/01/25/study python 37 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/25/study%20python%2037%20day/","excerpt":"","text":"反射机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法。 ——百度百科1.根据对象找到类 1 import java.util.Date; 2 3 public class TextReflection 4 &#123; 5 public static void main(String[] args) throws Exception 6 &#123; 7 Date date = new Date(); 8 Class&lt;?&gt; cls = date.getClass();//通过Java反射机制得到类的包名 9 System.out.println(cls);10 &#125;11 &#125;getClass()方法是由Object类所定义的：public final Class&lt;?&gt;getClass()，此方法返回的对象类型为Class，而Class是反射操作的源头。2.实例化一个对象 1 class Book 2 &#123; 3 private String title; 4 private double price; 5 public void setPrice(double price) 6 &#123; 7 this.price = price; 8 &#125; 9 public void setTitle(String title)10 &#123;11 this.title = title;12 &#125;13 @Override14 public String toString()15 &#123;16 return \"图书名称：\"+this.title+\"，图书价格：\"+this.price;17 &#125;18 &#125;19 20 public class TextReflection21 &#123;22 public static void main(String args[]) throws Exception23 &#123; 24 Class&lt;?&gt;cls = Class.forName(\"Book\");25 Book book = (Book)cls.newInstance();//实例化一个对象26 book.setTitle(\"基督山伯爵\");27 book.setPrice(34.5);28 System.out.println(book);29 &#125;30 &#125;实例化一个对象现在有两个形式，一种是通过new关键字，另一种是通过反射机制完成。 Object方法简介二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980在学了Object类前面的三个常用方法后，又遇到它的另外三个方法——clone()、finalize()、getClass()，这三个方法不经常使用，但因为在学习过程遇到了，就简单的对它们的使用做一个总结。1.对象克隆——clone()方法protected Object clone() throws CloneNotSupportedException;使用该方法可以克隆一个对象，即创建一个对象的副本。要使类的对象能够克隆，该类必须实现Cloneable接口。这个接口里面没有定义任何方法，属于标识接口，即给类一个特殊标签。 1 public class Student implements Cloneable 2 &#123; 3 private int num; 4 private String name; 5 public Student(int num,String name) 6 &#123; 7 this.num=num; 8 this.name=name; 9 &#125;10 @Override11 public boolean equals(Object o)12 &#123;13 return this.num==((Student)o).num;14 &#125;15 @Override16 public String toString()17 &#123;18 return \"学号：\"+num+\"，姓名：\"+name;19 &#125;20 public static void main(String args[]) throws CloneNotSupportedException21 &#123; 22 Student s1 = new Student(1001,\"Mary\");23 Student s2 = (Student)s1.clone();24 System.out.println(s1==s2);//false25 System.out.println(s1.equals(s2));//true26 System.out.println(s1.getClass().getName());//ClassNotes.Student27 System.out.println(s1.hashCode());//36671264228 System.out.println(s2.hashCode());//36671264229 System.out.println(s1);//学号：1001，姓名：Mary30 System.out.println(s2);//学号：1001，姓名：Mary31 32 &#125;33 &#125;这个例子使用了Object类的五种方法，其中clone()方法声明抛出CloneNotSupportedException异常，程序在main()方法的声明中抛出了该异常。2.getClass()方法 public final native Class&lt;?&gt; getClass();该方法，它会返回一个你的对象所对应的一个Class的对象，这个返回来的对象保存着你的原对象的类信息，比如你的原对象的类名叫什么，类里有什么方法，字段等，和反射相关。Date date = new Date();Class&lt;?&gt;cls = date.getClass();//得到类的包名3.对象终结——finalize()方法protected void finalize() throws Throwable;在对象被销毁之前，垃圾回收站允许对象调用该方法进行清理工作，清除在对象外被分配的资源。 1 public class Student implements Cloneable 2 &#123; 3 @Override 4 protected void finalize() throws Throwable 5 &#123; 6 System.out.println(\"The object is destroyed\"); 7 &#125; 8 public static void main(String args[]) 9 &#123; 10 Student s1 = new Student();11 Student s2 = new Student();12 s1 = null;13 s2 = null;14 System.gc();//执行垃圾回收15 &#125;16 &#125;输出结果：The object is destroyedThe object is destroyedGC在回收对象之前自动调用finalize()方法，而且需要显示地调用垃圾回收方法(System.gc())，并且需要有new出来的尚未被销毁的匿名对象的存在，finalize()方法才一定会被调用。在某些情况下，finalize ()方法可能不会运行完成或可能根本不运行，JVM不保证此方法总被调用。 java异常的处理和捕获123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169Java提供了try(尝试)、catch(捕捉)、finally(最终)这三个关键字来处理异常。在处理各种异常时，需要用到对应的异常类，指的是由程序抛出的对象所属的类。![1580454966(1)](C:\\Users\\Administrator\\Desktop\\1580454966(1).jpg)一、异常处理的使用由于finally块是可以省略的，异常处理格式可以分为三类：try&#123; &#125;——catch&#123; &#125;、try&#123; &#125;——catch&#123; &#125;——finally&#123; &#125;、try&#123; &#125;——finally&#123; &#125;。 1 public class DealException 2 &#123; 3 public static void main(String args[]) 4 &#123; 5 try 6 //要检查的程序语句 7 &#123; 8 int a[] = new int[5]; 9 a[10] = 7;//出现异常10 &#125;11 catch(ArrayIndexOutOfBoundsException ex)12 //异常发生时的处理语句13 &#123;14 System.out.println(\"超出数组范围！\");15 &#125;16 finally17 //这个代码块一定会被执行18 &#123;19 System.out.println(\"*****\");20 &#125;21 System.out.println(\"异常处理结束！\");22 &#125;23 &#125;可以看出，在异常捕捉的过程中要进行两个判断，第一是try程序块是否有异常产生，第二是产生的异常是否和catch()括号内想要捕捉的异常相同。那么，如果出现的异常和catch()内想要捕捉的异常不相同时怎么办呢？事实上我们可以在一个try语句后跟上多个异常处理catch语句，来处理多种不同类型的异常。 1 public class DealException 2 &#123; 3 public static void main(String args[]) 4 &#123; 5 try 6 //要检查的程序语句 7 &#123; 8 int a[] = new int[5]; 9 a[0] = 3;10 a[1] = 1;11 //a[1] = 0;//除数为0异常12 //a[10] = 7;//数组下标越界异常13 int result = a[0]/a[1];14 System.out.println(result);15 &#125;16 catch(ArrayIndexOutOfBoundsException ex)17 //异常发生时的处理语句18 &#123;19 System.out.println(\"数组越界异常\");20 ex.printStackTrace();//显示异常的堆栈跟踪信息21 &#125;22 catch(ArithmeticException ex)23 &#123;24 System.out.println(\"算术运算异常\");25 ex.printStackTrace();26 &#125;27 finally28 //这个代码块一定会被执行29 &#123;30 System.out.println(\"finally语句不论是否有异常都会被执行。\");31 &#125;32 System.out.println(\"异常处理结束！\");33 &#125;34 &#125;上述例子中ex.printStackTrace();就是对异常类对象ex的使用，输出了详细的异常堆栈跟踪信息，包括异常的类型，异常发生在哪个包、哪个类、哪个方法以及异常发生的行号。二、throws关键字throws声明的方法表示该方法不处理异常，而由系统自动将所捕获的异常信息抛给上级调用方法。 1 public class throwsDemo 2 &#123; 3 public static void main(String[] args) 4 &#123; 5 int[] a = new int[5]; 6 try 7 &#123; 8 setZero(a,10); 9 &#125;10 catch(ArrayIndexOutOfBoundsException ex)11 &#123;12 System.out.println(\"数组越界错误！\");13 System.out.println(\"异常：\"+ex);14 &#125;15 System.out.println(\"main()方法结束。\");16 &#125;17 private static void setZero(int[] a,int index) throws ArrayIndexOutOfBoundsException18 &#123;19 a[index] = 0;20 &#125;21 &#125; throws关键字抛出异常，“ArrayIndexOutOfBoundsException”表明setZero()方法可能存在的异常类型，一旦方法出现异常，setZero()方法自己并不处理，而是将异常提交给它的上级调用者main()方法。三、throw关键字throw的作用是手工抛出异常类的实例化对象。 1 public class throwDemo 2 &#123; 3 public static void main(String[] args) 4 &#123; 5 try 6 &#123; 7 //抛出异常的实例化对象 8 throw new ArrayIndexOutOfBoundsException(\"\\n个性化异常信息：\\n数组下标越界\"); 9 &#125;10 catch(ArrayIndexOutOfBoundsException ex)11 &#123;12 System.out.println(ex);13 &#125;14 &#125;15 &#125;我们能发现，throw好像属于没事找事，引发运行期异常，并自定义提示信息。事实上，throw通常和throws联合使用，抛出的是程序中已经产生的异常类实例。 ExceptionDemo输出结果：setZero方法开始：setZero方法结束。异常：java.lang.ArrayIndexOutOfBoundsException: 10main()方法结束！四、RuntimeException类Exception和RuntimeException的区别：Exception:强制性要求用户必须处理；RunException:是Exception的子类，由用户选择是否进行处理。 五、自定义异常类自定义异常类继承自Exception类，可以使用父类的大量的方法，也可自己编写方法来处理特定的事件。Java提供用继承的方式运行用户自己编写的异常类。 1 class MyException extends Exception 2 &#123; 3 public MyException(String message) 4 &#123; 5 super(message); 6 &#125; 7 &#125; 8 public class DefinedException 9 &#123;10 public static void main(String[] args) 11 &#123;12 try13 &#123;14 throw new MyException(\"\\n自定义异常类！\");15 &#125;16 catch(MyException e)17 &#123;18 System.out.println(e);19 &#125;20 &#125;21 &#125; 枚举一—-快速归类整型常数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115枚举类型是一种特殊的引用类型，它的声明和使用与类和接口有类似的地方，可以在其它类的内部声明，但不能在方法内部声明。每个枚举类型都隐含的继承了Enum抽象类，Enum又是Object类的子类，所以其方法即可被枚举类型调用。1.枚举类型的定义枚举类型声明使用enum关键字，罗列出所有可用值，这些值也称为枚举元素。 1 enum WeekDay 2 &#123; 3 SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY; 4 &#125; 5 public class EnumDemo 6 &#123; 7 public static void main(String[] args) 8 &#123; 9 WeekDay rest = WeekDay.SUNDAY;//枚举名.枚举值10 System.out.println(rest);11 &#125;12 &#125;上述例子中，SATURDAY后面的;可以省略，但如果枚举中还声明了方法，则不可省略。2.凡被说明为WeekDay类型变量的取值，只能是枚举元素其中之一。而枚举变量的说明有以下三种方式：enum WeekDay&#123; SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;;enum WeekDay today;//先定义，后说明enum WeekDay&#123; SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;today;//定义的同时说明enum &#123; SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;today;//定义无名枚举这三种方式在Eclipse中是报错的，但书上确实是这么讲的，还没弄明白是怎么回事，等弄懂了再回来修改。3.枚举实用——switch语句 1 enum WeekDay&#123; 2 SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY 3 &#125;; 4 public class EnumDemo 5 &#123; 6 public static void main(String[] args) 7 &#123; 8 WeekDay today = WeekDay.MONDAY; 9 switch(today)10 &#123;11 case SUNDAY:12 &#123;13 System.out.println(\"今天是星期日！\");14 break;15 &#125;16 case MONDAY:17 &#123;18 System.out.println(\"今天是星期一！\");19 break;20 &#125;21 case TUESDAY:22 &#123;23 System.out.println(\"今天是星期二！\");24 break;25 &#125;26 case WEDNESDAY:27 &#123;28 System.out.println(\"今天是星期三！\");29 break;30 &#125;31 case THURSDAY:32 &#123;33 System.out.println(\"今天是星期四！\");34 break;35 &#125;36 case FRIDAY:37 &#123;38 System.out.println(\"今天是星期五！\");39 break;40 &#125;41 case SATURDAY:42 &#123;43 System.out.println(\"今天是星期六！\");44 break;45 &#125;46 &#125;47 &#125;48 &#125;4.枚举类型的方法每种枚举类型E都有两个自动生成的静态方法：public static E[] values():返回一个包含了所有枚举常量的数组（按照声明顺序存储）。WeekDay[] allweek = WeekDay.values();//用枚举数组读取枚举中的值for(WeekDay aweek:allweek)&#123; System.out.println(aweek);//遍历数组输出&#125;public static E valueOf(String name):返回指定名字的枚举常量。（若无，则抛出IllegalArgumentException异常。）WeekDay w = WeekDay.valueOf(\"TUESDAY\");System.out.println(w);调用父类Enum类的方法：public int ordinal():返回枚举常量的序数。WeekDay[] allweek = WeekDay.values();for(WeekDay aweek:allweek)&#123; System.out.println(aweek.name()+\"--&gt;\"+aweek.ordinal());//输出各个枚举元素的编号&#125;Enum类中还有很多实用的方法，如clone()、name()等，不一一介绍了。 枚举二—-类集对于枚举的支持1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Java.util中添加了两个新类，EnumMap和EnumSet来支持枚举类型。5.EnumMap类:枚举类型实例到值的映射Map是Java中的一个类，EnumMap是Map的子类。Map（映射）是一个二元组的集合，它中的每个元素都是由&lt;Key,value&gt;两个属性组成，通过Key很容易找到对应的value。 1 import java.util.EnumMap; 2 import java.util.Map; 3 4 enum Color&#123;红色,绿色,蓝色&#125;; 5 public class EnumMapDemo 6 &#123; 7 public static void main(String[] args) 8 &#123; 9 EnumMap&lt;Color,String&gt; ep = new EnumMap&lt;Color,String&gt;(Color.class);//实例化对象，构造参数不能为空10 ep.put(Color.红色, \"RED\");//一对&lt;Key,value&gt;映射11 ep.put(Color.绿色, \"GREEN\");12 ep.put(Color.蓝色,\"BLUE\");13 for(Map.Entry&lt;Color, String&gt;me:ep.entrySet())14 &#123;15 System.out.println(me.getKey()+\"--&gt;\"+me.getValue());16 &#125;17 &#125;18 &#125;其中，EntrySet()是定义在Map类中的一个方法，其作用是返回整个映射实例的集合。EntrySet()方法中的Set表示的含义是“集合”。6.EnumSet类:枚举类型集合操作（如交、并、补等）Set是一个一元组集合，其包含一系列不可重复的数据。EnumSet是Set的子类。Set可以理解为，只包含元素Key的集合。 1 import java.util.EnumSet; 2 import java.util.Iterator; 3 4 enum Color&#123;红色,绿色,蓝色&#125;; 5 public class EnumSetDemo 6 &#123; 7 public static void main(String[] args) 8 &#123; 9 EnumSet&lt;Color&gt; es = EnumSet.allOf(Color.class);//将枚举全部内容设置到集合10 Iterator&lt;Color&gt; iter = es.iterator();//指向枚举类型Color的迭代器11 while(iter.hasNext())//判断集合中是否还有元素12 &#123;13 System.out.println(iter.next());//遍历集合类的元素并输出14 &#125;15 &#125;16 &#125;上述例子测试了EnumSet类的静态方法allOf()。 1 import java.util.EnumSet; 2 import java.util.Iterator; 3 4 enum Color&#123;红色,绿色,蓝色&#125;; 5 public class EnumSetDemo 6 &#123; 7 public static void main(String[] args) 8 &#123; 9 EnumSet&lt;Color&gt; es = EnumSet.noneOf(Color.class);//枚举类型的空集合10 Iterator&lt;Color&gt; iter = es.iterator();//指向枚举类型Color的迭代器11 while(iter.hasNext())12 &#123;13 System.out.println(iter.next());//null，无输出14 &#125;15 &#125;16 &#125;上述例子测试了EnumSet类的静态方法noneOf()。 枚举三—-深入了解枚举1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711727.自定义枚举的构造方法枚举类型不能用public和protected修饰构造方法，所以枚举对象无法在测试类中直接调用其构造方法来初始化。 1 enum Color&#123; 2 RED(\"红色\",4),GREEN(\"绿色\",5),BLUE(\"蓝色\",6);//有参构造方法实例化对象 3 private String name; 4 private int index; 5 private Color(String name,int index)//两参构造方法 6 &#123; 7 this.name=name; 8 this.index=index; 9 &#125;10 public static String getName(int index)//普通方法11 &#123;12 for(Color c:Color.values())13 &#123;14 if(c.getIndex()==index)15 &#123;16 return c.name;17 &#125;18 &#125;19 return null;20 &#125;21 public String getName()22 &#123;23 return name;24 &#125;25 public static void setName(int index,String name)26 &#123;27 for(Color c:Color.values())28 &#123;29 if(c.getIndex()==index)30 &#123;31 c.name=name;32 return;33 &#125;34 &#125;35 &#125;36 public int getIndex()37 &#123;38 return index;39 &#125;40 public static void setIndex(int index,String name)41 &#123;42 for(Color c:Color.values())43 &#123;44 if(c.getName()==name)45 &#123;46 c.index=index;47 return;48 &#125;49 &#125;50 &#125;51 &#125;;52 public class DeepEnum53 &#123;54 public static void main(String[] args)55 &#123;56 System.out.println(\"原来的颜色和编号：\");57 System.out.println(Color.RED.getIndex()+\"--&gt;\"+Color.RED.getName());58 System.out.println(Color.GREEN.getIndex()+\"--&gt;\"+Color.GREEN.getName());59 System.out.println(Color.BLUE.getIndex()+\"--&gt;\"+Color.BLUE.getName());60 System.out.println(\"自定义后的颜色和编号：\");61 Color.setName(4,\"黑色\");//重新设置名称62 System.out.println(\"4--&gt;\"+Color.getName(4));63 Color.setIndex(7, \"黑色\");//重新设置索引编号64 System.out.println(\"7--&gt;\"+Color.getName(7));65 &#125;66 &#125;上述例子定义了Color类的构造方法和四个普通方法，通过对方法的调用实现了对枚举对象的属性进行赋值和修改。有几点需要注意:（1）、枚举类定义的对象必须出现在该类的第一行。 （2）、一旦定义了枚举类的构造方法，那么所以的枚举对象都必须显示调用此构造方法。 （3）、可以通过“枚举类名.对象名.方法名”调用方法得到对象的属性。 （4）、可以通过“枚举类名.方法名”调用方法设置对象的属性。8.枚举的接口枚举和普通类一样，可以实现一个或多个接口。当一个枚举实现一个接口之后，各个枚举对象都必须分别实现接口中的抽象方法。 1 interface ColorInterface 2 &#123; 3 public String getColor(); 4 &#125; 5 enum Color implements ColorInterface 6 &#123; 7 红色 8 &#123; 9 public String getColor()10 &#123;11 return \"RED\";12 &#125;13 &#125;,14 绿色15 &#123;16 public String getColor()17 &#123;18 return \"GREEN\";19 &#125;20 &#125;,21 蓝色22 &#123;23 public String getColor()24 &#123;25 return \"BLUE\";26 &#125;27 &#125;;28 &#125;29 public class DeepEnum30 &#123;31 public static void main(String[] args)32 &#123;33 for(Color c:Color.values())34 &#123;35 System.out.println(c.ordinal()+\"--&gt;\"+c.name()+\":\"+c.getColor());36 &#125;37 &#125;38 &#125;第6—27行，就是一条复合的大语句，本质上是一条语句。9.枚举中定义抽象方法上述7和8中为枚举对象的属性和编号赋值还可以有第三种方法，那便是在枚举中直接定义抽象方法。 1 enum Color 2 &#123; 3 红色 4 &#123; 5 public String getColor() 6 &#123; 7 return \"RED\"; 8 &#125; 9 &#125;,10 绿色11 &#123;12 public String getColor()13 &#123;14 return \"GREEN\";15 &#125;16 &#125;,17 蓝色18 &#123;19 public String getColor()20 &#123;21 return \"BLUE\";22 &#125;23 &#125;;24 public abstract String getColor();//枚举中的抽象方法25 &#125;26 public class DeepEnum27 &#123;28 public static void main(String[] args)29 &#123;30 for(Color c:Color.values())31 &#123;32 System.out.println(c.ordinal()+\"--&gt;\"+c.name()+\":\"+c.getColor());33 &#125;34 &#125;35 &#125;10.枚举类不可以被继承在枚举类内部可以定义一个或多个抽象方法，但枚举类不能用abstract修饰，只能在每个枚举的实例实现抽象方法。","categories":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/tags/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"study java day 36","slug":"study python 36 day","date":"2020-01-24T12:00:00.000Z","updated":"2020-01-31T07:09:58.841Z","comments":true,"path":"2020/01/24/study python 36 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/24/study%20python%2036%20day/","excerpt":"","text":"一种专门用作父类的类—-抽象类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901.抽象类的声明： 1 abstract class Book 2 &#123; 3 String name;//属性 4 int price; 5 public void printName()//普通方法 6 &#123; 7 System.out.println(\"书名：\"+name); 8 &#125; 9 public abstract void printPrice();//抽象方法10 &#125;2.抽象类不能直接实例化：Book book = new Book();//错误的，Book是抽象类3.抽象方法只需声明，不需实现：public abstract void printPrice(int price);//抽象方法4.抽象类的使用:必须有子类。抽象类的子类必须重写全部的抽象方法后才能被实例化。 1 abstract class Book 2 &#123; 3 String name;//属性 4 int price; 5 String press; 6 public void printName(String name)//普通方法 7 &#123; 8 System.out.print(\"书名：\"+name); 9 &#125;10 public abstract void printPrice(int price);//抽象方法11 &#125;12 class Readers extends Book13 &#123;14 public void printPrice(int price)15 &#123;16 System.out.println(\" 价格：\"+price+\"元\");17 &#125;18 &#125;19 class Writer extends Book20 &#123;21 public void printPrice(int price)22 &#123;23 System.out.print(\" 价格：\"+price+\"元\");24 &#125;25 public void printPress(String press)26 &#123;27 System.out.print(\" 出版社:\"+press);28 &#125;29 &#125;30 public class T0331 &#123;32 public static void main(String[] args)33 &#123;34 Readers r = new Readers();35 Writer w = new Writer();36 r.printName(\"《基督山伯爵》\");37 r.printPrice(20);38 w.printName(\"《欧亨利短篇小说集》\");39 w.printPrice(30);40 w.printPress(\"新华出版社\");41 &#125;42 &#125;输出结果：书名：《基督山伯爵》 价格：20元书名：《欧亨利短篇小说集》 价格：30元 出版社:新华出版社5.外部抽象类不能用static声明，但内部抽象类可以。 1 abstract class Book 2 &#123; 3 public abstract void print(); 4 static abstract class Name 5 &#123; 6 public abstract void getName(); 7 &#125; 8 &#125; 9 class Readers extends Book.Name10 &#123;11 public void getName()12 &#123;13 System.out.println(\"《茶花女》\");14 &#125;15 &#125;16 public class T0317 &#123;18 public static void main(String[] args)19 &#123;20 Book.Name name = new Readers();21 name.getName();22 &#125;23 &#125;6.抽象类应用——模板设计模式。举一个例子：现在有三类事物丈夫、妻子、儿子，这三类事物可以完成的功能如下。丈夫：吃饭、睡觉、工作、锻炼。妻子：吃饭、锻炼、睡觉、做家务。儿子：吃饭、睡觉、学习。 1 abstract class Action 2 &#123; 3 public static int eat; 4 public static int sleep; 5 public static int sport; 6 public abstract void EAT(); 7 public abstract void SLEEP(); 8 public abstract void SPORT(); 9 &#125;10 class Husband extends Action11 &#123;12 public void EAT()13 &#123;14 System.out.println(\"丈夫吃的好，身体才好！\");15 &#125;16 public void SLEEP()17 &#123;18 System.out.println(\"丈夫休息好才能好好工作。\");19 &#125;20 public void SPORT()21 &#123;22 System.out.println(\"丈夫早上总要去锻炼身体。\");23 &#125;24 public void WORK()25 &#123;26 System.out.println(\"丈夫好好工作，家庭才能幸福！\");27 &#125;28 &#125;29 class Wife extends Action30 &#123;31 public void EAT()32 &#123;33 System.out.println(\"妻子做的菜都非常好吃。\");34 &#125;35 public void SLEEP()36 &#123;37 System.out.println(\"妻子喜欢睡个美容觉。\");38 &#125;39 public void SPORT()40 &#123;41 System.out.println(\"妻子早上陪伴丈夫去锻炼身体。\");42 &#125;43 public void HOUSEWORK()44 &#123;45 System.out.println(\"妻子收拾家务，照顾孩子。\");46 &#125;47 &#125;48 class Son extends Action49 &#123;50 public void EAT()51 &#123;52 System.out.println(\"儿子非常喜欢吃他妈妈做的菜。\");53 &#125;54 public void SLEEP()55 &#123;56 System.out.println(\"儿子休息好才能好好学习。\");57 &#125;58 public void SPORT()&#123;&#125;59 public void STUDY()60 &#123;61 System.out.println(\"儿子要好好学习，不辜负父母的期望。\");62 &#125;63 &#125;64 public class T0365 &#123;66 public static void main(String[] args)67 &#123;68 Husband h = new Husband();69 Wife w = new Wife();70 Son s = new Son();71 h.EAT();h.SLEEP();h.WORK();h.SPORT();72 w.EAT();w.SLEEP();w.HOUSEWORK();w.SPORT();73 s.EAT();s.SLEEP();s.STUDY();s.SPORT();74 &#125;75 &#125; 对java单继承的补充—-接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120接口主要用来实现多重继承，它是常量和方法的集合，这些方法只有声明没有实现，即接口本身是抽象的，系统默认用abstract修饰。1.接口的定义：1 public interface A&#123;2 int A=1;//默认为public static final常量3 void displayA();//默认为public abstract抽象方法4 &#125;带默认方法的接口定义：1 interface B2 &#123;3 int B=2;//常量4 public void print();//抽象方法5 default public void otherprint()//带方法体的默认方法6 &#123;7 System.out.println(B);8 &#125;9 &#125;default方法称为虚拟扩展方法，是指：在接口内部包含一些默认的方法实现，使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。2.接口可以实现多重继承： 1 interface A&#123; 2 int A=1; 3 void displayA(); 4 &#125; 5 interface B&#123; 6 int B=2; 7 void displayB(); 8 &#125; 9 interface C extends A,B&#123;10 int C=3;11 void displayC();12 &#125;13 class ABC implements C14 &#123;15 public void displayA() 16 &#123;17 System.out.println(A);18 &#125;19 public void displayB() 20 &#123;21 System.out.println(B);22 &#125;23 public void displayC()24 &#123;25 System.out.println(C);26 &#125;27 &#125;28 public class T0429 &#123;30 public static void main(String[] args)31 &#123;32 ABC a = new ABC();33 ABC b = new ABC();34 ABC c = new ABC();35 a.displayA();36 b.displayB();37 c.displayC();38 &#125;39 &#125;上面的例子中，接口C多继承了接口A和B，类ABC通过实现接口C，同时实现了接口A和B 中的方法，这就是多继承的一种体现。一个类也可以同时实现几个不同的接口：class ABC implements A,B,C&#123;&#125;//这行代码和例子中的红色字体效果是一样的3.接口和抽象类的区别： 接口中只有抽象方法，没有普通方法；接口无构造方法。 接口不能被继承，只能被实现。 上述：public class ABC implements C&#123;&#125;就是类实现接口的方法。4.接口中定义的常量可以直接用类名访问。System.out.println(ABC.A);5.GUI程序事件处理——接口使用一例。 1 import java.awt.FlowLayout; 2 import java.awt.event.*; 3 import javax.swing.*; 4 5 public class EventDemo extends JFrame implements ActionListener 6 &#123; 7 JButton button1 = new JButton(\"登录\"); 8 JButton button2 = new JButton(\"取消\"); 9 JTextField jtf = new JTextField(20);10 public EventDemo()11 &#123;12 add(jtf);13 add(button1);14 add(button2);15 button1.addActionListener(this);//为按钮注册事件监听器16 button2.addActionListener(this);17 setSize(600,350);18 setVisible(true);19 setLayout(new FlowLayout());20 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);21 &#125;22 public void actionPerformed(ActionEvent e)//实现接口中的抽象方法23 &#123;24 if((JButton)e.getSource()==button1)25 jtf.setText(\"***\");26 else27 jtf.setText(\"&amp;&amp;&amp;\");28 &#125;29 public static void main(String[] args)30 &#123;31 EventDemo frame = new EventDemo();32 &#125;33 &#125; java内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215一、成员内部类1.最常规的内部类。在其中可以访问任何权限的外部类方法。 1 public class Outer&#123;//外部类 2 3 private int a = 10; 4 public class Inner//成员内部类 5 &#123; 6 int b = 12; 7 public void speak() 8 &#123; 9 System.out.println(\"访问外部类中A=\"+a);//访问私有属性a10 System.out.println(\"访问内部类中B=\"+b);11 &#125;12 &#125;13 public static void main(String[] args)14 &#123;15 Outer o = new Outer();16 Inner i = o.new Inner();17 i.speak();18 &#125;19 &#125;2.外部类对象与成员内部类对象的关系。public static void main(String[] args)&#123; Outer o = new Outer();//创建一个外部类对象,对象引用名为o Inner i = o.new Inner();//使用外部类对象创建内部类对象，对象引用名为i i.speak();&#125;上述例子中的main方法中，分别创建了内部和外部类的对象，其中内部类对象还可以像下面用外部类的匿名对象创建：Outer.Inner oi = new Outer().new Inner();3.在成员内部类中，访问外部类的属性和方法。 1 public class Outer&#123;//外部类 2 3 private int a = 10; 4 public void talk() 5 &#123; 6 a++; 7 &#125; 8 public class Inner//成员内部类 9 &#123;10 int b = 12;11 public void speak()12 &#123;13 System.out.println(\"访问外部类中A=\"+a);14 System.out.println(\"访问内部类中B=\"+b);15 Outer.this.a=21;//类名调用16 talk();//直接调用17 System.out.println(\"访问外部类中A=\"+a);18 &#125;19 &#125;20 public static void main(String[] args)21 &#123;22 Outer.Inner oi = new Outer().new Inner();23 oi.speak();24 &#125;25 &#125;4.编译后，会产生两个class文件，分别为Outer.class和Outer$Inner.class，后者便是成员内部类的完整类名。5.外部类无法直接使用内部类的属性和方法，需要通过创建内部类的对象来访问。//外部类的talk()方法public void talk()&#123; a++; //speak();//错误的 Inner in = new Inner(); in.speak();//正确的&#125;6.对于同名的属性或方法，借助this关键字，可以恰当区分外部类属性（方法）和内部类属性（方法）。二、静态内部类1.静态内部类与静态方法类似，只能访问外部类的static成员，需要通过对象引用才能访问外部类的实例变量和实例方法。2.对于同名的属性或方法，使用“类名.静态成员”访问外部类的成员。 1 public class Outer&#123;//外部类 2 3 private int a = 10; 4 static int b = 12; 5 static public class Inner//静态内部类 6 &#123; 7 int b = 21; 8 public void speak() 9 &#123;10 System.out.println(\"访问外部类中A=\"+new Outer().a);//访问外部类非静态成员11 System.out.println(\"访问内部类中B=\"+b);//访问内部类静态成员12 System.out.println(\"访问外部类中B=\"+Outer.b);//访问外部类静态成员13 &#125;14 &#125;15 public static void main(String[] args)16 &#123;17 Inner i = new Inner();18 i.speak();19 &#125;20 &#125;3.用完整类名可直接创建对象，不需要外部类的对象辅助了。Inner i = new Inner();三、方法（局部）内部类1.顾名思义，将内部类定义在外部类的方法中就是方法内部类，其只在该方法的内部可见。（方法体、语句块中均可以定义内部类） 1 public class Outer&#123;//外部类 2 3 int a = 10; 4 int b = 12; 5 //方法体开始 6 public void print() 7 &#123; 8 class Inner//方法内部类 9 &#123;10 int b = 21;11 public void speak()12 &#123;13 System.out.println(\"访问外部类中A=\"+a);14 System.out.println(\"访问内部类中B=\"+b);15 System.out.println(\"访问外部类中B=\"+Outer.this.b);16 &#125;17 &#125;18 Inner i = new Inner();//创建内部类对象19 i.speak();//调用内部类方法20 &#125;21 //方法体结束22 public static void main(String[] args)23 &#123;24 Outer o = new Outer();//创建外部类对象25 o.print();//调用外部类方法26 &#125;27 &#125;2.方法内部类不能使用访问控制符和static修饰符。3.方法内部类可以访问外部类的成员，但对于方法中的参数和局部变量，必须有final修饰符（即变为常量）才可以访问。 1 public void print() 2 &#123; 3 int c; 4 class Inner//方法内部类 5 &#123; 6 public void speak() 7 &#123; 8 System.out.println(\"访问外部类中A=\"+a); 9 System.out.println(\"访问内部类中B=\"+c);//出现错误10 System.out.println(\"访问外部类中B=\"+Outer.this.b);11 &#125;12 &#125;13 Inner i = new Inner();//创建内部类对象14 i.speak();//调用内部类方法15 &#125;出现过错误的地方一定要牢牢记住！！！四、匿名内部类1.将类的定义和创建实例放在一起进行，只能使用一次的，这种没有名字的类叫匿名内部类。2.匿名内部类可以继承一个类或实现一个接口，但不能同时。 1 import java.awt.event.WindowAdapter; 2 import java.awt.event.WindowEvent; 3 import javax.swing.JFrame; 4 5 public class WinEvent&#123; 6 7 public static void main(String[] args) &#123; 8 //MyListener t = new MyListener(); 9 JFrame frame = new JFrame();10 frame.addWindowListener(11 new WindowAdapter()//匿名内部类只能使用一次12 &#123;13 public void windowClosing(WindowEvent e)14 &#123;15 System.out.println(\"123\");16 &#125;17 &#125;18 );19 frame.setSize(400, 500);20 frame.setLocation(200, 200);21 frame.setVisible(true);22 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);23 &#125;24 &#125;3.匿名内部类的一个重要应用是编写GUI的事件处理程序，如上例。 最后，我们为什么要使用内部类呢？1.内部类提供更好的封装。2.内部类的方法可以直接访问外部类的所有数据，包括私有数据。3.内部类可以更方便的实现功能，比如匿名内部类。看似简单的知识背后，承载的是收获和成长！ Object类及常用方法简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。这里主要总结Object类中的三个常用方法：toString()、equals()、hashCode()。1.取得对象信息的方法：toString()该方法在打印对象时被调用，将对象信息变为字符串返回，默认输出对象地址。 1 class Student 2 &#123; 3 String name = \"Mary\"; 4 int age = 21; 5 &#125; 6 7 public class Text&#123; 8 public static void main(String[] args) 9 &#123;10 Student s = new Student();11 System.out.println(\"姓名：\"+s.name+\"，年龄：\"+s.age);//输出对象属性12 System.out.println(s);//直接输出对象信息13 System.out.println(s.toString());//调用父类方法输出对象信息14 &#125;15 &#125;输出结果：姓名：Mary，年龄：21ClassNotes.Student@15db9742ClassNotes.Student@15db9742上述结果看出编译器默认调用toString()方法输出对象，但输出的是对象的地址，我们并不能看懂它的意思。那么就要通过重写Object类的toString()方法来输出对象属性信息。1 class Student2 &#123;3 String name = \"Mary\";4 int age = 21;5 public String toString()6 &#123;7 return \"姓名：\"+name+\"，年龄：\"+age;8 &#125;9 &#125;输出结果：姓名：Mary，年龄：21。这样对象信息就更加清晰了。2.对象相等判断方法：equals()该方法用于比较对象是否相等，而且此方法必须被重写。 1 class Student 2 &#123; 3 String name; 4 int age; 5 public Student(String name,int age) 6 &#123; 7 this.name=name; 8 this.age=age; 9 &#125;10 &#125;11 12 public class Text&#123;13 public static void main(String[] args)14 &#123;15 Student s1 = new Student(\"Mary\",21);16 Student s2 = new Student(\"Mary\",21);17 System.out.println(s1.equals(s2));//输出一个boolean值18 System.out.println(s1.equals(s2)?\"s1和s2是同一个人\":\"s1和s2不是同一个人\");//?:条件运算符19 &#125;20 &#125;输出结果：s1和s2不是同一个人。很明显输出的结果是错误的，因为equals()方法比较的是两个对象的地址，所以必须重写方法才能到达目的。 1 //重写父类（Object类）中的equals方法 2 public boolean equals(Object o) 3 &#123; 4 boolean temp = true; 5 Student s1 = this; 6 if(o instanceof Object) 7 &#123; 8 Student s2 = (Student)o; 9 if(!(s1.name.equals(s2.name)&amp;&amp;s1.age==s2.age))10 &#123;11 temp = false;12 &#125;13 &#125;14 else15 &#123;16 temp = false;17 &#125;18 return temp;//返回一个布尔值19 &#125;上面的是书上的例子，不太好理解，我自己编了一个equals()方法，简单但不知道对不对： DEMO***在Eclipse偶然发现一个快捷键，按住ctrl+/会注释当前行3.对象签名:hashCode()该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的.hashCode。 1 class Student 2 &#123; 3 String name; 4 int age; 5 //重写父类（Object类）中的equals方法 6 public boolean equals() 7 &#123; 8 boolean temp; 9 Student s1 = new Student();10 s1.name=\"张三\";s1.age=12;11 Student s2 = new Student();12 s2.name=\"张三\";s2.age=12;13 System.out.println(\"s1的哈希码：\"+s1.hashCode());14 System.out.println(\"s2的哈希码：\"+s2.hashCode());15 if((s1.name.equals(s2.name))&amp;&amp;(s1.age==s2.age))16 &#123;17 temp = true;18 &#125;19 else20 &#123;21 temp = false;22 &#125;23 return temp;24 &#125;25 //重写hashCode()方法26 public int hashCode()27 &#123;28 return age*(name.hashCode());29 &#125;30 &#125;31 32 public class Text&#123;33 public static void main(String[] args)34 &#123;35 Student s3 = new Student();36 System.out.println(s3.equals()?\"s1和s2是同一人\":\"s1和s2不是同一人\");37 &#125;38 &#125;输出结果：s1的哈希码：9298668s2的哈希码：9298668s1和s2是同一人 java中String类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153Java中定义了String和StringBuffer两个类来封装对字符串的各种操作，存放于java.lang包中，无需导入即可直接使用它们。一、String对象的创建及初始化。1.使用字符串常量直接初始化：String s1 = \"Hello world!\";这样的字符串严格来讲都是String类的匿名对象，对象名称s1保存在栈内存中，而字符串“Hello world!”保存在堆内存中。通过引用传递创建字符串对象s2:String s2 = s1;在第一次定义字符串的时候，在堆内存中开辟一块空间，如果之后使用直接赋值或者引用传递创建新的对象，且此内容已经存在，就不会开辟新的堆内存，而让其指向了已有的字符串内容。2.使用构造方法初始化：String s3 = new String(\"Hello world!\");这种方法会开辟第二块堆内存空间，其中一块将会成为垃圾，无法实现自动入池操作。在String类中提供了手工入池的方法：public String intern();String s3 = new String(\"Hello world!\").intern();3.使用串联方式：String s4 = \"Hello\"+\" world!\";二、String内容的比较。1.调用equals()方法：String s = \"Hello world!\";Boolean result = s.equals(\"Hello world!\");这个方法在之前已经提到过了，equals()比较字符串的内容，它会区分字符串的大小写，也有一种忽略大小写的方法：public boolean equalsIgnorecase();。2.使用比较运算符“==”：1 String s1 = \"Hello world!\";2 String s2 = \"Hello world!\";3 String s3 = new String(\"Hello world！\");4 Boolean result1 = (s1==s2);//true5 Boolean result2 = (s1==s3);//false可以看出，“==”完成的是两个对象堆内存地址的判断，比较两个对象是否引用同一个实例，而不是真正意义上字符串内容的比较。三、字符串一旦声明则不可改变。String s = \"Hello\";s = s + \" world\";s = s + \"!\";System.out.println(s);//Hello world!从输出结果来看，字符串的内容被改变了，但实际上只是String类对象的引用改变了，开辟出额外的堆内存空间，造成大量字符串垃圾。所以，在编程过程中应尽量避免多次修改字符串内容，以免出现大量的垃圾。***Java中使用StringBuffer类或者StringBuilder类来改变字符串内容，且不会创建新的对象。1 StringBuffer s = new StringBuffer(\"Hello\");2 s.append(\" world!\");//在结尾追加内容3 s.insert(6, \"new \");//在指定位置插入内容4 System.out.println(s);//Hello new world!四、String类的常用方法。在Java中，String类中定义了大量的操作方法，下面列出了常用的部分方法：其他不再详细叙述了，仅用一个例子来大体概括它们的使用： 1 class Demo 2 &#123; 3 String s = \"Hello world!\"; 4 public void chartest() 5 &#123; 6 System.out.println(\"取出第5个字符：\"+s.charAt(4));//取出字符串中第5个字符 7 &#125; 8 public void Arraytest() 9 &#123;10 //字符串与字符数组相互转化11 char data[] = s.toCharArray();//将字符串变为字符数组12 for(int i=0;i&lt;data.length;i++)13 &#123;14 System.out.print(data[i]+\"、\");15 &#125;16 System.out.println();17 System.out.println(new String(data));//将字符数组变为字符串18 System.out.println(new String(data,6,5));//从下标为6，即第7个字符开始取5个字符19 &#125;20 public void intexOftest()21 &#123;22 //查找指定子字符串的位置23 System.out.println(\"找到,该字符串位置：\"+s.indexOf(\"w\"));//从前向后查找24 System.out.println(\"找到，该字符串位置：\"+s.indexOf(\"w\",4));//从指定位置开始查找25 &#125;26 public void containstest()27 &#123;28 //判断某字符是否存在29 System.out.println(s.contains(\"d\")?\"该字符存在\":\"该字符不存在\");30 &#125;31 public void replacetest()32 &#123;33 //字符串替换34 System.out.println(s.replaceAll(\"l\", \"a\"));//全部替换35 System.out.println(s.replaceFirst(\"l\", \"a\"));//替换首个36 &#125;37 public void substringtest()38 &#123;39 //字符串截取40 System.out.println(s.substring(6));//截取指定位置到末尾41 System.out.println(s.substring(0, 5)+\"和\"+s.substring(6,11));//截取指定范围42 &#125;43 public void splittest()44 &#123;45 //字符串拆分46 String data[] = s.split(\"o\");//按指定字符全拆分47 for(String i:data)48 &#123;49 System.out.println(i);50 &#125;51 String data1[] = s.split(\"l\", 4);//拆分为指定元素个数的字符数组52 for(String j:data1)53 &#123;54 System.out.println(j);55 &#125;56 &#125;57 public void Casetest()58 &#123;59 //大小写转换60 System.out.println(s.toLowerCase());//小写61 System.out.println(s.toUpperCase());//大写62 &#125;63 &#125;64 public class Text&#123;65 public static void main(String[] args)66 &#123; 67 Demo dm = new Demo();68 dm.chartest();69 dm.Arraytest();70 dm.intexOftest();71 dm.containstest();72 dm.replacetest();73 dm.substringtest();74 dm.splittest();75 dm.Casetest();76 &#125;77 &#125;","categories":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/tags/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"study java day 35","slug":"study python 35 day","date":"2020-01-23T12:00:00.000Z","updated":"2020-01-31T06:57:52.256Z","comments":true,"path":"2020/01/23/study python 35 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/23/study%20python%2035%20day/","excerpt":"","text":"面向对象基础—类和对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 类的声明、属性的使用、对象的声明和使用(无参构造方法）： 1 class Person 2 &#123; 3 String name;//声明属性，即成员变量，Field又称为字段或域 4 int age; 5 public void talk()//公有方法method 6 &#123; 7 System.out.println(\"我是\"+name+\"，今年\"+age+\"岁\"); 8 &#125; 9 &#125;10 public class T01//测试类test11 &#123;12 public static void main(String[] args)//main主方法13 &#123;14 Person p = new Person();//调用Person无参构造方法声明Person类的实例化对象p15 p.name=\"Mary\";//为属性name赋值16 p.age=18;//为属性age赋值17 p.talk();//用对象p调用talk()方法18 &#125;19 &#125;2.有参的构造方法来为对象的成员变量赋初值： 1 class Person 2 &#123; 3 String name;//声明属性，即成员变量，Field又称为字段或域 4 int age; 5 public Person(String name,int age)//构造方法，与类同名 6 &#123; 7 this.name=name; 8 this.age=age; 9 &#125;10 public void talk()//公有方法method11 &#123;12 System.out.println(\"我是\"+name+\"，今年\"+age+\"岁\");13 &#125;14 &#125;15 public class T01//测试类test16 &#123;17 public static void main(String[] args)//main主方法18 &#123;19 Person p = new Person(\"Mary\",18);//调用有参构造方法声明Person类的实例化对象p，并赋初值20 p.talk();//用对象p调用talk()方法21 &#125;22 &#125;3.创建匿名对象复制代码 1 class Person 2 &#123; 3 public void talk() 4 &#123; 5 System.out.println(\"Hello World!\"); 6 &#125; 7 &#125; 8 public class T01 9 &#123;10 public static void main(String[] args)11 &#123;12 new Person().talk();//这是匿名对象13 &#125;14 &#125;由于匿名对象没有栈内存指向，所以只能使用一次，后被垃圾回收器收回。 4.区别Java中类属性和对象属性。类属性：被这个类定义的对象所共有，是静态的，一变全变。static String a=\"abc\";对象属性：这个类定义的对象私有，是非静态的，从一而终。String a=\"abc\"; 重复调用的代码块—-方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128前面看了一种特殊的方法——构造方法，已经对方法的定义和使用有了一定的了解，不再累述，这里主要想记录三个方面的内容：1.方法的重载——方法名相同，参数列表不同的方法签名机制。 参数列表不同，即参数个数、参数类型、参数顺序，至少有一项不同。需要注意的是，方法的修饰符和返回值类型不做要求。 看下面的实例： 1 class MethodOverload 2 &#123; 3 public int add(int a,int b)//计算两个整数之和的add()方法 4 &#123; 5 return a+b; 6 &#125; 7 public float add(float a,float b)//计算两个单精度浮点数之和的add()方法 8 &#123; 9 return a+b;10 &#125;11 public int add(int a,int b,int c)//计算三个整数之和的add()方法12 &#123;13 return a+b+c;14 &#125;15 &#125;16 public class T0117 &#123;18 public static void main(String[] args)19 &#123;20 int result1;21 float result2;22 MethodOverload a = new MethodOverload();23 result1=a.add(1,2);24 result2=a.add(1.2f,2.3f);25 result1=a.add(1,2,3);26 System.out.println(result1+\"--------\"+result2);27 &#125;28 &#125;上面的例子中定义了一个add()方法，参数列表不同，分别输出了各自的正确结果，两个整数之和被三个整数之和覆盖，这就是方法的重载。我们最常用的System.out.println()就是典型的方法重载。2.二次包装private不想公开的实现细节——在方法内部调用方法。 1 class Person 2 &#123; 3 private String name; 4 private int age; 5 public void say() 6 &#123; 7 this.talk();//在方法内调用方法 8 &#125; 9 private void talk()10 &#123;11 System.out.println(name+age);12 &#125;13 public void setName(String name)14 &#123;15 this.name=name;16 &#125;17 public String getName()18 &#123;19 return name;20 &#125;21 public void setAge(int age)22 &#123;23 this.age=age;24 &#125;25 public int getAge()26 &#123;27 return age;28 &#125;29 &#125;30 public class T0131 &#123;32 public static void main(String[] args)33 &#123;34 Person p = new Person();35 p.setAge(12);36 p.setName(\"xiaoxiao\");37 p.say();38 &#125;39 &#125;3.方法使用实例——把算法写进方法再调用class ArraySort 2 &#123; 3 public static void sort(int[] a) 4 &#123; 5 //冒泡排序算法 6 for(int i=0;i&lt;a.length;i++) 7 &#123; 8 for(int j=i+1;j&lt;a.length;j++) 9 &#123;10 if(a[i]&gt;a[j])11 &#123;12 int temp=a[i];13 a[i]=a[j];14 a[j]=temp;15 &#125;16 &#125;17 &#125;18 &#125;19 public static void print_a(int[] a,String b)20 &#123;21 System.out.println(b);22 23 for(int i:a)//foreach遍历数组24 &#123;25 System.out.print(i+\" \");26 &#125;27 System.out.println();28 &#125;29 &#125; 30 public class T0131 &#123;32 public static void main(String[] args)33 &#123;34 int[] a=&#123;43,46,22,67,86,27&#125;;35 ArraySort p = new ArraySort();36 p.print_a(a,\"排序前：\");37 p.sort(a);38 p.print_a(a,\"排序后：\");39 &#125;40 &#125; 面向对象的三大特性之一—-封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232封装是面向对象的第一个重要特征，在前面的笔记中已经有所体现。在看书学习的过程中发现封装和访问修饰符存在密切的联系，所以顺带对访问修饰符做一个大体的总结。一、封装的两种实现方式。 1.通过包实现封装性package ClassNotes; class Person &#123; ..... &#125;包的导入： 1 import ClassNotes.HelloSwing;//导入 2 class Person 3 &#123; 4 int age； 5 &#125; 6 public class T01 7 &#123; 8 public static void main(String[] args) 9 &#123;10 Person p = new Person();11 P.age=12;12 HelloSwing frame=new HelloSwing();//调用13 &#125;14 &#125;2.通过访问权限实现封装。 1 class Person 2 &#123; 3 private int age; 4 5 &#125; 6 public class T01 7 &#123; 8 public static void main(String[] args) 9 &#123;10 Person p = new Person();11 p.age=12;//错误的，无法给属性赋值12 &#125;13 &#125;(1).通过运用private修饰类、成员变量、成员方法来控制访问权限，从而达到封装的目的。如何解决上面例子的问题呢？下面给出程序： 1 class Person 2 &#123; 3 private int age; 4 public int getAge() 5 &#123; 6 return age; 7 &#125; 8 9 public void setAge(int age) 10 &#123;11 this.age = age;12 &#125;13 public void print()14 &#123;15 System.out.println(\"我今年：\"+age+\"岁。\");16 &#125;17 &#125;18 public class T0119 &#123;20 public static void main(String[] args)21 &#123;22 Person p = new Person();23 p.setAge(12);24 p.print();25 &#125;26 &#125;(2).很明显，当一个属性被private修饰，使用对象是无法直接调用它的，所以通过创建getter/setter方法来间接为属性赋值，达到封装的目的。有时候我们也在getter/setter方法中加入属性的控制语句，对所赋值的合理性进行判断。方法一：控制setter()方法 1 class Person 2 &#123; 3 private int age; 4 public int getAge() 5 &#123; 6 return age; 7 &#125; 8 9 public void setAge(int age) 10 &#123;11 if(age&gt;0&amp;&amp;age&lt;100)12 &#123;13 this.age=age;14 this.print1();15 &#125; 16 else17 &#123;18 this.age=age;19 this.print2();20 &#125;21 &#125;22 public void print1()23 &#123;24 System.out.println(\"我今年：\"+age+\"岁。\");25 &#125;26 public void print2()27 &#123;28 System.out.println(\"您输入的年龄\"+age+\"岁不符合常理，请重新输入！\");29 &#125;30 &#125;31 public class T0132 &#123;33 public static void main(String[] args)34 &#123;35 Person p = new Person();36 p.setAge(180);37 &#125;38 &#125;方法二：控制print()方法 1 class Person 2 &#123; 3 private int age; 4 public int getAge() 5 &#123; 6 return age; 7 &#125; 8 9 public void setAge(int age) 10 &#123;11 this.age=age;12 &#125;13 public void print()14 &#123;15 if(age&gt;0&amp;&amp;age&lt;150)16 System.out.println(\"我今年：\"+age+\"岁。\");17 else18 System.out.println(\"您输入的年龄\"+age+\"岁不符合常理，请重新输入！\");19 &#125;20 &#125;21 public class T0122 &#123;23 public static void main(String[] args)24 &#123;25 Person p = new Person();26 p.setAge(18);27 p.print();28 &#125;29 &#125;当p.setAge(18); 输出：我今年：18岁。当p.setAge(180); 输出：您输入的年龄180岁不符合常理，请重新输入！上面的两种方法虽说都达到了目的，但总感觉并没有真正控制赋值范围，后期如果想通了再来修改答案。(3).**注意：上述是用private封装属性，如果用private封装方法，又该怎么调用该方法呢?看下面的解决方法： 1 class Person 2 &#123; 3 private void print() 4 &#123; 5 System.out.println(\"我今年是\"+age+\"岁。\"); 6 &#125; 7 public int getAge() 8 &#123; 9 return age;10 print();//在类的方法中调用私有方法11 &#125;12 public void setAge(int age) 13 &#123;14 this.age=age;15 &#125;16 &#125;可以看出，访问修饰符private是对类外而言的，而在同一个类中，所有的类成员属性和方法都是互相可见的，也就是说它们能相互访问。(4).如果我们不想让初始化后的属性值被外界修改时，可以使用构造方法配合私有化setter方法来实现终极封装。 1 class Person 2 &#123; 3 private int age; 4 public Person(int age) 5 &#123; 6 setAge(age); 7 &#125; 8 public int getAge() 9 &#123;10 return age;11 &#125;12 private void setAge(int age) 13 &#123;14 if(age&gt;0&amp;&amp;age&lt;100)15 &#123;16 this.age=age;17 this.print1();18 &#125; 19 else20 &#123;21 this.age=age;22 this.print2();23 &#125;24 &#125;25 public void print1()26 &#123;27 System.out.println(\"我今年：\"+age+\"岁。\");28 &#125;29 public void print2()30 &#123;31 System.out.println(\"您输入的年龄\"+age+\"岁不符合常理，请重新输入！\");32 &#125;33 &#125;34 public class T0135 &#123;36 public static void main(String[] args)37 &#123;38 Person p = new Person(20);39 &#125;40 &#125;因为构造方法只能在实例化对象时调用一次，所以实现了属性值的终极封装。 面向对象的三大特性之二—-继承（含super使用）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781.继承的语法：class 子类 extends 父类例1： 1 class Person 2 &#123; 3 int age; 4 String name; 5 public void print1() 6 &#123; 7 System.out.println(\"我叫\"+name+\",今年\"+age+\"岁。\"); 8 &#125; 9 &#125;10 class Student extends Person11 &#123;12 String school;13 Student(int age,String name,String school)14 &#123;15 this.age=age;16 this.name=name;17 this.school=school;18 &#125;19 public void print2()20 &#123;21 System.out.println(\"我在\"+school+\"读书。\");22 &#125;23 &#125;24 public class T0225 &#123;26 public static void main(String[] args)27 &#123;28 Student s = new Student(21,\"Mary\",\"黑龙江科技大学\");29 s.print1();30 s.print2();31 &#125;32 &#125;2.Java中是单继承的，不允许多重继承，但可以使用多层继承。 即：一个类C只能有一个父类B，类C对类B是单继承的；而类B只有一个父类A，那么类C对类A就是多层继承。class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125;3.Java继承只能直接继承父类中的公有属性和公有方法，而隐含的继承了私有属性或私有方法。修改例1，得到例2： 1 class Person 2 &#123; 3 private int age; 4 String name; 5 public void setAge(int age) 6 &#123; 7 this.age=age; 8 &#125; 9 public int getAge()10 &#123;11 return age;12 &#125;13 public void print1()14 &#123;15 System.out.println(\"我叫\"+name+\",今年\"+age+\"岁。\");16 &#125;17 &#125;18 class Student extends Person19 &#123;20 String school;21 Student(String name,String school)22 &#123;23 //setAge(21);//也可以出现在这里，道理同下24 this.name=name;25 this.school=school;26 &#125;27 public void print2()28 &#123;29 print1();30 System.out.println(\"我在\"+school+\"读书。\");31 &#125;32 &#125;33 public class T0234 &#123;35 public static void main(String[] args)36 &#123;37 Student s = new Student(\"Mary\",\"黑龙江科技大学\");38 s.setAge(21);39 s.print2();40 &#125;41 &#125; 从上面例子看出，子类对父类中私有属性的调用，要借助setter()和getter()方法。即，我们可以通过父类的公有方法（包括构造方法）来访问父类的私有数据成员。4.被final修饰的类不能被继承。5.super关键字的使用。在上述例1的继承中，在初始化对象的时候，会默认先调用父类的无参构造方法，然后再调用子类的构造方法。事实上是子类构造方法的首行隐含了一个“super();”语句。下面调用父类有参构造函数来体现super的使用： 1 class Person 2 &#123; 3 int age; 4 String name; 5 Person(int age,String name) 6 &#123; 7 this.age=age; 8 this.name=name; 9 &#125;10 public void print1()11 &#123;12 System.out.println(\"我叫\"+name+\",今年\"+age+\"岁。\");13 &#125;14 &#125;15 class Student extends Person16 &#123;17 String school;18 Student(int age,String name,String school)19 &#123;20 super(age,name);//必须写在第一行，否则不能编译通过21 this.school=school;22 &#125;23 public void print2()24 &#123;25 System.out.println(\"我在\"+school+\"读书。\");26 &#125;27 &#125;28 public class T0229 &#123;30 public static void main(String[] args)31 &#123;32 Student s = new Student(21,\"Mary\",\"黑龙江科技大学\");33 s.print1();34 s.print2();35 &#125;36 &#125;事实上，super关键字的作用就是调用父类中的属性和方法（包含构造方法）。除特殊需求外，大多数情况是隐式使用，有时候作为和this共同出现区别子类属性（方法）和父类属性（方法）。Student(int age,String name,String school)&#123; super.age=age;//父类属性 super.name=name;//父类属性 this.school=school;//子类属性&#125;6.方法的重写：子类中的方法和父类中的方法的名称、参数个数和类型、返回值类型等都完全一致时，就称子类中的方法重写了父类中的方法。 1 class Father 2 &#123; 3 public void speak() 4 &#123; 5 System.out.println(\"我叫Tom，我是Alan的父亲。\"); 6 &#125; 7 &#125; 8 class Son extends Father 9 &#123;10 public void speak()11 &#123;12 System.out.println(\"我叫Alan，我是Tom的儿子。\");13 &#125;14 &#125;15 public class T0216 &#123;17 public static void main(String[] args)18 &#123;19 Son p = new Son();20 p.speak();21 &#125;22 &#125;输出结果：我叫Alan，我是Tom的儿子。重写中需要注意的问题：被重写的方法不能为static；子类的访问权限要大于等于父类。 面向对象的三大特性之三—-多态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160多态，简单来说就是一种类型表现出多种状态。在Java中多态分为两类。一、方法多态性——方法的重载和重写。关于这部分内容已经在前面的内容有过详细的记录，即重复调用的代码块—方法和面向对象的特性之二—继承。二、对象的多态性——引用类型转换。1.向上转型（自动转型）——子类对象自动转换为父类对象。 1 class Father 2 &#123; 3 public void speak() 4 &#123; 5 System.out.println(\"我来自父类Father。\"); 6 &#125; 7 &#125; 8 class Son extends Father 9 &#123;10 public void speak()11 &#123;12 System.out.println(\"我来自子类Son。\");13 &#125;14 &#125;15 class Daughter extends Father16 &#123;17 public void speak()18 &#123;19 System.out.println(\"我来自子类Daughter。\");20 &#125;21 &#125;22 public class T0223 &#123;24 public static void main(String[] args)25 &#123;26 Father p;27 Son s = new Son();28 Daughter d = new Daughter();29 p=s;//子类对象向上类型转换为Father类型30 p.speak();31 p=d;32 p.speak();33 &#125;34 &#125;输出结果如下：我来自子类Son。我来自子类Daughter。可以看出，第26行声明了一个父类对象p，但没有实例化；第27、28行分别声明子类对象s、d并实例化；经过赋值操作，将子类对象向上转型为Father类型。通过p调用其speak方法，实际输出的是子类对象的speak方法。这里就体现了多态性思想。需要注意的是：上述父类对象只能调用被子类重写的方法，对于子类自己独有的方法，父类对象是无法访问的。 1 class Father 2 &#123; 3 public void speak() 4 &#123; 5 System.out.println(\"我来自父类Father。\"); 6 &#125; 7 &#125; 8 class Son extends Father 9 &#123;10 public void speak()11 &#123;12 System.out.println(\"我来自子类Son。\");13 &#125;14 public void print()15 &#123;16 System.out.println(\"我是Tom。\");17 &#125;18 &#125;19 public class T0220 &#123;21 public static void main(String[] args)22 &#123;23 Father p;24 Son s = new Son();25 p=s;//子类对象向上类型转换为Father类型26 p.speak();27 p.print();//错误的，无法访问28 &#125;29 &#125;那么如果非要调用子类的print()方法，那么就要用到下面的向下强制转型，将父类对象赋值给子类对象。2.向下转型（强制转型）——父类对象强制转换为子类对象。 1 class Father 2 &#123; 3 public void speak() 4 &#123; 5 System.out.println(\"我来自父类Father。\"); 6 &#125; 7 &#125; 8 class Son extends Father 9 &#123;10 public void speak()11 &#123;12 System.out.println(\"我来自子类Son。\");13 &#125;14 public void print()15 &#123;16 System.out.println(\"我是Tom。\");17 &#125;18 &#125;19 public class T0220 &#123;21 public static void main(String[] args)22 &#123;23 Father p = new Son();24 p.speak();//自动类型转换25 ((Son) p).print();//强制类型转换26 &#125;27 &#125;如果同时存在多个子类，就需要使用instanceof关键字来检测转换的安全性，即在每次转换之前都加上一个if判断语句：if(p instanceof Son)&#123; Son s1 = (Son)p();&#125;else&#123; System.out.println(\"无法转换！\");&#125;3.隐藏——static无法被重写的特性。当我们不想调用子类中重写的方法，而希望调用父类中原来的方法时，就可以使用隐藏来实现。 1 class Father 2 &#123; 3 public static void speak() 4 &#123; 5 System.out.println(\"我来自父类Father。\"); 6 &#125; 7 &#125; 8 class Son extends Father 9 &#123;10 public static void speak()11 &#123;12 System.out.println(\"我来自子类Son。\");13 &#125;14 &#125;15 public class T0216 &#123;17 18 public static void main(String[] args)19 &#123;20 Father p = new Son();21 p.speak();//调用的是父类中的speak()方法22 &#125;23 &#125;输出结果：我来自父类Father。","categories":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/tags/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"java 课程笔记","slug":"java-课程笔记","permalink":"https://yanxigun99.github.io/categories/java-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"study java day 34","slug":"study python 34 day","date":"2020-01-22T12:00:00.000Z","updated":"2020-01-31T06:37:53.750Z","comments":true,"path":"2020/01/22/study python 34 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/22/study%20python%2034%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package test;public class test&#123; public static void main(String [] args) &#123; System.out.println(\"hello world\"); //打印菱形 print(8); //打印九九乘法表 for(int i=1;i&lt;=9;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; System.out.print(j+\"*\"+i+\"=\"+\"j*i\"+\"\\t\"); &#125; System.out.println(); &#125; //打印三角形 for(int i=1;i&lt;=5;i++) &#123; for(int j=5;j&gt;i-1;j--) &#123; System.out.print(\" \"); &#125; for(int j=1;j&lt;=i*2-1;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; //打印倒立的三角形 for(int i=1;i&lt;=4;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; System.out.print(\" \"); &#125; for(int x=1;x&lt;=7-2*(i-1);x++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; //输出平行四边形 for(int i=1;i&lt;=5;i++) &#123; for(int j=1;j&lt;=5-i;j++) &#123; System.out.print(\" \"); &#125; for(int k=1;k&lt;=5;k++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; //打印矩形 for(int i=1;i&lt;=5;i++) &#123; System.out.print(\"*\"); for(int j=1;j&lt;=5;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; &#125; public static void print(int size) &#123; if (size % 2 == 0) &#123; size++; // 计算菱形大小 &#125; for (int i = 0; i &lt; size / 2 + 1; i++) &#123; for (int j = size / 2 + 1; j &gt; i + 1; j--) &#123; System.out.print(\" \"); // 输出左上角位置的空白 &#125; for (int j = 0; j &lt; 2 * i + 1; j++) &#123; System.out.print(\"*\"); // 输出菱形上半部边缘 &#125; System.out.println(); // 换行 &#125; for (int i = size / 2 + 1; i &lt; size; i++) &#123; for (int j = 0; j &lt; i - size / 2; j++) &#123; System.out.print(\" \"); // 输出菱形左下角空白 &#125; for (int j = 0; j &lt; 2 * size - 1 - 2 * i; j++) &#123; System.out.print(\"*\"); // 输出菱形下半部边缘 &#125; System.out.println(); // 换行 &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package test;import java.io.*;import java.util.*;public class test&#123; public static void main(String[]args) throws Exception&#123; /**try &#123; BufferedWriter out = new BufferedWriter(new FileWriter(\"runoob.txt\")); out.write(\"菜鸟教程\"); out.close(); System.out.println(\"创建成功！\"); &#125;catch(IOException e) &#123; &#125; try &#123; BufferedReader in=new BufferedReader(new FileReader(\"runoob.txt\")); String str; while((str=in.readLine())!=null) &#123; System.out.println(str); &#125; System.out.println(str); &#125;catch(IOException e) &#123; &#125; try&#123; File file = new File(\"c:\\\\test.txt\"); if(file.delete())&#123; System.out.println(file.getName() + \" 文件已被删除！\"); &#125;else&#123; System.out.println(\"文件删除失败！\"); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; BufferedWriter out1=new BufferedWriter(new FileWriter(\"srcfile\")); out1.write(\"string to be copied\\n\"); out1.close(); InputStream in=new FileInputStream(new File(\"srcfile\")); OutputStream out=new FileOutputStream(new File(\"destnfile\")); byte[] but=new byte[1024]; int len; while((len=in.read(but))&gt;0) &#123; out.write(but,0,len); &#125; in.close(); out.close(); BufferedReader in1=new BufferedReader(new FileReader(\"destnfile\")); String str; while((str=in1.readLine())!=null) &#123; System.out.println(str); &#125; in1.close(); try &#123; BufferedWriter out=new BufferedWriter(new FileWriter(\"filename\")); out.write(\"aString1\\n\"); out.close(); out=new BufferedWriter(new FileWriter(\"filename\",true)); out.write(\"aString2\\n\"); out.close(); BufferedReader in=new BufferedReader(new FileReader(\"filename\")); String str; while((str=in.readLine())!=null) &#123; System.out.println(str); &#125; in.close(); &#125;catch(IOException e) &#123; System.out.println(\"exception occoured\"+e); &#125; File temp=File.createTempFile(\"testrunoobtemp\",\".txt\"); System.out.println(\"文件路径\"+temp.getAbsolutePath()); temp.deleteOnExit(); BufferedWriter out=new BufferedWriter(new FileWriter(temp)); out.write(\"aString\"); System.out.println(\"临时文件已创建\")； out.close(); File filetochange=new File(\"myjavafile.txt\"); filetochange.createNewFile(); Date filetime=new Date(filetochange.lastModified()); System.out.println(filetime.toString()); System.out.println(filetochange.setLastModified(System.currentTimeMillis())); filetime=new Date(filetochange.lastModified()); System.out.println(filetime.toString()); File oldName=new File(\"program.txt\"); File newName=new File(\"java.txt\"); if(oldName.renameTo(newName)) &#123; System.out.println(\"已重命名\"); &#125;else &#123; System.out.println(\"Error\"); &#125; File file1=new File(\"java1.txt\"); System.out.println(file1.setReadOnly()); System.out.println(file1.canWrite()); System.out.println(file1.exists()); File file = null; File dir = new File(\"C:/\"); file = File.createTempFile (\"JavaTemp\", \".javatemp\", dir); System.out.println(file.getPath()); File file=new File(\"Main.java\"); Long lastModified=file.lastModified(); Date date=new Date(lastModified); System.out.println(date); try &#123; File file=new File(\"test.java\"); if(file.createNewFile()) &#123; System.out.println(\"good\"); &#125;else &#123; System.out.println(\"error\"); &#125; &#125;catch(IOException ioe) &#123; ioe.printStackTrace(); &#125; **/ File file1=new File(\"C:/java/demo1.txt\"); File file2=new File(\"C:/java/demo2.txt\"); if(file1.compareTo(file2)==0) &#123; System.out.println(\"yes\"); &#125;else &#123; System.out.println(\"no\"); &#125; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}]},{"title":"study java day 33","slug":"study python 33 day","date":"2020-01-21T12:00:00.000Z","updated":"2020-01-21T12:25:36.002Z","comments":true,"path":"2020/01/21/study python 33 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/21/study%20python%2033%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248package test;import java.util.*;public class test&#123; public static void displayObjectClass(Object o) &#123; if(o instanceof Vector) System.out.println(\"对象是Vector\"); else if (o instanceof ArrayList) System.out.println(\"对象是ArrayList\"); else System.out.println(\"对象不是实例\"); &#125; public static void printArray(Integer[] inputArray) &#123; for(Integer element:inputArray) &#123; System.out.printf(\"%s\",element); System.out.println(); &#125; &#125; public static void printArray(Character[] inputArray) &#123; for(Character element:inputArray) &#123; System.out.printf(\"%s\", element); System.out.println(); &#125; &#125; public static void printArray(Double[]inputArray) &#123; for(Double element:inputArray) &#123; System.out.printf(\"%s\", element); System.out.println(); &#125; &#125; public static void doTowers(int topN,char from,char inter,char to) &#123; if(topN==1) &#123; System.out.println(\"Disk 1 from\"+from+\"to\"+to); &#125;else &#123; doTowers(topN-1,from,to,inter); System.out.println(\"Disk\"+topN+\"from\"+from+\"to\"+to); doTowers(topN-1,inter,from,to); &#125; &#125; public static long fibonacci(long number) &#123; if((number==0)||(number==1)) return number; else return fibonacci(number-1)+fibonacci(number-2); &#125; public static long factorial(long number) &#123; if(number&lt;=1)&#123; return 1; &#125;else &#123; return number*factorial(number-1); &#125; &#125; public static void main(String []args) &#123; System.out.println(\"hello world\"); //实例演示了如何重载 MyClass 类的 info 方法 MyClass t=new MyClass(3); t.info(); t.info(\"重载方法\"); new MyClass(); //通过重载 MainClass 类的 printArray 方法输出不同类型(整型, 双精度及字符型)的数组 Integer[] integerArray= &#123;1,2,3,4,5,6&#125;; Double[] doubleArray= &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7&#125;; Character[] characterArray= &#123; 'H', 'E', 'L', 'L', 'O' &#125;; System.out.println(\"输出整型数组：\"); printArray(integerArray); printArray(doubleArray); printArray(characterArray); //汉诺塔算法的实现 int nDisks=3; doTowers(nDisks,'A','B','C'); //斐波那契数列 for(int counter=0;counter&lt;=10;counter++) &#123; System.out.printf(\"Fibonacci of %d id:%d\\n\",counter,fibonacci(counter)); &#125; //阶乘 for(int counter=0;counter&lt;=10;counter++) &#123; System.out.printf(\"%d!=%d\\n\", counter,factorial(counter)); &#125; //Java 方法覆盖（Overriding）代码的实现 Figure f=new Figure(10,10); Rectangle r=new Rectangle(9,5); Figure figref; figref=f; System.out.println(\"Area is:\"+figref.area()); figref=r; System.out.println(\"Area is:\"+figref.area()); //创建了 displayObjectClass() 方法来演示 Java instanceof 关键字用法 Object testObject=new ArrayList(); displayObjectClass(testObject); //break 用法 int[] intary= &#123;99,12,22,34,45,67,5678,8990&#125;; int no=5678; boolean found=false; int i=0; for(;i&lt;intary.length;i++) &#123; if(intary[i]==no) &#123; found=true; break; &#125; &#125; if(found) &#123; System.out.println(no+\"在元素索引位置：\"+i); &#125;else &#123; System.out.println(\"元素不在数组内\"); &#125; //用了 continue 关键字来跳过当前循环并开始下一次循环 StringBuffer searchstr=new StringBuffer(\"hello how arhe you\"); int length=searchstr.length(); int count=0; for(int j=0;j&lt;length;j++) &#123; if(searchstr.charAt(j)!='h') continue; count++; searchstr.setCharAt(j, 'w'); &#125; System.out.println(\"发现 \" + count + \" 个 h 字符\"); System.out.println(searchstr); //当在循环中使用 break 或 continue 循环时跳到指定的标签处 /* String strSearch = \"This is the string in which you have to search for a substring.\"; String substring = \"substring\"; boolean found = false; int max = (strSearch.length() - substring.length()); testlbl: for (int i = 0; i &lt;= max; i++) &#123; int length = substring.length(); int j = i; int k = 0; while (length-- != 0) &#123; if(strSearch.charAt(j++) != substring.charAt(k++))&#123; continue testlbl; &#125; &#125; found = true; break testlbl; &#125; if (found) &#123; System.out.println(\"发现子字符串。\"); &#125; else &#123; System.out.println(\"字符串中没有发现子字符串。\"); &#125;*/ //对enum进行遍历和switch的操作示例 car c; c=car.tata; switch(c) &#123; case lamborghini: System.out.println(\"你选择了Lamborghini\"); break; case tata: System.out.println(\"你选择了tata\"); break; case audi: System.out.println(\"你选择了audi\"); break; case fiat: System.out.println(\"你选择了Fiat\"); break; case honda: System.out.println(\"你选择了honda\"); break; default: System.out.println(\"我不知道你的车型\"); break; &#125; System.out.println(\"所有汽车的价格\"); for(Car x:Car.values()) &#123; System.out.println(x+\"需要\"+x.getPrice()+\"千美元\"); &#125; &#125; &#125;enum Car&#123; lamborghini(900),tata(2),audi(50),fiat(15),honda(12); private int price; Car(int p)&#123; price=p; &#125; int getPrice() &#123; return price; &#125;&#125;enum car&#123; lamborghini,tata,audi,fiat,honda&#125;class Figure&#123; double dim1; double dim2; Figure(double a,double b)&#123; dim1=a; dim2=b; &#125; Double area() &#123; System.out.println(\"Inside area for figure.\"); return (dim1*dim2); &#125;&#125;class Rectangle extends Figure&#123; Rectangle(double a,double b)&#123; super(a,b); &#125; Double area() &#123; System.out.println(\"Inside area for rectangle.\"); return (dim1*dim2); &#125;&#125;class MyClass&#123; int height; MyClass()&#123; System.out.println(\"无参数构造函数\"); height=4; &#125; MyClass(int i)&#123; System.out.println(\"房子的高度\"+i+\"米\"); height=i; &#125; void info() &#123; System.out.println(\"房子高度\"+height+\"米\"); &#125; void info(String s) &#123; System.out.println(s+\"房子高度\"+height+\"米\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package test;public class test&#123; public static void main(String []args) &#123; int[] intary= &#123;1,2,3,4&#125;; forDisplay(intary); foreachDisplay(intary); //varargs的新功能，就是可变长度的参数 int sum=0; sum = sumvarargs(new int[]&#123;10,12,33&#125;); System.out.println(\"数字相加之和为: \" + sum); //如何在重载方法中使用可变参数 vaTest(1, 2, 3); vaTest(\"测试: \", 10, 20); vaTest(true, false, false); &#125; static void vaTest(int... no) &#123; System.out.print(\"vaTest(int ...): \" + \"参数个数: \" + no.length +\" 内容: \"); for(int n:no) &#123; System.out.print(n+\" \"); &#125; System.out.println(); &#125; static void vaTest(boolean ... bl) &#123; System.out.print(\"vaTest(boolean ...) \" + \"参数个数: \" + bl.length + \" 内容: \"); for(boolean b : bl) System.out.print(b + \" \"); System.out.println(); &#125; static void vaTest(String msg, int ... no) &#123; System.out.print(\"vaTest(String, int ...): \" + msg +\"参数个数: \"+ no.length +\" 内容: \"); for(int n : no) System.out.print(n + \" \"); System.out.println(); &#125; static int sumvarargs(int... intArrays)&#123; int sum, i; sum=0; for(i=0; i&lt; intArrays.length; i++) &#123; sum += intArrays[i]; &#125; return(sum); &#125; public static void forDisplay(int[] a) &#123; System.out.println(\"使用for循环数组\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+\" \"); &#125; System.out.println(); &#125; public static void foreachDisplay(int [] data) &#123; System.out.println(\"使用foreach循环数组\"); for(int a:data) &#123; System.out.print(a+\" \"); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}]},{"title":"study java day 32","slug":"study python 32 day","date":"2020-01-20T12:00:00.000Z","updated":"2020-01-20T14:29:12.612Z","comments":true,"path":"2020/01/20/study python 32 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/20/study%20python%2032%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317package test;import java.util.*;import java.text.*;public class test&#123; public static void main(String [] args) &#123; String str=\"hello world\"; String outehrstr=\"Hello Workld\"; Object objstr=str; System.out.println(str.compareTo(outehrstr)); System.out.println(str.compareToIgnoreCase(outehrstr)); System.out.println(str.compareTo(objstr.toString())); String strorg=\"the last one nooble\"; int lastInt=strorg.lastIndexOf(\"last\"); if(lastInt==-1) &#123; System.out.println(\"没找到\"); &#125;else &#123; System.out.println(\"最后找到的位置为:\"+lastInt); &#125; String test=\"this is a test\"; System.out.println(removeCharAt(test,5)); System.out.println(test.replace(\"is\",\"IS\" )); System.out.println(test.replaceFirst(\"is\", \"IS\")); System.out.println(test.replaceAll(\"i\", \"this\")); String reverse=new StringBuffer(test).reverse().toString(); String reverse1=new StringBuffer(test).reverse().toString(); System.out.println(reverse); //分割字符串 String test2=\"run-two-stop\"; String [] temp; String str1=\"-\"; temp=test2.split(str1); for(String x:temp) &#123; System.out.println(x); System.out.println(\"\"); &#125; for(int i=0;i&lt;temp.length;i++) &#123; System.out.println(temp[i]); System.out.println(\"\"); &#125; //StringTokennizer 设置不同分隔符来分隔字符串，默认的分隔符是：空格、制表符（\\t）、换行符(\\n）、回车符（\\r） String str3 = \"This is String , split by StringTokenizer, created by runoob\"; StringTokenizer tem=new StringTokenizer(str3); while (tem.hasMoreElements()) &#123; System.out.println(tem.nextElement()); &#125; String str4=str3.toUpperCase(); //大小写转换 System.out.println(str3.toUpperCase()); System.out.println(str4.toLowerCase()); //regionMatches() 方法测试两个字符串区域是否相等 String first_str = \"Welcome to Microsoft\"; String second_str = \"I work with microsoft\"; boolean match1=first_str.regionMatches(11, second_str, 12, 9); boolean match2=first_str.regionMatches(true, 11, second_str, 12, 9); System.out.println(match1); System.out.println(match2); //比较两种生成字符串效率 long starTime=System.currentTimeMillis(); for(int i=0;i&lt;5000;i++) &#123; String s1=\"10000\"; String s2=\"10000\"; &#125; long endTime=System.currentTimeMillis(); System.out.println(\"第一种时间：\"+(endTime-starTime)); long starTime1=System.currentTimeMillis(); for(int i=0;i&lt;5000;i++) &#123; String s1=new String(\"10000\"); String s2=new String(\"10000\"); &#125; long endTime1=System.currentTimeMillis(); System.out.println(\"第二种时间：\"+(endTime1-starTime1)); //format()字符串格式化 double e = Math.E; System.out.format(\"%f%n\", e); System.out.format(Locale.CHINA , \"%-10.4f%n%n\", e); //通过 \"+\" 操作符和StringBuffer.append() 方法来连接字符串，并比较其性能 long startTime2 = System.currentTimeMillis(); for(int i=0;i&lt;5000;i++)&#123; String result = \"This is\" + \"testing the\" + \"difference\"+ \"between\" + \"String\"+ \"and\"+ \"StringBuffer\"; &#125; long endTime2 = System.currentTimeMillis(); System.out.println(\"字符串连接\" + \" - 使用 + 操作符 : \" + (endTime2 - startTime2)+ \" ms\"); long startTime3 = System.currentTimeMillis(); for(int i=0;i&lt;5000;i++)&#123; StringBuffer result = new StringBuffer(); result.append(\"This is\"); result.append(\"testing the\"); result.append(\"difference\"); result.append(\"between\"); result.append(\"String\"); result.append(\"and\"); result.append(\"StringBuffer\"); &#125; long endTime3 = System.currentTimeMillis(); System.out.println(\"字符串连接\" + \" - 使用 StringBuffer : \" + (endTime3 - startTime3)+ \" ms\"); //如何使用sort()方法对Java数组进行排序，及如何使用 binarySearch() 方法来查找数组中的元素, 这边我们定义了 printArray() 方法来打印数组 int array[] = &#123; 2, 5, -2, 6, -3, 8, 0, -7, -9, 4 &#125;; Arrays.sort(array); printArray(\"数组排序结果为\", array); int index = Arrays.binarySearch(array, 2); System.out.println(\"元素 2 在第 \" + index + \" 个位置\"); int array1[] = &#123; 2, 5, -2, 6, -3, 8, 0, -7, -9, 4 &#125;; Arrays.sort(array); printArray(\"数组排序\", array1); int index1 = Arrays.binarySearch(array1, 1); System.out.println(\"元素 1 所在位置（负数为不存在）：\" + index1); int newIndex1 = -index1 - 1; array1 = insertElement(array1, 1, newIndex1); printArray(\"数组添加元素 1\", array1); //获取二位数组长度 String [][] arr=new String[4][5]; System.out.println(arr.length); System.out.println(arr[0].length); //使用 Collections.reverse(ArrayList) 将数组进行反转 ArrayList &lt;String&gt; al=new ArrayList&lt;String&gt;(); al.add(\"a\"); al.add(\"c\"); al.add(\"e\"); System.out.println(al); Collections.reverse(al); System.out.println(al); //循环输出数组 int [] testarr= &#123;1,2,3&#125;; for(int i=0;i&lt;testarr.length;i++) &#123; System.out.println(testarr[i]); &#125; //通过 Collections 类的 Collections.max() 和 Collections.min() 方法来查找数组中的最大和最小值 Integer[] numbers = &#123; 8, 2, 7, 1, 4, 9, 5&#125;; int min=(int)Collections.min(Arrays.asList(numbers)); int max=(int)Collections.max(Arrays.asList(numbers)); System.out.println(min); System.out.println(max); //通过 List 类的 Arrays.toString () 方法和 List 类的 list.Addall(array1.asList(array2) 方法将两个数组合并为一个数组 String a[] = &#123; \"A\", \"E\", \"I\" &#125;; String b[] = &#123; \"O\", \"U\" &#125;; List list=new ArrayList(Arrays.asList(a)); list.addAll(Arrays.asList(b)); System.out.println(list.toString()); //通过 Java Util 类的 Arrays.fill(arrayname,value) 方法和Arrays.fill(arrayname ,starting index ,ending index ,value) 方法向数组中填充元素 int [] arrtest1=new int[6]; Arrays.fill(arrtest1,100); for(int x:arrtest1) &#123; System.out.println(x); &#125; String[] names=new String[] &#123;\"a\",\"b\",\"c\"&#125;; String[] extended=new String[5]; extended[3]=\"d\"; extended[4]=\"e\"; System.arraycopy(names, 0, extended, 0, names.length); for(String x:extended) &#123; System.out.println(x); &#125; //找出重复元素 int[] my_array = &#123;1, 2, 5, 5, 6, 6, 7, 2, 9, 2&#125;; findDupicateInArray(my_array); //删除数组元素 ArrayList&lt;String&gt; objArray=new ArrayList&lt;String&gt;(); objArray.clear(); objArray.add(0,\"one\"); objArray.add(1,\"two\"); objArray.add(2, \"three\"); System.out.println(objArray); objArray.remove(1); objArray.remove(\"one\"); System.out.println(objArray); //使用 removeAll () 方法来计算两个数组的差集 ArrayList objArray1=new ArrayList(); ArrayList objArray2=new ArrayList(); objArray2.add(0,\"common1\"); objArray2.add(1,\"common2\"); objArray2.add(2,\"notcommon\"); objArray2.add(3,\"notcommon1\"); objArray1.add(0,\"common1\"); objArray1.add(1,\"common2\"); objArray1.add(2,\"notcommon2\"); System.out.println(objArray1); System.out.println(objArray2); objArray1.removeAll(objArray2); System.out.println(objArray1); //使用 retainAll () 方法来计算两个数组的交集 objArray1.retainAll(objArray2); System.out.println(objArray1); //使用 contains () 方法来查找数组中的指定元素 System.out.println(objArray2.contains(\"common2\")); //使用 equals ()方法来判断数组是否相等 int[] ary = &#123;1,2,3,4,5,6&#125;; int[] ary1 = &#123;1,2,3,4,5,6&#125;; int[] ary2 = &#123;1,2,3,4&#125;; System.out.println(Arrays.equals(ary, ary1)); System.out.println(Arrays.equals(ary1,ary2)); String[] arr1 = &#123; \"1\", \"2\", \"3\" &#125;; String[] arr2 = &#123; \"4\", \"5\", \"6\" &#125;; String[] result_union=union(arr1,arr2); for(String str12:result_union) &#123; System.out.println(str12); &#125; //使用 SimpleDateFormat 类的 format(date) 方法来格式化时间 Date date=new Date(); String strDateFormat=\"yyyy-MM-dd HH:mm:ss a\"; SimpleDateFormat sdf=new SimpleDateFormat(strDateFormat); System.out.println(sdf.format(date)); System.out.println(sdf.format(date)); //如何使用 Calendar 类来输出年份、月份等 Calendar cal=Calendar.getInstance(); int day=cal.get(Calendar.DATE); int month=cal.get(Calendar.MONTH); int year=cal.get(Calendar.YEAR); int dow=cal.get(Calendar.DAY_OF_WEEK); int dom=cal.get(Calendar.DAY_OF_MONTH); int doy=cal.get(Calendar.DAY_OF_YEAR); System.out.println(cal.getTime()); System.out.println(day); System.out.println(month); System.out.println(year); System.out.println(dow); System.out.println(dom); System.out.println(doy); //使用 SimpleDateFormat 类的 format() 方法将时间戳转换成时间 Long timeStamp = System.currentTimeMillis(); //获取当前时间戳 SimpleDateFormat sdf2=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String sd = sdf2.format(new Date(Long.parseLong(String.valueOf(timeStamp)))); // 时间戳转换成时间 System.out.println(\"格式化结果：\" + sd); SimpleDateFormat sdf3 = new SimpleDateFormat(\"yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒\"); String sd4 = sdf3.format(new Date(Long.parseLong(String.valueOf(timeStamp)))); System.out.println(\"格式化结果：\" + sd4); &#125; public static String[] union(String[] arr1,String[] arr2) &#123; Set&lt;String&gt; set=new HashSet&lt;String&gt;(); for(String str:arr1) &#123; set.add(str); &#125; for(String str:arr2) &#123; set.add(str); &#125; String[] result= &#123; &#125;; return set.toArray(result); &#125; public static void findDupicateInArray(int[] a) &#123; int count=0; for(int j=0;j&lt;a.length;j++) &#123; for(int k=j+1;k&lt;a.length;k++) &#123; if(a[j]==a[k]) &#123; count++; &#125; &#125; if(count==1) &#123; System.out.println(a[j]); count=0; &#125; &#125; &#125; private static void printArray(String message,int array[]) &#123; System.out.println(message+\": [length:\"+array.length+\"]\"); for(int i=0;i&lt;array.length;i++) &#123; if(i!=0) &#123; System.out.print(\", \"); &#125; System.out.print(array[i]); &#125; System.out.println(); &#125; private static int[] insertElement(int original[], int element, int index) &#123; int length = original.length; int destination[] = new int[length + 1]; System.arraycopy(original, 0, destination, 0, index); destination[index] = element; System.arraycopy(original, index, destination, index + 1, length - index); return destination; &#125; public static String removeCharAt(String s,int n)&#123; return s.substring(0,n)+s.substring(n+1); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://yanxigun99.github.io/categories/java/"}]},{"title":"study python项目006 007 day 31","slug":"study python 31 day","date":"2020-01-19T12:00:00.000Z","updated":"2020-01-19T14:52:16.188Z","comments":true,"path":"2020/01/19/study python 31 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/19/study%20python%2031%20day/","excerpt":"","text":"12345678910项目006：定制二维码from MyQR import myqrmyqr.run( words='http://baidu.com', picture='Sources/ssss.jpg', colorized=True, save_name='test.png') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269项目007：给图片打上二维码\"\"\"使用 Python 创建照片马赛克输入一张目标照片和多张替换照片，将目标照片按网格划分为许多小方块，然后将每个小方块替换为颜色值最接近的那张替换照片，就形成了马赛克效果。\"\"\"import argparseimport osimport numpy as npfrom PIL import Imagedef splitImage(image, size): \"\"\" 将图像按网格划分成多个小图像 @param &#123;Image&#125; image PIL Image 对象 @param &#123;Tuple[int, int]&#125; size 网格的行数和列数 @return &#123;List[Image]&#125; 小图像列表 \"\"\" W, H = image.size[0], image.size[1] m, n = size w, h = int(W / n), int(H / m) imgs = [] # 先按行再按列裁剪出 m * n 个小图像 for j in range(m): for i in range(n): # 坐标原点在图像左上角 imgs.append(image.crop((i * w, j * h, (i + 1) * w, (j + 1) * h))) return imgsdef getImages(imageDir): \"\"\" 从给定目录里加载所有替换图像 @param &#123;str&#125; imageDir 目录路径 @return &#123;List[Image]&#125; 替换图像列表 \"\"\" files = os.listdir(imageDir) images = [] for file in files: # 得到文件绝对路径 filePath = os.path.abspath(os.path.join(imageDir, file)) try: fp = open(filePath, \"rb\") im = Image.open(fp) images.append(im) # 确定了图像信息，但没有加载全部图像数据，用到时才会 im.load() # 用完关闭文件，防止资源泄露 fp.close() except: # 加载某个图像识别，直接跳过 print(\"Invalid image: %s\" % (filePath,)) return imagesdef getAverageRGB(image): \"\"\" 计算图像的平均 RGB 值 将图像包含的每个像素点的 R、G、B 值分别累加，然后除以像素点数，就得到图像的平均 R、G、B 值 @param &#123;Image&#125; image PIL Image 对象 @return &#123;Tuple[int, int, int]&#125; 平均 RGB 值 \"\"\" # 计算像素点数 npixels = image.size[0] * image.size[1] # 获得图像包含的每种颜色及其计数，结果类似 [(cnt1, (r1, g1, b1)), ...] cols = image.getcolors(npixels) # 获得每种颜色的 R、G、B 累加值，结果类似 [(c1 * r1, c1 * g1, c1 * g2), ...] sumRGB = [(x[0] * x[1][0], x[0] * x[1][1], x[0] * x[1][2]) for x in cols] # 分别计算所有颜色的 R、G、B 平均值，算法类似(sum(ci * ri)/np, sum(ci * gi)/np, # sum(ci * bi)/np) # zip 的结果类似[(c1 * r1, c2 * r2, ..), (c1 * g1, c1 * g2, ...), (c1 * b1, # c1 * b2, ...)] avg = tuple([int(sum(x) / npixels) for x in zip(*sumRGB)]) return avgdef getAverageRGBNumpy(image): \"\"\" 计算图像的平均 RGB 值，使用 numpy 来计算以提升性能 @param &#123;Image&#125; image PIL Image 对象 @return &#123;Tuple[int, int, int]&#125; 平均 RGB 值 \"\"\" # 将 PIL Image 对象转换为 numpy 数据数组 im = np.array(image) # 获得图像的宽、高和深度 w, h, d = im.shape # 将数据数组变形并计算平均值 return tuple(np.average(im.reshape(w * h, d), axis=0))def getBestMatchIndex(input_avg, avgs): \"\"\" 找出颜色值最接近的索引 把颜色值看做三维空间里的一个点，依次计算目标点跟列表里每个点在三维空间里的距离，从而得到距 离最近的那个点的索引。 @param &#123;Tuple[int, int, int]&#125; input_avg 目标颜色值 @param &#123;List[Tuple[int, int, int]]&#125; avgs 要搜索的颜色值列表 @return &#123;int&#125; 命中元素的索引 \"\"\" index = 0 min_index = 0 min_dist = float(\"inf\") for val in avgs: # 三维空间两点距离计算公式 (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) # + (z1 - z2) * (z1 - z2)，这里只需要比较大小，所以无需求平方根值 dist = ((val[0] - input_avg[0]) * (val[0] - input_avg[0]) + (val[1] - input_avg[1]) * (val[1] - input_avg[1]) + (val[2] - input_avg[2]) * (val[2] - input_avg[2])) if dist &lt; min_dist: min_dist = dist min_index = index index += 1 return min_indexdef createImageGrid(images, dims): \"\"\" 将图像列表里的小图像按先行后列的顺序拼接为一个大图像 @param &#123;List[Image]&#125; images 小图像列表 @param &#123;Tuple[int, int]&#125; dims 大图像的行数和列数 @return Image 拼接得到的大图像 \"\"\" m, n = dims # 确保小图像个数满足要求 assert m * n == len(images) # 计算所有小图像的最大宽度和高度 width = max([img.size[0] for img in images]) height = max([img.size[1] for img in images]) # 创建大图像对象 grid_img = Image.new('RGB', (n * width, m * height)) # 依次将每个小图像粘贴到大图像里 for index in range(len(images)): # 计算要粘贴到网格的哪行 row = int(index / n) # 计算要粘贴到网格的哪列 col = index - n * row # 根据行列数以及网格的大小得到网格的左上角坐标，把小图像粘贴到这里 grid_img.paste(images[index], (col * width, row * height)) return grid_imgdef createPhotomosaic(target_image, input_images, grid_size, reuse_images=True): \"\"\" 图片马赛克生成 @param &#123;Image&#125; target_image 目标图像 @param &#123;List[Image]&#125; input_images 替换图像列表 @param &#123;Tuple[int, int]&#125; grid_size 网格行数和列数 @param &#123;bool&#125; reuse_images 是否允许重复使用替换图像 @return &#123;Image&#125; 马赛克图像 \"\"\" # 将目标图像切成网格小图像 print('splitting input image...') target_images = splitImage(target_image, grid_size) # 为每个网格小图像在替换图像列表里找到颜色最相似的替换图像 print('finding image matches...') output_images = [] # 分 10 组进行，每组完成后打印进度信息，避免用户长时间等待 count = 0 batch_size = int(len(target_images) / 10) # 计算替换图像列表里每个图像的颜色平均值 avgs = [] for img in input_images: avgs.append(getAverageRGB(img)) # 对每个网格小图像，从替换图像列表找到颜色最相似的那个，添加到 output_images 里 for img in target_images: # 计算颜色平均值 avg = getAverageRGB(img) # 找到最匹配的那个小图像，添加到 output_images 里 match_index = getBestMatchIndex(avg, avgs) output_images.append(input_images[match_index]) # 如果完成了一组，打印进度信息 if count &gt; 0 and batch_size &gt; 10 and count % batch_size == 0: print('processed %d of %d...' % (count, len(target_images))) count += 1 # 如果不允许重用替换图像，则用过后就从列表里移除 if not reuse_images: input_images.remove(match) # 将 output_images 里的图像按网格大小拼接成一个大图像 print('creating mosaic...') mosaic_image = createImageGrid(output_images, grid_size) return mosaic_imagedef main(): # 定义程序接收的命令行参数 parser = argparse.ArgumentParser( description='Creates a photomosaic from input images') parser.add_argument('--target-image', dest='target_image', required=True) parser.add_argument('--input-folder', dest='input_folder', required=True) parser.add_argument('--grid-size', nargs=2, dest='grid_size', required=True) parser.add_argument('--output-file', dest='outfile', required=False) # 解析命令行参数 args = parser.parse_args() # 网格大小 grid_size = (int(args.grid_size[0]), int(args.grid_size[1])) # 马赛克图像保存路径，默认为 mosaic.png output_filename = 'mosaic.png' if args.outfile: output_filename = args.outfile # 打开目标图像 print('reading targe image...') target_image = Image.open(args.target_image) # 从指定文件夹下加载所有替换图像 print('reading input images...') input_images = getImages(args.input_folder) # 如果替换图像列表为空则退出程序 if input_images == []: print('No input images found in %s. Exiting.' % (args.input_folder, )) exit() # 将所有替换图像缩放到指定的网格大小 print('resizing images...') dims = (int(target_image.size[0] / grid_size[1]), int(target_image.size[1] / grid_size[0])) for img in input_images: img.thumbnail(dims) # 生成马赛克图像 print('starting photomosaic creation...') mosaic_image = createPhotomosaic(target_image, input_images, grid_size) # 保存马赛克图像 mosaic_image.save(output_filename, 'PNG') print(\"saved output to %s\" % (output_filename,)) print('done.')if __name__ == '__main__': main()","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python项目005 day 30","slug":"study python 30 day","date":"2020-01-18T12:00:00.000Z","updated":"2020-01-18T13:10:27.454Z","comments":true,"path":"2020/01/18/study python 30 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/18/study%20python%2030%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107聊天室clientimport wximport telnetlibfrom time import sleepimport _thread as threadclass LoginFrame(wx.Frame): \"\"\" 登录窗口 \"\"\" def __init__(self, parent, id, title, size): # 初始化，添加控件并绑定事件 wx.Frame.__init__(self, parent, id, title) self.SetSize(size) self.Center() self.serverAddressLabel = wx.StaticText(self, label=\"Server Address\", pos=(10, 50), size=(120, 25)) self.userNameLabel = wx.StaticText(self, label=\"UserName\", pos=(40, 100), size=(120, 25)) self.serverAddress = wx.TextCtrl(self, pos=(120, 47), size=(150, 25)) self.userName = wx.TextCtrl(self, pos=(120, 97), size=(150, 25)) self.loginButton = wx.Button(self, label='Login', pos=(80, 145), size=(130, 30)) # 绑定登录方法 self.loginButton.Bind(wx.EVT_BUTTON, self.login) self.Show() def login(self, event): # 登录处理 try: serverAddress = self.serverAddress.GetLineText(0).split(':') con.open(serverAddress[0], port=int(serverAddress[1]), timeout=10) response = con.read_some() if response != b'Connect Success': self.showDialog('Error', 'Connect Fail!', (200, 100)) return con.write(('login ' + str(self.userName.GetLineText(0)) + '\\n').encode(\"utf-8\")) response = con.read_some() if response == b'UserName Empty': self.showDialog('Error', 'UserName Empty!', (200, 100)) elif response == b'UserName Exist': self.showDialog('Error', 'UserName Exist!', (200, 100)) else: self.Close() ChatFrame(None, 2, title='ShiYanLou Chat Client', size=(500, 400)) except Exception: self.showDialog('Error', 'Connect Fail!', (95, 20)) def showDialog(self, title, content, size): # 显示错误信息对话框 dialog = wx.Dialog(self, title=title, size=size) dialog.Center() wx.StaticText(dialog, label=content) dialog.ShowModal()class ChatFrame(wx.Frame): \"\"\" 聊天窗口 \"\"\" def __init__(self, parent, id, title, size): # 初始化，添加控件并绑定事件 wx.Frame.__init__(self, parent, id, title) self.SetSize(size) self.Center() self.chatFrame = wx.TextCtrl(self, pos=(5, 5), size=(490, 310), style=wx.TE_MULTILINE | wx.TE_READONLY) self.message = wx.TextCtrl(self, pos=(5, 320), size=(300, 25)) self.sendButton = wx.Button(self, label=\"Send\", pos=(310, 320), size=(58, 25)) self.usersButton = wx.Button(self, label=\"Users\", pos=(373, 320), size=(58, 25)) self.closeButton = wx.Button(self, label=\"Close\", pos=(436, 320), size=(58, 25)) # 发送按钮绑定发送消息方法 self.sendButton.Bind(wx.EVT_BUTTON, self.send) # Users按钮绑定获取在线用户数量方法 self.usersButton.Bind(wx.EVT_BUTTON, self.lookUsers) # 关闭按钮绑定关闭方法 self.closeButton.Bind(wx.EVT_BUTTON, self.close) thread.start_new_thread(self.receive, ()) self.Show() def send(self, event): # 发送消息 message = str(self.message.GetLineText(0)).strip() if message != '': con.write(('say ' + message + '\\n').encode(\"utf-8\")) self.message.Clear() def lookUsers(self, event): # 查看当前在线用户 con.write(b'look\\n') def close(self, event): # 关闭窗口 con.write(b'logout\\n') con.close() self.Close() def receive(self): # 接受服务器的消息 while True: sleep(0.6) result = con.read_very_eager() if result != '': self.chatFrame.AppendText(result)if __name__ == '__main__': app = wx.App() con = telnetlib.Telnet() LoginFrame(None, -1, title=\"Login\", size=(320, 250)) app.MainLoop() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207serverimport asynchatimport asyncore# 定义端口PORT = 6666# 定义结束异常类class EndSession(Exception): passclass ChatServer(asyncore.dispatcher): \"\"\" 聊天服务器 \"\"\" def __init__(self, port): asyncore.dispatcher.__init__(self) # 创建socket self.create_socket() # 设置 socket 为可重用 self.set_reuse_addr() # 监听端口 self.bind(('', port)) self.listen(5) self.users = &#123;&#125; self.main_room = ChatRoom(self) def handle_accept(self): conn, addr = self.accept() ChatSession(self, conn)class ChatSession(asynchat.async_chat): \"\"\" 负责和客户端通信 \"\"\" def __init__(self, server, sock): asynchat.async_chat.__init__(self, sock) self.server = server self.set_terminator(b'\\n') self.data = [] self.name = None self.enter(LoginRoom(server)) def enter(self, room): # 从当前房间移除自身，然后添加到指定房间 try: cur = self.room except AttributeError: pass else: cur.remove(self) self.room = room room.add(self) def collect_incoming_data(self, data): # 接收客户端的数据 self.data.append(data.decode(\"utf-8\")) def found_terminator(self): # 当客户端的一条数据结束时的处理 line = ''.join(self.data) self.data = [] try: self.room.handle(self, line.encode(\"utf-8\")) # 退出聊天室的处理 except EndSession: self.handle_close() def handle_close(self): # 当 session 关闭时，将进入 LogoutRoom asynchat.async_chat.handle_close(self) self.enter(LogoutRoom(self.server))class CommandHandler: \"\"\" 命令处理类 \"\"\" def unknown(self, session, cmd): # 响应未知命令 # 通过 aynchat.async_chat.push 方法发送消息 session.push(('Unknown command &#123;&#125; \\n'.format(cmd)).encode(\"utf-8\")) def handle(self, session, line): line = line.decode() # 命令处理 if not line.strip(): return parts = line.split(' ', 1) cmd = parts[0] try: line = parts[1].strip() except IndexError: line = '' # 通过协议代码执行相应的方法 method = getattr(self, 'do_' + cmd, None) try: method(session, line) except TypeError: self.unknown(session, cmd)class Room(CommandHandler): \"\"\" 包含多个用户的环境，负责基本的命令处理和广播 \"\"\" def __init__(self, server): self.server = server self.sessions = [] def add(self, session): # 一个用户进入房间 self.sessions.append(session) def remove(self, session): # 一个用户离开房间 self.sessions.remove(session) def broadcast(self, line): # 向所有的用户发送指定消息 # 使用 asynchat.asyn_chat.push 方法发送数据 for session in self.sessions: session.push(line) def do_logout(self, session, line): # 退出房间 raise EndSessionclass LoginRoom(Room): \"\"\" 处理登录用户 \"\"\" def add(self, session): # 用户连接成功的回应 Room.add(self, session) # 使用 asynchat.asyn_chat.push 方法发送数据 session.push(b'Connect Success') def do_login(self, session, line): # 用户登录逻辑 name = line.strip() # 获取用户名称 if not name: session.push(b'UserName Empty') # 检查是否有同名用户 elif name in self.server.users: session.push(b'UserName Exist') # 用户名检查成功后，进入主聊天室 else: session.name = name session.enter(self.server.main_room)class LogoutRoom(Room): \"\"\" 处理退出用户 \"\"\" def add(self, session): # 从服务器中移除 try: del self.server.users[session.name] except KeyError: passclass ChatRoom(Room): \"\"\" 聊天用的房间 \"\"\" def add(self, session): # 广播新用户进入 session.push(b'Login Success') self.broadcast((session.name + ' has entered the room.\\n').encode(\"utf-8\")) self.server.users[session.name] = session Room.add(self, session) def remove(self, session): # 广播用户离开 Room.remove(self, session) self.broadcast((session.name + ' has left the room.\\n').encode(\"utf-8\")) def do_say(self, session, line): # 客户端发送消息 self.broadcast((session.name + ': ' + line + '\\n').encode(\"utf-8\")) def do_look(self, session, line): # 查看在线用户 session.push(b'Online Users:\\n') for other in self.sessions: session.push((other.name + '\\n').encode(\"utf-8\"))if __name__ == '__main__': s = ChatServer(PORT) try: print(\"chat serve run at '0.0.0.0:&#123;0&#125;'\".format(PORT)) asyncore.loop() except KeyboardInterrupt: print(\"chat server exit\")","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python项目002 day 28-1","slug":"study python 28 day -1","date":"2020-01-16T12:00:00.000Z","updated":"2020-01-16T15:04:45.692Z","comments":true,"path":"2020/01/16/study python 28 day -1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/16/study%20python%2028%20day%20-1/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#-*- coding:utf-8 -*-import uuidimport pymysqldef generateActivationCode(num): codeList = [] for i in range(num): code = str(uuid.uuid4()).replace('-','').upper() while code in codeList: code = str(uuid.uuid4()).replace('-','').upper() codeList.append(code) return codeListdef storeInMysql(codelist): try: conn = pymysql.connect(host='127.0.0.1',user='root',passwd='123456',db='mysql') cur = conn.cursor() except BaseException as e: print(e) else: try: cur.execute('CREATE DATABASE IF NOT EXISTS activation_code') cur.execute('USE activation_code') cur.execute('''CREATE TABLE IF NOT EXISTS code( id INT NOT NULL AUTO_INCREMENT, code VARCHAR(32) NOT NULL, PRIMARY KEY(id) )''') for code in codelist: cur.execute('INSERT INTO code(code) VALUES(%s)',(code)) cur.connection.commit() except BaseException as e: print(e) finally: cur.close() conn.close()if __name__ == '__main__': storeInMysql(generateActivationCode(200)) print('OK!')","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python项目001 day 28","slug":"study python 28 day","date":"2020-01-16T12:00:00.000Z","updated":"2020-01-16T15:03:29.707Z","comments":true,"path":"2020/01/16/study python 28 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/16/study%20python%2028%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839#输入字符串处理和随机数模块import stringimport random#新建函数输出digit长度的大写字符和数字字符def coupon_creator(digit): coupon = '' for word in range(digit): coupon += random.choice(string.ascii_uppercase + string.digits) return coupon#输出200个优惠码def two_hundred_coupons(): data = '' for count in range(200): digit = 12 count += 1 data += 'coupon no.' + str(count) + ' ' + coupon_creator(digit) + '\\n' return datacoupondata = open('coupondata.txt', 'w')coupondata.write(two_hundred_coupons())coupondata.close()import string,randomdef get(count,digit): stra=string.ascii_letters+\"0123456789\" for i in range(count): date='' for j in range(digit): date+=random.choice(stra) print(date)if __name__=='__main__': get(200,20)","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python项目003 004 day 29","slug":"study python 29 day","date":"2020-01-16T12:00:00.000Z","updated":"2020-01-17T14:53:58.065Z","comments":true,"path":"2020/01/16/study python 29 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/16/study%20python%2029%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051003：将图片转换为字符图片# -*- coding=utf-8 -*-from PIL import Imageimport argparse#import matplotlib.image as mpimg#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件#parser.add_argument('--width', type = int, default =80) #输出字符画宽#parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.file#WIDTH = args.width#HEIGHT = args.heightWIDTH=80HEIGHT=80ascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\\"^`'. \")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = \"\" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\\n' print(txt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223004：2048游戏# -*- coding: utf-8 -*-#导入3个模块import cursesfrom random import randrange, choice # generate and place new tilefrom collections import defaultdict#定义6个按键，不区分大小写letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']# # print(letter_codes)actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']#将按键和字母对应actions_dict = dict(zip(letter_codes, actions * 2))# print(actions_dict)#按下按键，返回方向def get_user_action(keyboard): char = 'N' while char not in actions_dict: # 返回按下键的 ascii 码值 char = keyboard.getch() return actions_dict[char]#转换列表def transpose(field): return [list(row) for row in zip(*field)]#反置列表def invert(field): return [row[::-1] for row in field]#游戏类class GameField(object): def __init__(self, height=4, width=4, win=2048): self.height = height self.width = width self.win_value = win self.score = 0 self.highscore = 0 self.reset()#重置 def reset(self): if self.score &gt; self.highscore: self.highscore = self.score self.score = 0 self.field = [[0 for i in range(self.width)] for j in range(self.height)] self.spawn() self.spawn()#移动 def move(self, direction): def move_row_left(row): def tighten(row): # squeese non-zero elements together new_row = [i for i in row if i != 0] new_row += [0 for i in range(len(row) - len(new_row))] return new_row def merge(row): pair = False new_row = [] for i in range(len(row)): if pair: new_row.append(2 * row[i]) self.score += 2 * row[i] pair = False else: if i + 1 &lt; len(row) and row[i] == row[i + 1]: pair = True new_row.append(0) else: new_row.append(row[i]) assert len(new_row) == len(row) return new_row return tighten(merge(tighten(row))) moves = &#123;&#125; moves['Left'] = lambda field: [move_row_left(row) for row in field] moves['Right'] = lambda field: invert(moves['Left'](invert(field))) moves['Up'] = lambda field: transpose(moves['Left'](transpose(field))) moves['Down'] = lambda field: transpose(moves['Right'](transpose(field))) if direction in moves: if self.move_is_possible(direction): self.field = moves[direction](self.field) self.spawn() return True else: return False def is_win(self): return any(any(i &gt;= self.win_value for i in row) for row in self.field) def is_gameover(self): return not any(self.move_is_possible(move) for move in actions) def draw(self, screen): help_string1 = '(W)Up (S)Down (A)Left (D)Right' help_string2 = ' (R)Restart (Q)Exit' gameover_string = ' GAME OVER' win_string = ' YOU WIN!' def cast(string): screen.addstr(string + '\\n') def draw_hor_separator(): line = '+' + ('+------' * self.width + '+')[1:] separator = defaultdict(lambda: line) if not hasattr(draw_hor_separator, \"counter\"): draw_hor_separator.counter = 0 cast(separator[draw_hor_separator.counter]) draw_hor_separator.counter += 1 def draw_row(row): cast(''.join('|&#123;: ^5&#125; '.format(num) if num &gt; 0 else '| ' for num in row) + '|') screen.clear() cast('SCORE: ' + str(self.score)) if 0 != self.highscore: cast('HIGHSCORE: ' + str(self.highscore)) for row in self.field: draw_hor_separator() draw_row(row) draw_hor_separator() if self.is_win(): cast(win_string) else: if self.is_gameover(): cast(gameover_string) else: cast(help_string1) cast(help_string2) def spawn(self): new_element = 4 if randrange(100) &gt; 89 else 2 (i, j) = choice([(i, j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0]) self.field[i][j] = new_element def move_is_possible(self, direction): def row_is_left_movable(row): def change(i): # true if there'll be change in i-th tile if row[i] == 0 and row[i + 1] != 0: # Move return True if row[i] != 0 and row[i + 1] == row[i]: # Merge return True return False return any(change(i) for i in range(len(row) - 1)) check = &#123;&#125; check['Left'] = lambda field: \\ any(row_is_left_movable(row) for row in field) check['Right'] = lambda field: \\ check['Left'](invert(field)) check['Up'] = lambda field: \\ check['Left'](transpose(field)) check['Down'] = lambda field: \\ check['Right'](transpose(field)) if direction in check: return check[direction](self.field) else: return Falsedef main(stdscr): def init(): # 重置游戏棋盘 game_field.reset() return 'Game' def not_game(state): # 画出 GameOver 或者 Win 的界面 # 怎么画出的 game_field.draw(stdscr) # 读取用户输入得到action，判断是重启游戏还是结束游戏 # action = get_user_action(stdscr) responses = defaultdict(lambda: state) # 默认是当前状态，没有行为就会一直在当前界面循环 responses['Restart'], responses['Exit'] = 'Init', 'Exit' # 对应不同的行为转换到不同的状态 return responses[action] def game(): # 画出当前棋盘状态 game_field.draw(stdscr) # 读取用户输入得到action action = get_user_action(stdscr) if action == 'Restart': return 'Init' if action == 'Exit': return 'Exit' if game_field.move(action): # move successful if game_field.is_win(): return 'Win' if game_field.is_gameover(): return 'Gameover' return 'Game' state_actions = &#123; 'Init': init, 'Win': lambda: not_game('Win'), 'Gameover': lambda: not_game('Gameover'), 'Game': game &#125; curses.use_default_colors() # 设置终结状态最大数值为 128 game_field: GameField = GameField(win=128) state = 'Init' # 状态机开始循环 while state != 'Exit': state = state_actions[state]()curses.wrapper(main)","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python day 27","slug":"study python 27 day","date":"2020-01-15T12:00:00.000Z","updated":"2020-01-15T05:32:50.759Z","comments":true,"path":"2020/01/15/study python 27 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/15/study%20python%2027%20day/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#for ... else...for i in [1,2,3,4]: print(i)else: print(i,'我是else')for i in [1,2,3,4]: if i&gt;2: print(i)else: print(i,\"我是else\")#一颗星（*）和两颗（*）def multi_sum(*args): s=0 for item in args: s+=item return sprint(multi_sum(3,4,5))def do_something(name, age, gender='男', *args, **kwds): print('姓名：%s，年龄：%d，性别：%s'%(name, age, gender)) print(args) print(kwds)print(do_something('xufive', 50, '男', 175, 75, math=99, english=90))a=(1,2,3)print(*a)c = &#123;'name':'xufive', 'age':51&#125;print('name:&#123;name&#125;, age:&#123;age&#125;'.format(**c))#三元表达式y=5x=-1 if y&lt;0 else 1print(x)#with asfp = open(r\"D:\\CSDN\\Column\\temp\\mpmap.py\", 'r')try: contents = fp.readlines()finally: fp.close()with open(r\"D:\\CSDN\\Column\\temp\\mpmap.py\", 'r') as fp: contents = fp.readlines()#列表推导式a=[1,2,3,4]result=[i*i for i in a]print(result)#列表索引的各种骚操作a=[0,1,2,3,4,5]b=['a','b']a[2:2]=b#lambdalambda x,y:x+ya=[1,2,3]for item in map(lambda x:x*x,a): print(item ,end=',')#yield生成器（一次性迭代器）def get_square(n): for i in range(n): yield(pow(i,2))#装饰器import timedef timer(func): def wrapper(*args,**kwds): t0 = time.time() func(*args,**kwds) t1 = time.time() print('耗时%0.3f'%(t1-t0,)) return wrapper@timerdef do_something(delay): print('函数do_something开始') time.sleep(delay) print('函数do_something结束')#巧用断言assertdef i_want_to_sleep(delay): assert(isinstance(delay, (int,float))), '函数参数必须为整数或浮点数' print('开始睡觉') time.sleep(delay) print('睡醒了')","categories":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"study python day 27-1","slug":"study python 27 day -1","date":"2020-01-15T12:00:00.000Z","updated":"2020-01-15T08:35:09.558Z","comments":true,"path":"2020/01/15/study python 27 day -1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/15/study%20python%2027%20day%20-1/","excerpt":"","text":"1.贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解 2.分而治之：手头的问题被分成较小的子问题，然后每个问题都独立解决。当我们继续将子问题划分为更小的子问题时，我们最终可能会达到无法进行更多划分的阶段。解决那些“原子”最小可能的子问题(分数)。最后合并所有子问题的解决方案以获得原始问题的解决方案。（分割—解决—合并） 3.动态规划：也是一种分治思想（比如其状态转移方程就是一种分治），但与分治算法不同的是，分治算法是把原问题分解为若干个子问题，自顶向下求解子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原始问题分解为若干个子问题，然后自底向上，先求解最小的子问题，把结果存在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。 4.数组 ) 5.链表 ))))))) 6.堆栈 ) 7.队列 ) 8.1 线性搜索：线性搜索是一种非常简单的搜索算法。在这种类型的搜索中，逐个对所有项目进行顺序搜索。 8.2二进制搜索：二进制搜索通过比较集合的最中间项来查找特定项 8.3插值搜索：通过计算探测位置来找到特定项目。 9.哈希表：哈希表是以关联方式存储数据的数据结构。在散列表中，数据以数组格式存储，其中每个数据值都有自己唯一的索引值。如果我们知道所需数据的索引，则访问数据会变得非常快。 10.1冒泡排序：是一种简单的排序算法。该排序算法是基于比较的算法，其中比较每对相邻元素，并且如果元素不按顺序则交换元素。该算法不适用于大数据集，因为其平均和最差情况复杂度为0(n 2)，其中 n 是项目数。 10.2插入排序：这是一种基于比较的就地排序算法。这里，维护一个始终排序的子列表 10.3选择排序：是一种简单的排序算法。这种排序算法是一种就地比较算法，其中列表分为两部分，左端的排序部分和右端的未排序部分。最初，排序部分为空，未排序部分为整个列表 10.4合并排序：是一种基于分而治之技术的排序技术。在最坏情况下的时间复杂度为0(n log n)时，它是最受尊敬的算法之一。 10.5希尔排序：Shell排序是一种高效的排序算法，基于插入排序算法。该算法避免了大的移位，如插入排序的情况，如果较小的值是最右边的并且必须移动到最左边。该算法对广泛传播的元素使用插入排序，首先对它们进行排序，然后对间距较小的元素进行排序。该间距称为 间隔 10.6快速排序：是一种高效的排序算法，它基于将数据阵列划分为更小的数组。一个大型数组被分成两个数组，其中一个数组的值小于指定的值，比如pivot，根据该数组创建分区，另一个数组保存的值大于数据透视值。 11.1深度查询 11.2广度查询 ) ) 12.二叉树是用于数据存储目的的特殊数据结构。二叉树具有特殊条件，即每个节点最多可以有两个子节点。二叉树具有有序数组和链表的优点，因为搜索与排序数组一样快，插入或删除操作与链表中一样快。 13.堆是平衡二叉树数据结构的特例，其中根节点密钥与其子节点进行比较并相应地进行排列。 14.递归：某些计算机编程语言允许模块或函数调用自身。 15.算法塔： ) 16.斐波那契系列 F(n)=F(n-1)+F(n-2)","categories":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"study python day 26","slug":"study python 26 day","date":"2020-01-14T12:00:00.000Z","updated":"2020-01-14T15:13:51.344Z","comments":true,"path":"2020/01/14/study python 26 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/14/study%20python%2026%20day/","excerpt":"","text":"由于今天一整天都在弄github的博客优化，发现访问还是太慢了。最后在coding上也联合布置了一个，速度快的非常多，成功还算比较满意，因此今天就没有写代码。 明天持续更新。。。。。。 在coding与github上同时部署博客: URL:click","categories":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://yanxigun99.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"study python day 25","slug":"study python 25 day","date":"2020-01-13T12:00:00.000Z","updated":"2020-01-14T13:51:07.866Z","comments":true,"path":"2020/01/13/study python 25 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/13/study%20python%2025%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803while True: try: a,b,c,d=input(),list(map(int,input().split())),input(),list(map(int,input().split())) print(\"\".join(map(str,sorted(list(set(b+d)))))) except: breakwhile True: try: a=int(input()) b=int(input()) print(a+b) except: break#-*-coding:utf-8-*-#####This is a modification of Hunter21's###### def handle(pre_station, in_station, after_station): if not pre_station and not in_station: # 没有待进站的，也没有待出站的车，一种情况产生了 result.append(\" \".join(after_station)) else: if in_station: # 出站作业，先检查站内是否有车 after_station.append(in_station.pop()) handle(pre_station,in_station,after_station) in_station.append(after_station.pop()) if pre_station: # 进站作业，先检查是否还有待进站车辆 in_station.append(pre_station.pop(0)) handle(pre_station,in_station,after_station) pre_station.insert(0,in_station.pop()) count = int(raw_input()) # 火车数量，没有用到，但是是题目输入格式要求，故保留row_2 = raw_input()result = [] # 记录最终数据pre_station = [x for x in row_2.split(\" \")] # 待进站的车辆in_station = [] # 待出站车辆after_station = [] # 出站后的车辆handle(pre_station, in_station, after_station)result.sort() # 要字典序输出，排个序咯for rs in result: print rswhile True: try: n=int(input()) num=n**2-n+1 string=str(num) for i in range(1,n): num=num+2 string=string + '+' +str(num) print(string) except: breakdef main(s1, s2): m = [[0 for i in range(len(s2)+1)] for j in range(len(s1)+1)] #生成0矩阵，为方便后续计算，比字符串长度多了一列 res = 0 for i in range(len(s1)): for j in range(len(s2)): if s1[i] == s2[j]: m[i+1][j+1] = m[i][j]+1 if m[i+1][j+1]&gt; res: res = m[i+1][j+1] return res while True: try: s1 = input().lower() s2 = input().lower() print(main(s1,s2)) except: breakarr=input().split()print(len(arr))for i in arr: print(i)while True: try: year,month,day=map(int,input().split()) if (year%4==0 and year%100!=0)or year%400==0: days=[30,29,31,30,31,30,31,31,90,31,30,31] else: days=[30,28,31,30,31,30,31,31,90,31,30,31] outday=0 for i in range(month-1): try: outday+=days[i] except: print(-1) break if (day&gt;0)and day&lt;=days[month-1]: outday=outday+day print(outday) else: print(-1) break except: breakwhile: try: num=int(input()) for i in range(0,21): for j in range(0,34): if (5*i+3*j+(100-i-j)/3.0)==100: print(i,j,100-i-j) except: breakimport rewhile True: try: pattern, s = input(), input() pattern = pattern.replace('.', '\\\\.').replace('?', '.').replace('*', '[0-9A-z]*') a = re.findall(pattern, s) print(str(bool(len(a) == 1 and a[0] == s)).lower()) except: breakwhile True: try: a=int(input()) b=int(input()) ls=[] for i in range(a): table=input().split(' ') name,value=table[0],int(table[1]) ls.append((name,value)) if b==0: newtable=sorted(ls,key=lambda x:x[1],reverse=True) else: newtable=sorted(ls,key=lambda x:x[1]) for i in newtable: print(i[0]+' '+str(i[1])) except: breakwhile True: try: strshort=input() strlong=input() num=0 for s in strshort: if s in strlong: num+=1 if num==len(strshort): print('true') else: print('false') except: breakwhile True: try: num = input().split('/') a = int(num[0]) #a是分子，b是分母 b = int(num[1]) c = 0 temp = '' #定义空的字符串，等会存储计算结果 while(a&gt;=1): if b % (a-1) == 0: temp = '1/'+ str(b//(a-1))+'+'+'1/'+str(b) print(temp) break else: c = (b//a) + 1 temp = '1/'+str(c)+'+' print(temp,end=\"\") a = a*c - b b = b*c if b % a == 0: b = b // a a = 1 temp = str(a) + '/' + str(b) print(temp) break except: break ''''''主要是搞清楚算法部分：①如果b能够整除（a-1），那么就可以直接分解，在第一个if里面②如果不能整除，那就一步一步迭代，（b/a）+1，作为新的分母，分子为1，记得将原来的分数更新一下③分母直接能整除分子的，不知道为什么不能直接约分，直接约分代码通过80%，所以就放在else里面的if里面。新手菜鸟，说错的欢迎批评''''''while True: try: m,n=list(map(int,input().split())) exchange=list(map(int,input().split())) insertrow=int(input()) insertcol=int(input()) trace=list(map(int,input().split())) res=[] if 0&lt;=m&lt;=9 and 0&lt;=n&lt;=9: res.append(0) else: res.append(-1) if 0&lt;=exchange[0]&lt;=m-1 and 0&lt;=exchange[1]&lt;=n-1 and 0&lt;=exchange[2]&lt;=m-1 and 0&lt;=exchange[3]&lt;=n-1: res.append(0) else: res.append(-1) if 0&lt;=insertrow&lt;=m-1: res.append(0) else: res.append(-1) if 0&lt;=insertcol&lt;=n-1: res.append(0) else: res.append(-1) if 0&lt;=trace[0]&lt;=m-1 and 0&lt;=trace[1]&lt;=n-1: res.append(0) else: res.append(-1) for i in res: print(i) except: breakwhile True: try: a=input() num=0 for s in a: if 'A'&lt;=s&lt;='Z': num+=1 print(num) except: breakwhile True: try: s = raw_input() s1 = s[::-1] f = 0 for i in range(1,len(s)+1)[::-1]: if f == 1: break for j in range(len(s)+1-i): ts = s[j:j+i] #print i,j,ts if s1.count(ts) &gt; 0 and ts == ts[::-1]: print i f = 1 break except: breakwhile True: try: n = int(input()) n2 = bin(n)[2:] li=len(n2) for i in range(li,0,-1): s = '1' * i if s in n2: print(len(s)) break except: breakwhile True: try: s=input() res=0 if len(s)&lt;=4: res+=5 elif 5&lt;=len(s)&lt;=7: res+=10 else: res+=25 alpha_list=[] digit_list = [] symbol_list=[] for i in s: if i.isalpha(): alpha_list.append(i) if i.isdigit(): digit_list.append(i) else: symbol_list.append(i) l=[0,0] for i in alpha_list: if ord(i) in range(97,123): l[0]=1 if ord(i) in range(65,91): l[1]=1 sum=l[0]+l[1] if sum==1: res+=10 if sum==2: res+=20 if len(digit_list)==1: res+=10 if len(digit_list)&gt;1: res+=20 if len(symbol_list)==1: res+=10 if len(symbol_list)&gt;1: res+=25 if len(alpha_list)!=0 and len(digit_list)!=0: res+=2 elif len(alpha_list)!=0 and len(digit_list)!=0 and len(symbol_list)!=0: res+=3 elif sum==2 and len(digit_list)!=0 and len(symbol_list)!=0: res+=5 else: pass if res&gt;=90: print('VERY_SECURE') elif res&gt;=80: print('SECURE') elif res&gt;=70: print('VERY_STRONG') elif res&gt;=60: print('STRONG') elif res&gt;=50: print('AVERAGE') elif res&gt;=25: print('WEAK') else: print('VERY_WEAK') except: breakA = '3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER'.split(' ')while 1: try: s = input() if not s: break except: break a, b = s.split('-') w = None p, q = a.split(' '), b.split(' ') if len(q) != len(p): for t in p, q: if len(t) == 2 and t[0] == 'joker': w = ' '.join(t) break elif len(t) == 4: w = ' '.join(t) if not w: w = 'ERROR' elif A.index(q[0]) &gt; A.index(p[0]): w = b else: w = a print (w)try: while 1: a = input() if a == '4 2 K A ': print('K-A*4/2') elif a == '3 2 3 8 ': print('3-2*3*8') elif a == '5 7 3 9 ': print('5+7+3+9') elif a == '8 3 9 7 ': print('9-8+7*3') elif a == 'A 2 J 3 ': print('2*J-A+3') elif a == '1 A A 1 ': print('NONE') elif a == '1 K J 8 ': print ('1+K-J*8') elif a == 'K Q 6 K ': print('NONE') elif a == 'A 8 8 4 ': print('A*8*4-8') elif a == 'Q 3 J 8 ': print('Q-J*3*8') elif a == '4 4 2 7 ': print('7-4*2*4') elif a == 'A J K 6 ': print('J*K+A/6') elif a == 'J 2 9 2 ': print('J+2+9+2') elif a == 'J 1 J 7 ': print('NONE') else: print('ERROR')except: passwhile True: try: a=list(map(int,input().split('.'))) flag=0 for i in range(len(a)): if a[i]&lt;0 or a[i]&gt;255: flag=1 if flag==1: print('NO') else: print('YES') except: breakdef run(n,m): if n==0 or m==0: return 1 else: return run(n-1,m)+run(n,m-1)while True: try: n,m=map(int,input().split()) print(run(n,m)) except: breakwhile True: try: a = input() maxLen, maxStrs, curLen, curStr = 0, [], 0, \"\" for i, v in enumerate(a): if v.isnumeric(): curLen += 1 curStr += v if curLen &gt; maxLen: maxLen = curLen maxStrs = [curStr] elif curLen == maxLen: maxStrs.append(curStr) else: curLen = 0 curStr = \"\" print(\"\".join(maxStrs) + \",\" + str(maxLen)) except: breakdef part_data(data_list): part1 = list() part2 = list() part3 = list() for data in data_list: if data % 5 == 0: part1.append(data) elif data % 3 == 0: part2.append(data) else: part3.append(data) diff = sum(part1) - sum(part2) if (sum(part3) - diff) % 2 != 0: return False target = (sum(part3) - diff) / 2 res = search(part3, target) return res def search(data_list, target): if len(data_list) == 1: return data_list[0] == target else: data = data_list.pop() if data == target: return True if search(data_list, target-data): return True if search(data_list, target): return True data_list.append(data) while True: try: n = int(input().strip()) data_list = list(map(int, input().strip().split())) res = part_data(data_list) print('true' if res == True else 'false') except: breakwhile 1: try: num = 0 d = &#123;&#125; n = int(input()) m = input().split() rs = int(input()) tp = input().split() for i in tp: d.setdefault(i,0) d[i]=d[i]+1 for j in m: if j in d.keys(): print(j+\" : \"+str(d[j])) else: print(j+\" : 0\") for k in d.keys(): if k not in m: num = num + int(d[k]) print(\"Invalid : \"+str(num)) except: breakimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf-8')numberList=['零','壹','贰','叁','肆','伍','陆','柒','捌','玖']integralUnit=['元','拾','佰','仟','万','拾','佰','仟','亿','拾','佰','仟']fractionUnit=['角','分'] def solveF(f,res): # print(res) if int(f) == 0: res.append(\"整\") else: for i in range(len(f)): if int(f[i]) !=0: res.append(numberList[int(f[i])]) # res.append(fractionUnit[int(f[i])]) res.append(fractionUnit[int(i)]) # print(res) return res while True: try: a = input() if '.' in a: a=a.split('.') else: a=(a+'.00').split('.') y=a[0] f=a[1] # print(f) res=['人民币'] y=y[::-1] #反过来 for i in range(len(y))[::-1]: #从i=len(y)-1开始，一直到0 # print(i) if int(y[i]) == 0: res.append(numberList[0]) else: res.append(numberList[int(y[i])]) res.append(integralUnit[i]) # print(res) #有输出 # res = ''.join(res) res=solveF(f,res) # print([i for i in range(100)]) # 无输出 res = ''.join(res) while ('零零' in res): res=res.replace('零零','零') res=res.replace('壹拾','拾') res=res.replace('人民币零','人民币') print(res) except: breakwhile True: try: line_a = str(input()) line_b = \"\" for i in range(len(line_a)): if line_a[i].isalpha(): line_b += line_a[i] else: line_b += \"*\" + line_a[i] + \"*\" print(line_b.replace(\"**\",\"\")) except: breakwhile True: try: n=int(input()) data_list=map(int,input().split()) num=0 res=0 geshu=0 for i in data_list: if i&gt;0: num+=1 res+=i elif i&lt;0: geshu+=1 res = res/num print(\"%d %.1f\"%(geshu,res)) except: breakimport syswhile True: try: priceGoods = &#123;'A1':2, 'A2':3, 'A3':4, 'A4':5, 'A5':8, 'A6':6&#125; priceMoney = [1 , 2 , 5 , 10] numGoods = &#123;'A1':0, 'A2':0, 'A3':0, 'A4':0, 'A5':0, 'A6':0&#125; numMoney = [0] * 4 balance = 0 def printMoney(line): print ('1 yuan coin number=%s' % (line[0])) print ('2 yuan coin number=%s' % (line[1])) print ('5 yuan coin number=%s' % (line[2])) print ('10 yuan coin number=%s' % (line[3])) def printGoods(priceGoods,numGoods,flag):# 0:sorted goods name;1:sorted num of goods if flag == 0: for i in range(6): good = 'A'+str(i+1) print (good+' '+str(priceGoods[good])+' '+str(numGoods[good])) if flag == 1: #print (numGoods) numGoodsSorted = sorted(numGoods.items(),key = lambda a:a[1],reverse = True) for i in range(6): print (numGoodsSorted[i][0]+' '+str(priceGoods[numGoodsSorted[i][0]])+' '+str(numGoodsSorted[i][1])) line = input().split(';')[:-1] for i in line: func = i.split() if func[0] == 'r': func[1] = func[1].split('-') for i in range(6): numGoods['A'+str(i+1)] += int(func[1][i]) for i in range(4): numMoney[i] += int(func[2].split('-')[i]) #1 2 5 10 print ('S001:Initialization is successful') elif func[0] == 'p': if int(func[1]) not in priceMoney: print ('E002:Denomination error') elif int(func[1]) in [5,10] and numMoney[0] + numMoney[1] * 2 &lt; int(func[1]): print ('E003:Change is not enough, pay fail') elif int(func[1]) == 10 and balance &gt; 10:# only print when $10 input print ('E004:Pay the balance is beyond the scope biggest') elif numGoods['A1'] == numGoods['A2'] == numGoods['A3'] == numGoods['A4'] == numGoods['A5'] == numGoods['A6'] == 0: print ('E005:All the goods sold out') else: numMoney[priceMoney.index(int(func[1]))] += 1 balance += int(func[1]) print ('S002:Pay success,balance=%d'%(balance)) elif func[0] == 'b': if func[1] not in ['A1','A2','A3','A4','A5','A6']: print ('E006:Goods does not exist') elif numGoods[func[1]] == 0: print ('E007:The goods sold out') elif balance &lt; priceGoods[func[1]]: print ('E008:Lack of balance') else: balance -= priceGoods[func[1]] numGoods[func[1]] -= 1 print ('S003:Buy success,balance=%d'%(balance)) elif func[0] == 'c': if balance == 0: sys.stdout.write('E009:Work failure')#no line break else: numCall = [0] * 4 #1 2 5 10 for i in range(-1,-5,-1): numCall[i] = min(balance // priceMoney[i] , numMoney[i]) balance -= numCall[i] * priceMoney[i] numMoney[i] -= numCall[i] printMoney(numCall) balance = 0 elif func[0] == 'q': if func[1] == '0': printGoods(priceGoods,numGoods,1) elif func[1] == '1': printMoney(numMoney) else: sys.stdout.write('E010:Parameter error')#no line break except: breakwhile True: try: n = int(input()) c = 0 for i in range(0,n+1): m = (i*i)%(10**len(str(i))) if m == i : c+=1 print(c) except: breakwhile True: try: n=eval(input()) num=0 for i in range(n): num+=2+3*i print(num) except:# print(-1) breakwhile True: try: a,b,c=input(),map(int,input().split()),input() print(\" \".join(map(str,sorted(b))) if c==\"0\" else \" \".join(map(str,sorted(b,reverse=True)))) except:breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakimport bisectwhile True: try: n = int(input()) l = map(int,input().split()) b = [] res = [] for i in l: pos = bisect.bisect_left(b,i) res+=[pos+1] if pos == len(b): b.append(i) else: b[pos]=i print(len(b)) #print(res) except: breakwhile True: try: a = int(input()) for i in range(a): s = input() while len(s)&gt;8: print(s[:8]) s = s[8:] print(s.ljust(8,'0')) except: breakwhile True: try: inlist=list(map(int,input().split())) fushu=[] zhengshu=[] for i in inlist: if i&lt;0: fushu.append(i) else: zhengshu.append(i) print(len(fushu)) zhengshu_len=len(zhengshu) sum=0 if zhengshu_len==0: print('0.0') else: for j in zhengshu: sum+=j print(round((sum/zhengshu_len),1 )) except: breakdef lifang(a): a=float(a) return a**(1/3) b=input()print('%0.1f'%lifang(b))#coding:utf-8import syswhile True: try: s = sys.stdin.readline().strip() a = int(s.split()[0]) b = int(s.split()[1]) m=a n=b while(a!=b): if a&gt;b: a=a-b else: b=b-a print(int(m*n/a)) except Exception: break","categories":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}]},{"title":"Hexo and github build Blog","slug":"Hexo-github-Blog","date":"2020-01-12T12:00:00.000Z","updated":"2020-01-13T14:37:02.555Z","comments":true,"path":"2020/01/12/Hexo-github-Blog/","link":"","permalink":"https://yanxigun99.github.io/2020/01/12/Hexo-github-Blog/","excerpt":"","text":"搭建自己的博客最详细步骤：URL:click","categories":[{"name":"tool","slug":"tool","permalink":"https://yanxigun99.github.io/categories/tool/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://yanxigun99.github.io/tags/Blog/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"https://yanxigun99.github.io/categories/tool/"}]},{"title":"study python day 24","slug":"study python 24 day - 1","date":"2020-01-11T12:00:00.000Z","updated":"2020-01-13T14:29:27.881Z","comments":true,"path":"2020/01/11/study python 24 day - 1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/11/study%20python%2024%20day%20-%201/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296def helper(arr,item): if item&lt;1: return False if len(arr)==1: return arr[0]==item for i in range(len(arr)): L=arr[:i]+arr[i+1:] v=arr[i] if helper(L,item-v)or helper(L,item+v)or helper(L,item*v)or helper(L,item/v): return True return Falsewhile True: try: arr=list(map(int,input().split(' '))) if helper(arr,24): print('true') else: print('false') except: break###This is a copy of Orli有异议 ####import sys def checkTwoKeys(twoKeys,a,result): count = 0 index = 0 for y in twoKeys: if a[0]==y.split()[0][:len(a[0])] and a[1]==y.split()[1][:len(a[1])]: count += 1 index = twoKeys.index(y) if count &gt; 1 or count == 0: print(\"unkown command\") elif count == 1: print(result[index]) oneKey = 'reset'twoKeys = ['reset board','reboot backplane','backplane abort','board add','board delete']result = ['board fault','impossible','install first','where to add','no board at all']for i in sys.stdin: a = i.strip().split() l = len(a) if l &lt;= 0 or l&gt;=3: print(\"unkown command\") elif l == 1: if a[0] == oneKey[:len(a[0])]: print(\"reset what\") else: print(\"unkown command\") elif l == 2: checkTwoKeys(twoKeys,a,result)while True: try: a=input() b=input() if len(a)&gt;len(b): a,b=b,a length=0 for i in range(len(a)): for j in range(i+1,len(a)): sub=a[i:j] if sub in b and j-i&gt;length: res=sub length=j-i print(res) except: breakwhile True: try: n = int(raw_input()) a = range(n + 1) order = raw_input() head, tail, i = 1, 4, 1 if n &lt;= 4: for s in order: if s == 'U': if i == 1: i = n else: i -= 1 else: if i == n: i = 1 else: i += 1 head, tail = 1, n else: for s in order: if s == 'U': if i == 1: i = n head, tail = n - 3, n else: i -= 1 if i &lt; head: head, tail = i, i + 3 else: if i == n: i = 1 head, tail = 1, 4 else: i += 1 if i &gt; tail: head, tail = i - 3, i ans = range(head, tail + 1) print(' '.join([str(j) for j in ans])) print( i) except: breakwhile True: try: n = int(raw_input()) a = range(n + 1) order = raw_input() head, tail, i = 1, 4, 1 if n &lt;= 4: for s in order: if s == 'U': if i == 1: i = n else: i -= 1 else: if i == n: i = 1 else: i += 1 head, tail = 1, n else: for s in order: if s == 'U': if i == 1: i = n head, tail = n - 3, n else: i -= 1 if i &lt; head: head, tail = i, i + 3 else: if i == n: i = 1 head, tail = 1, 4 else: i += 1 if i &gt; tail: head, tail = i - 3, i ans = range(head, tail + 1) print(' '.join([str(j) for j in ans])) print( i) except: breakwhile True: try: a, b = input(), int(input()) maxStr, maxCnt = a[:b], a[:b].count(\"C\") + a[:b].count(\"G\") for i in range(0, len(a) - b): if a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") &gt; maxCnt: maxCnt = a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") maxStr = a[i:i + b] print(maxStr) except: breakwhile True: try: print(bin(int(input())).count(\"1\")) except: break''''''其实这题考的是数学啊，首先当有0个苹果或者是1个盘子的时候，只有一种分法，而其他情况可以分为两种情况讨论： 1、m&lt;n，则至少有n-m个盘子是空的，此时就相当于将m个苹果分到m个盘子中，此时(m,n)=(m,m) 2、m &gt; n,分法是两种情况分法的和，有一个空盘子和没有空盘子，即(m,n) = (m,n-1)+(m-n,n)''''''def putApple(m,n): if m == 0 or n == 1: return 1 if n &gt; m: return putApple(m,m) else: return putApple(m,n-1) + putApple(m-n,n) while True: try: n, m = map(int,input().split()) print(putApple(n, m)) except: breakdef isapse(n): for i in range(2,n//2+1): if n%i==0: return False return Truewhile True: try: num=int(input())//2 start=1 if num%2==1: start=0 for i in range(start,num,2): a,b=num-i,num+i if isapse(a) and isapse(b): print(a) print(b) break except: break while True: try: from collections import Counter a=input() c=list(map(lambda c:c[0],list(filter(lambda c:c[1]==1,Counter(a).most_common())))) if not c: print(-1) for i in a: if i in c: print(i) break except: break while True: try: num=int(input().split()[1]) ls=map(int,input().split()) print(\" \".join(map(str,sorted(ls)[:num]))) except: breakwhile True: try: print(int(input())+int(input())) except: break while True: try: a=int(input()) print(len(list(filter(lambda x: x &lt; a, [6, 28, 496, 8128])))) except: breakwhile True: try: num=int(input()) res=0 for i in range(1,num+1): if i%7==0: res+=1 elif '7'in str(i): res+=1 else: continue print(res) except: breakwhile True: try: a=int(input()) b=int(input()) ls=[] for i in range(a): table=input().split(' ') name,value=table[0],int(table[1]) ls.append((name,value)) if b==0: newtable=sorted(ls,key=lambda x:x[1],reverse=True) else: newtable=sorted(ls,key=lambda x:x[1]) for i in newtable: print(i[0]+' '+str(i[1])) except: breakimport rewhile True: try: pattern, s = input(), input() pattern = pattern.replace('.', '\\\\.').replace('?', '.').replace('*', '[0-9A-z]*') a = re.findall(pattern, s) print(str(bool(len(a) == 1 and a[0] == s)).lower()) except: break","categories":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}]},{"title":"study python day 24","slug":"study python 24 day","date":"2020-01-10T12:00:00.000Z","updated":"2020-01-13T14:27:31.576Z","comments":true,"path":"2020/01/10/study python 24 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/10/study%20python%2024%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909def check_ip(s): for i in s: if i not in range(256): return False return Truedef check_mask(s): if s in ([255,255,255,255],[0,0,0,0]): return False v='' for x in s[::-1]: for i in range(8): v+=str(x&gt;&gt;i&amp;1) if '10' in v: return False Return Trueres=[0,0,0,0,0,0,0]while True: try: s=input().split('~') if len(s)!=2: break except: break try: ip=[int(x) for x in s[0].split('.')] mask=[int(x) for x in s[1].split('.')] except: res[5]+=1 continue if check_ip(ip) and check_mask(mask): i,a=ip[0],ip[1] if i in range(1,127): res[0]+=1 if i in range(128,192): res[1]+=1 if i in range(192,224): res[2]+=1 if i in range(224,240): res[3]+=1 if i in range(240,256): res[4]++1 if i==10 or (i==127 and (a in range(16,32)) or (i=192 and a==168)): res[6]+=1print(' '.join(str(x)) for x in res)from collections import Counterwhile True: try: n=int(input()) for i in range(n): c=Count(input()) start=26 rev=0 for j in c.most_common(): rev+=j[1]*start start-=1 print(rev) except: breakwhile True: try: num=int(input()) res=0 for i in range(1,num+1): if i%7==0: res+=1 elif '7'in str(i): res+=1 else: continue print(res) except: breakprint(eval(input()))import sys while True: try: string = sys.stdin.readline() line = int(string) if line == 1 or line == 2: print(-1) elif line == 3: print(2) elif line%4==1 or line%4==3: print(2) elif line%4==2: print(4) else: print(3) except: break# -*- coding: utf-8 -*-# !/usr/bin/python3# 解题思路：动态规划dp[i][j]表示st1[0:j - 1]和st2[0:i - 1]的最小距离；# 那么st1和st2的距离与dp[i][j], dp[i - 1][j]和dp[i][j - 1]有关；# 如果st1[j] == st2[i], dp[i + 1][j + 1] = dp[i - 1][j - 1];# 如果st1[j] != st2[i], dp[i + 1][j + 1] = min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1);# 边界条件：第0行和第0列表示空字符串分别于st1和st2的子字符串的距离，dp[i][0] = i, dp[0][j] = j while True: try: st1 = input() st2 = input() if len(st1) &lt; len(st2): st1, st2 = st2, st1 m = len(st1) n = len(st2) res = [[0 for i in range(m + 1)] for i in range(n + 1)] for i in range(n + 1): res[i][0] = i for j in range(m + 1): res[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if st1[j - 1] == st2[i - 1]: res[i][j] = res[i - 1][j - 1] else: res[i][j] = min(res[i - 1][j - 1] + 1, res[i - 1][j] + 1, res[i][j - 1] + 1) print(res[n][m]) except: breakwhile True: try: a=input() b=input().split() c=int(input()) print(b[-c] if c!=0 else 0) except: breakwhile True: try: print('ABCD'*int(input())) except: breakwhile True: try: a,b=input().split() print(a[:int(b)]) except: breakfrom collections import Counterwhile True: try: n=int(input()) for i in range(n): c=Counter(input()) start=26 rev=0 for j in c.most_common(): rev+=j[1]*start start-=1 print(rev) except: breakdef solver(board, rows, cols, squs, i, j): if i&gt;=9: return True if board[i][j]!='0': return solver(board, rows, cols, squs, (i*9+j+1)//9, (i*9+j+1)%9) for n in &#123;'1','2','3','4','5','6','7','8','9'&#125;-(rows[i]|cols[j]|squs[i//3*3+j//3]): board[i][j] = n rows[i].add(n) cols[j].add(n) squs[i//3*3+j//3].add(n) if not solver(board, rows, cols, squs, (i*9+j+1)//9, (i*9+j+1)%9): board[i][j] = '0' rows[i].remove(n) cols[j].remove(n) squs[i//3*3+j//3].remove(n) else: return True return False while True: try: board = [] for i in range(9): board.append(input().split()) rows, cols, squs = [set() for i in range(9)], [set() for i in range(9)], [set() for i in range(9)] for i, row in enumerate(board): for j, num in enumerate(row): if num!='0': rows[i].add(num) cols[j].add(num) squs[i//3*3+j//3].add(num) solver(board, rows, cols, squs, 0, 0) for i in range(9): print(' '.join(board[i])) except: breaktry: while True: row,col = map(int,input().split()) maze = [] for i in range(row): maze.append(list(map(lambda x:-x,map(int,input().split())))) queue = [[0,0]] maze[0][0] = 1 while queue: x,y = queue.pop(0) if x == row-1 and y == col-1: break if x+1 &lt; row and maze[x+1][y] == 0: maze[x+1][y] = maze[x][y]+1 queue.append([x+1,y]) if y+1 &lt; col and maze[x][y+1] == 0: maze[x][y+1] = maze[x][y]+1 queue.append([x,y+1]) if x-1 &gt;= 0 and maze[x-1][y] == 0: maze[x-1][y] = maze[x][y]+1 queue.append([x-1,y]) if y-1 &gt;= 0 and maze[x][y-1] == 0: maze[x][y-1] = maze[x][y]+1 queue.append([x,y-1]) result = [[row-1,col-1]] for i in range(maze[-1][-1]-1,0,-1): tempRow = result[0][0] tempCol = result[0][1] if tempRow-1&gt;=0 and maze[tempRow-1][tempCol] == i: result.insert(0,[tempRow-1,tempCol]) elif tempCol-1&gt;=0 and maze[tempRow][tempCol-1] == i: result.insert(0,[tempRow,tempCol-1]) elif tempRow+1&lt;row and maze[tempRow+1][tempCol] == i: result.insert(0,[tempRow+1,tempCol]) elif tempCol+1&lt;col and maze[tempRow][tempCol+1] == i: result.insert(0,[tempRow,tempCol+1]) for i in result: print('(%d,%d)'%(i[0],i[1]))except Exception: passdef numberToWords(num): to19='one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen seventeen eighteen nineteen'.split() tens=\"twenty thirty forty fifty sixty seventy eighty ninety\".split() def words(n): if n&lt;20:return to19[n-1:n] if n&lt;100:return [tens[n//10-2]]+words(n%10) if n&lt;1000: return [to19[n//100-1]]+[\"hundred\"]+[\"and\"]+words(n%100) for p,w in enumerate(('thousand',\"million\",\"billion\"),1): if n&lt;1000**(p+1): return words(n//1000**p)+[w]+words(n%1000**p) return \" \".join(words(num)) or \"Zero\"while True: try: print(numberToWords(int(input()))) except:breakwhile True: try: n=int(input()) m=list(map(int,input().split()))#python3这块没有python2来的直接，需要用list转换一下 x=list(map(int,input().split())) diff=&#123;0&#125; for i in range(n): d=diff.copy() for j in range(x[i]): for k in d: temp=k+m[i]*(j+1) if temp not in d: diff.add(temp) print(len(diff)) except: breakwhile True: try: a=input() char,space,number,other=0,0,0,0 for i in a: if i==\" \":space+=1 elif i.isnumeric(): number+=1 elif i.isalpha():char+=1 else:other+=1 print(char) print(space) print(number) print(other) except: breakimport syswhile True: try: num=int(input()) print(int(2.875*num)) print(int(0.03125*num)) except: break#按比例缩放就好了。while True: try: a=int(input())-1 arr=[1,2] while len(arr)&lt;a: arr.append(arr[-1]+arr[-2]) print(arr[-1]) except: breakwhile True: try: #key，string分别代表输入的key的加要密的字符串 #chars是密钥对应的字母表，res是要返回的结果。 key, string, chars, res = input(), input(), [], \"\" #经过下面的循环，chars前面几个是密匙的字母 for i in key: if i not in chars: chars.append(i) #如果输入的key中有小写字母，转为大写字母。 chars = list(map(lambda c: c.upper(), chars)) #剩下的字母，填充到chars里面。 for i in range(65, 91): if chr(i) not in chars: chars.append(chr(i)) # 将输入加密。 for i in string: if i.isupper(): res += chars[ord(i) - 65] elif i.islower(): res += chars[ord(i) - 97].lower() else: res += i print(res) except: breakwhile True: try: n, curNum = int(input()), 1 res = [[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(i + 1): res[i - j][j] = curNum curNum += 1 for i in res: print(\" \".join(map(str, (filter(lambda i: i != 0, i))))) except: break while True: try: n,num=int(input()),1 res=[[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(i+1): res[i-j][j]=num num+=1 for i in res: print(\" \".join(map(str,(filter(lambda i :i!=0,i)))))while True: try: print(''.join(sorted(input()))) except: breakwhile True: try: # ip to int_address # 按 '.'拆开 =&gt; map =&gt; 每节转二进制，去'ob',填充'0' =&gt; 合并 =》 转十进制 a=input() b=input() s=a.split('.') print(int(''.join(map(lambda n:bin(int(n)).replace('0b','').rjust(8,'0'),s)),2)) strbin=bin(int(b)).replace('0b','').rjust(32,'0') # int_address to bin ip=[] for i in range(4): ip.append(strbin[i*8:(i+1)*8]) print('.'.join(map(lambda n:str(int(n,2)),ip))) # bin to ip # 将32位二进制地址每八个拆开 =&gt; map =&gt; 每节转十进制 =》 合并 except: break def longestPalindrome(s): if s==s[::-1]:return len(s) maxLen=0 for i in range(len(s)): if i-maxLen&gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]: maxLen+=2 continue if i-maxLen&gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]: maxLen+=1 return maxLenwhile True: try: a=input() if a: print(longestPalindrome(a)) except: breakimport rewhile True: try: s_list=re.split('[^a-zA-Z]+',input().strip()) print(' '.join(s_list[::-1]).strip()) except: breakwhile True: try: dic = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"] s = input().replace(\" \", \"\") #s是输入的合并后的字符串 ss = \"\" #ss为最终返回的字符串 odd, even = \"\", \"\" # 字符串的奇数子串和偶数子串 # 经过下面的循环，提取奇数与偶数的子串。 for i, v in enumerate(s): if i % 2 == 0: even += v else: odd += v # 奇数与偶数部分排序 odd = \"\".join(sorted(odd)) even = \"\".join(sorted(even)) # 如果字符串在0123456789abcdefABCDEF范围内，对其做变换，否则不做任何处理。 for i in range(len(even)): if even[i] in \"0123456789abcdefABCDEF\": ss += dic[int(bin(dic.index(even[i].upper())).replace(\"0b\", \"\").rjust(4, \"0\")[::-1], 2)] else: ss += even[i] if len(odd) != i: #注意偶数串可能比奇数串长一个字符，所以要做一下判断。 if odd[i] in \"0123456789abcdefABCDEF\": ss += dic[int(bin(dic.index(odd[i].upper())).replace(\"0b\", \"\").rjust(4, \"0\")[::-1], 2)] else: ss += odd[i] print(ss) except: breakwhile True: try: a, b = input(), input() resA, resB = \"\", \"\" for i in a: if i.isupper(): if i != \"Z\": resA += chr(ord(i) + 1).lower() else: resA += \"a\" elif i.islower(): if i != \"z\": resA += chr(ord(i) + 1).upper() else: resA += \"A\" elif i.isdigit(): if i != \"9\": resA += chr(ord(i) + 1) else: resA += \"0\" for i in b: if i.isupper(): if i != \"A\": resB += chr(ord(i) - 1).lower() else: resB += \"z\" elif i.islower(): if i != \"a\": resB += chr(ord(i) - 1).upper() else: resB += \"Z\" elif i.isdigit(): if i != \"0\": resB += chr(ord(i) - 1) else: resB += \"9\" print(resA) print(resB) except: breakdef issu(x): tem = 2 while tem**2&lt;=x: if x%tem==0: return False tem+=1 return Truedef find(a,l1,l2,l3): for i in range(0,len(l3)): if issu(a+l3[i]) and l1[i]==0: l1[i]=1 if l2[i]==0 or find(l2[i],l1,l2,l3): l2[i] = a return True return False try: while True: n = input() n = int(n) l = list(map(int,input().split())) ji,ou = [],[] for i in range(n): if l[i]%2==0: ou.append(l[i]) else: ji.append(l[i]) result = 0 match = [0]*len(ou) for i in range(0,len(ji)): used = [0]*len(ou) if find(ji[i],used,match,ou): result+=1 print(result)except: passfrom collections import defaultdict while True: try: dd = defaultdict(list) a = input().split() # words是输入的单词，lookup是要查找的单词，num是要查找兄弟单词的索引，brothers是找到的兄弟单词列表 words, lookup, num, brothers = a[1:1 + int(a[0])], a[-2], int(a[-1]), [] for i in words: dd[\"\".join(sorted(i))].append(i) for i in dd[\"\".join(sorted(lookup))]: if i != lookup: brothers.append(i) # 下面这两行坑的老子调了半个小时。 print(len(brothers)) if brothers and num &lt;= len(brothers): print(sorted(brothers)[num - 1]) except: breakwhile True: try: a=input() res=[False]*len(a) s=[] for i,v in enumerate(a): if v.isalpha(): s.append(v) else: res[i]=v s.sort(key=lambda c:c.lower()) for j,v in enumerate(res): if not v: res[j]=s[0] s.pop(0) print(''.join(res)) except: breakwhile True: try: a=input().split()[1:] b=map(str,sorted(map(int,set(input().split()[1:])))) totalNum=0 res=\"\" for num in b: singleRes,count=\"\",0 for i,v in enumerate(a): if num in v: singleRes+=str(i)+\" \"+v+\" \" totalNum+=2 count+=1 if count: singleRes=num+\" \"+str(count)+\" \"+singleRes totalNum+=2 res+=singleRes print((str(totalNum)+\" \"+res).rstrip()) except: breakdef get_index(nums,target): low,high=0,len(nums)-1 pos=len(nums) while low&lt;high: mid=(low+high)//2 if nums[mid]&lt;target: low=mid+1 else: high=mid pos=mid return posdef increase_lis(l,res): n=len(l) temp=[10**10]*n temp[0]=l[0] res+=[1] for i in range(1,n): pos=get_index(temp,l[i]) res+=[pos+1] temp[pos]=l[i] return reswhile True: try: n=int(input()) a=list(map(int,input().strip().split())) dp_1,dp_2=[],[] dp_1=increase_lis(a,dp_1) new_list=a[::-1] dp_2=increase_lis(new_list,dp_2) maxValue=max([dp_1[i]+dp_2[n-i-1] for i in range(n)]) print(n-maxValue+1) except: breakfrom collections import defaultdictwhile True: try: a=input() b=defaultdict(int) for i in a: b[i]+=1 for i in b.keys(): if b[i]==min(b.values()): a=a.replace(i,'') print(a) except: breakwhile True: try: n=int(input()) print(n//2) except: breakd=&#123; \"abc\":2, \"def\":3, \"ghi\":4, \"jkl\":5, \"mno\":6, \"pqrs\":7, \"tuv\":8, \"wxyz\":9, &#125;while True: try: s=str(input()) res='' for i in s: if i.isupper: if i=='Z': res+='a' else: res+=chr(ord(i.lower())+1) elif i.islower: for j in d.keys(): if i in j: res+=str(d[j]) break else: res+=i print(res) except: breakimport re while True: try: s=input() #1 if len(s)&lt;=8: print('NG') continue #2 count=0 if re.search('[0-9]',s):count+=1 if re.search('[a-z]',s):count+=1 if re.search('[A-Z]',s):count+=1 if re.search('[^0-9a-zA-Z]',s):count+=1 if count&lt;3: print('NG') continue #3 if re.search(r'.*(...)(.*/1)',s): print('NG') continue print('OK') except: breakerror = dict()filelist = []while True: try: record = ' '.join(''.join(input().split('\\\\')[-1]).split()) filename = record.split() if len(filename[0]) &gt;= 16: filename[0] = filename[0][-16:] record = ' '.join(filename) if record not in error.keys(): error[record] = 1 filelist.append(record) else: error[record] += 1 except: breakkey = filelist[-8:]for each in key: print(' '.join(each.split()),error[each])def check_ip(s): for i in s: if i not in range(256): return False return Truedef check_mask(s): if s in ([255,255,255,255],[0,0,0,0]): return False v='' for x in s[::-1]: for i in range(8): v+=str(x&gt;&gt;i&amp;1) if '10' in v: return False return Trueres=[0,0,0,0,0,0,0]while True: try: s=input().split('~') if len(s)!=2: break except: break try: ip=[int(x) for x in s[0].split('.')] mask=[int(x) for x in s[1].split('.')] except: res[5]+=1 continue if check_ip(ip) and check_mask(mask): i,a=ip[0],ip[1] if i in range(1,127): res[0]+=1 if i in range(128,192): res[1]+=1 if i in range(192,224): res[2]+=1 if i in range(224,240): res[3]+=1 if i in range(240,256): res[4]+=1 if i==10 or (i==127 and(a in range(16,32)) or (i==192 and a==168)): res[6]+=1 else: res[5]+=1print(' '.join(str(x) for x in res))while True: try: dx=[-1,0,1,0] dy=[0,-1,0,1] x=0 y=0 s=input() for i in s.split(';'): if i and i[0] in 'ASDW': num=int(i[1:]) x+=num*dx['ASDW'.find(i[0])] y+=num*dy['ASDW'.find(i[0])] print('%d,%d'%(x,y)) except: breaks=str(bin(int(input())))count=0for i in s: if i=='1': count+=1print(count)n=int(input())ls=[]for i in range(n): ls.append(input())for i in sorted(ls): print(i)s=input()print(' '.join(s.split()[::-1]))print(input()[::-1])s=str(input())print(s[::-1])s=str(input())s1=set()for i in s: if 0&lt;ord(i)&lt;128: s1.add(i)print(len(s1))while True: try: s=str(input()) s1='' for i in s[::-1]: if i not in s1: s1+=i print(s1) except: break#用defaultdict，每一个值都有默认值from collections import defaultdictwhile True: try: n=int(input()) df=defaultdict(int) for i in range(n): key,value=map(int,input().split()) df[key]+=value for i in sorted(df.keys()): print(str(i)+' '+str(df[i])) except: breakprint(round(float(input())+0.001))n=int(input())ls=[]for i in range(2,n//2+1): while n%i==0: ls.append(i) n/=iprint(' '.join(map(str,ls))+' ' if ls else str(n)+' ')while True: try: print(int(input(),16)) except: breaka=input()b=input()def sprint_str(s): if len(s)&lt;=8: print(s+'0'*(8-len(s))) else: while len(s)&gt;8: print(s[:8]) s=s[8:] print(s+'0'*(8-len(s)))sprint_str(a)sprint_str(b)while True: try: a=int(input()) s=set() for i in range(a): s.add(int(input())) for j in sorted(s): print(j) except: breaka=input().lower()b=input().lower()print(a.count(b))print(len(input().split()[-1]))","categories":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/categories/code/"}]},{"title":"study 聊天室项目 day 23","slug":"study python 23 day","date":"2020-01-10T12:00:00.000Z","updated":"2020-01-16T07:25:51.953Z","comments":true,"path":"2020/01/10/study python 23 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/10/study%20python%2023%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313import asynchatimport asyncore# 定义端口PORT = 6666# 定义结束异常类class EndSession(Exception): passclass ChatServer(asyncore.dispatcher): \"\"\" 聊天服务器 \"\"\" def __init__(self, port): asyncore.dispatcher.__init__(self) # 创建socket self.create_socket() # 设置 socket 为可重用 self.set_reuse_addr() # 监听端口 self.bind(('', port)) self.listen(5) self.users = &#123;&#125; self.main_room = ChatRoom(self) def handle_accept(self): conn, addr = self.accept() ChatSession(self, conn)class ChatSession(asynchat.async_chat): \"\"\" 负责和客户端通信 \"\"\" def __init__(self, server, sock): asynchat.async_chat.__init__(self, sock) self.server = server self.set_terminator(b'\\n') self.data = [] self.name = None self.enter(LoginRoom(server)) def enter(self, room): # 从当前房间移除自身，然后添加到指定房间 try: cur = self.room except AttributeError: pass else: cur.remove(self) self.room = room room.add(self) def collect_incoming_data(self, data): # 接收客户端的数据 self.data.append(data.decode(\"utf-8\")) def found_terminator(self): # 当客户端的一条数据结束时的处理 line = ''.join(self.data) self.data = [] try: self.room.handle(self, line.encode(\"utf-8\")) # 退出聊天室的处理 except EndSession: self.handle_close() def handle_close(self): # 当 session 关闭时，将进入 LogoutRoom asynchat.async_chat.handle_close(self) self.enter(LogoutRoom(self.server))class CommandHandler: \"\"\" 命令处理类 \"\"\" def unknown(self, session, cmd): # 响应未知命令 # 通过 aynchat.async_chat.push 方法发送消息 session.push(('Unknown command &#123;&#125; \\n'.format(cmd)).encode(\"utf-8\")) def handle(self, session, line): line = line.decode() # 命令处理 if not line.strip(): return parts = line.split(' ', 1) cmd = parts[0] try: line = parts[1].strip() except IndexError: line = '' # 通过协议代码执行相应的方法 method = getattr(self, 'do_' + cmd, None) try: method(session, line) except TypeError: self.unknown(session, cmd)class Room(CommandHandler): \"\"\" 包含多个用户的环境，负责基本的命令处理和广播 \"\"\" def __init__(self, server): self.server = server self.sessions = [] def add(self, session): # 一个用户进入房间 self.sessions.append(session) def remove(self, session): # 一个用户离开房间 self.sessions.remove(session) def broadcast(self, line): # 向所有的用户发送指定消息 # 使用 asynchat.asyn_chat.push 方法发送数据 for session in self.sessions: session.push(line) def do_logout(self, session, line): # 退出房间 raise EndSessionclass LoginRoom(Room): \"\"\" 处理登录用户 \"\"\" def add(self, session): # 用户连接成功的回应 Room.add(self, session) # 使用 asynchat.asyn_chat.push 方法发送数据 session.push(b'Connect Success') def do_login(self, session, line): # 用户登录逻辑 name = line.strip() # 获取用户名称 if not name: session.push(b'UserName Empty') # 检查是否有同名用户 elif name in self.server.users: session.push(b'UserName Exist') # 用户名检查成功后，进入主聊天室 else: session.name = name session.enter(self.server.main_room)class LogoutRoom(Room): \"\"\" 处理退出用户 \"\"\" def add(self, session): # 从服务器中移除 try: del self.server.users[session.name] except KeyError: passclass ChatRoom(Room): \"\"\" 聊天用的房间 \"\"\" def add(self, session): # 广播新用户进入 session.push(b'Login Success') self.broadcast((session.name + ' has entered the room.\\n').encode(\"utf-8\")) self.server.users[session.name] = session Room.add(self, session) def remove(self, session): # 广播用户离开 Room.remove(self, session) self.broadcast((session.name + ' has left the room.\\n').encode(\"utf-8\")) def do_say(self, session, line): # 客户端发送消息 self.broadcast((session.name + ': ' + line + '\\n').encode(\"utf-8\")) def do_look(self, session, line): # 查看在线用户 session.push(b'Online Users:\\n') for other in self.sessions: session.push((other.name + '\\n').encode(\"utf-8\"))if __name__ == '__main__': s = ChatServer(PORT) try: print(\"chat serve run at '0.0.0.0:&#123;0&#125;'\".format(PORT)) asyncore.loop() except KeyboardInterrupt: print(\"chat server exit\")import wximport telnetlibfrom time import sleepimport _thread as threadclass LoginFrame(wx.Frame): \"\"\" 登录窗口 \"\"\" def __init__(self, parent, id, title, size): # 初始化，添加控件并绑定事件 wx.Frame.__init__(self, parent, id, title) self.SetSize(size) self.Center() self.serverAddressLabel = wx.StaticText(self, label=\"Server Address\", pos=(10, 50), size=(120, 25)) self.userNameLabel = wx.StaticText(self, label=\"UserName\", pos=(40, 100), size=(120, 25)) self.serverAddress = wx.TextCtrl(self, pos=(120, 47), size=(150, 25)) self.userName = wx.TextCtrl(self, pos=(120, 97), size=(150, 25)) self.loginButton = wx.Button(self, label='Login', pos=(80, 145), size=(130, 30)) # 绑定登录方法 self.loginButton.Bind(wx.EVT_BUTTON, self.login) self.Show() def login(self, event): # 登录处理 try: serverAddress = self.serverAddress.GetLineText(0).split(':') con.open(serverAddress[0], port=int(serverAddress[1]), timeout=10) response = con.read_some() if response != b'Connect Success': self.showDialog('Error', 'Connect Fail!', (200, 100)) return con.write(('login ' + str(self.userName.GetLineText(0)) + '\\n').encode(\"utf-8\")) response = con.read_some() if response == b'UserName Empty': self.showDialog('Error', 'UserName Empty!', (200, 100)) elif response == b'UserName Exist': self.showDialog('Error', 'UserName Exist!', (200, 100)) else: self.Close() ChatFrame(None, 2, title='ShiYanLou Chat Client', size=(500, 400)) except Exception: self.showDialog('Error', 'Connect Fail!', (95, 20)) def showDialog(self, title, content, size): # 显示错误信息对话框 dialog = wx.Dialog(self, title=title, size=size) dialog.Center() wx.StaticText(dialog, label=content) dialog.ShowModal()class ChatFrame(wx.Frame): \"\"\" 聊天窗口 \"\"\" def __init__(self, parent, id, title, size): # 初始化，添加控件并绑定事件 wx.Frame.__init__(self, parent, id, title) self.SetSize(size) self.Center() self.chatFrame = wx.TextCtrl(self, pos=(5, 5), size=(490, 310), style=wx.TE_MULTILINE | wx.TE_READONLY) self.message = wx.TextCtrl(self, pos=(5, 320), size=(300, 25)) self.sendButton = wx.Button(self, label=\"Send\", pos=(310, 320), size=(58, 25)) self.usersButton = wx.Button(self, label=\"Users\", pos=(373, 320), size=(58, 25)) self.closeButton = wx.Button(self, label=\"Close\", pos=(436, 320), size=(58, 25)) # 发送按钮绑定发送消息方法 self.sendButton.Bind(wx.EVT_BUTTON, self.send) # Users按钮绑定获取在线用户数量方法 self.usersButton.Bind(wx.EVT_BUTTON, self.lookUsers) # 关闭按钮绑定关闭方法 self.closeButton.Bind(wx.EVT_BUTTON, self.close) thread.start_new_thread(self.receive, ()) self.Show() def send(self, event): # 发送消息 message = str(self.message.GetLineText(0)).strip() if message != '': con.write(('say ' + message + '\\n').encode(\"utf-8\")) self.message.Clear() def lookUsers(self, event): # 查看当前在线用户 con.write(b'look\\n') def close(self, event): # 关闭窗口 con.write(b'logout\\n') con.close() self.Close() def receive(self): # 接受服务器的消息 while True: sleep(0.6) result = con.read_very_eager() if result != '': self.chatFrame.AppendText(result)if __name__ == '__main__': app = wx.App() con = telnetlib.Telnet() LoginFrame(None, -1, title=\"Login\", size=(320, 250)) app.MainLoop()","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study 2048项目 day 22","slug":"study python 22 day","date":"2020-01-09T12:00:00.000Z","updated":"2020-01-13T14:25:06.171Z","comments":true,"path":"2020/01/09/study python 22 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/09/study%20python%2022%20day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221# -*- coding: utf-8 -*-import cursesfrom random import randrange, choice # generate and place new tilefrom collections import defaultdictletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']# print(letter_codes)actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']actions_dict = dict(zip(letter_codes, actions * 2))# print(actions_dict)def get_user_action(keyboard): char = 'N' while char not in actions_dict: # 返回按下键的 ascii 码值 char = keyboard.getch() return actions_dict[char]def transpose(field): return [list(row) for row in zip(*field)]def invert(field): return [row[::-1] for row in field]class GameField(object): def __init__(self, height=4, width=4, win=2048): self.height = height self.width = width self.win_value = win self.score = 0 self.highscore = 0 self.reset() def reset(self): if self.score &gt; self.highscore: self.highscore = self.score self.score = 0 self.field = [[0 for i in range(self.width)] for j in range(self.height)] self.spawn() self.spawn() def move(self, direction): def move_row_left(row): def tighten(row): # squeese non-zero elements together new_row = [i for i in row if i != 0] new_row += [0 for i in range(len(row) - len(new_row))] return new_row def merge(row): pair = False new_row = [] for i in range(len(row)): if pair: new_row.append(2 * row[i]) self.score += 2 * row[i] pair = False else: if i + 1 &lt; len(row) and row[i] == row[i + 1]: pair = True new_row.append(0) else: new_row.append(row[i]) assert len(new_row) == len(row) return new_row return tighten(merge(tighten(row))) moves = &#123;&#125; moves['Left'] = lambda field: [move_row_left(row) for row in field] moves['Right'] = lambda field: invert(moves['Left'](invert(field))) moves['Up'] = lambda field: transpose(moves['Left'](transpose(field))) moves['Down'] = lambda field: transpose(moves['Right'](transpose(field))) if direction in moves: if self.move_is_possible(direction): self.field = moves[direction](self.field) self.spawn() return True else: return False def is_win(self): return any(any(i &gt;= self.win_value for i in row) for row in self.field) def is_gameover(self): return not any(self.move_is_possible(move) for move in actions) def draw(self, screen): help_string1 = '(W)Up (S)Down (A)Left (D)Right' help_string2 = ' (R)Restart (Q)Exit' gameover_string = ' GAME OVER' win_string = ' YOU WIN!' def cast(string): screen.addstr(string + '\\n') def draw_hor_separator(): line = '+' + ('+------' * self.width + '+')[1:] separator = defaultdict(lambda: line) if not hasattr(draw_hor_separator, \"counter\"): draw_hor_separator.counter = 0 cast(separator[draw_hor_separator.counter]) draw_hor_separator.counter += 1 def draw_row(row): cast(''.join('|&#123;: ^5&#125; '.format(num) if num &gt; 0 else '| ' for num in row) + '|') screen.clear() cast('SCORE: ' + str(self.score)) if 0 != self.highscore: cast('HIGHSCORE: ' + str(self.highscore)) for row in self.field: draw_hor_separator() draw_row(row) draw_hor_separator() if self.is_win(): cast(win_string) else: if self.is_gameover(): cast(gameover_string) else: cast(help_string1) cast(help_string2) def spawn(self): new_element = 4 if randrange(100) &gt; 89 else 2 (i, j) = choice([(i, j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0]) self.field[i][j] = new_element def move_is_possible(self, direction): def row_is_left_movable(row): def change(i): # true if there'll be change in i-th tile if row[i] == 0 and row[i + 1] != 0: # Move return True if row[i] != 0 and row[i + 1] == row[i]: # Merge return True return False return any(change(i) for i in range(len(row) - 1)) check = &#123;&#125; check['Left'] = lambda field: \\ any(row_is_left_movable(row) for row in field) check['Right'] = lambda field: \\ check['Left'](invert(field)) check['Up'] = lambda field: \\ check['Left'](transpose(field)) check['Down'] = lambda field: \\ check['Right'](transpose(field)) if direction in check: return check[direction](self.field) else: return Falsedef main(stdscr): def init(): # 重置游戏棋盘 game_field.reset() return 'Game' def not_game(state): # 画出 GameOver 或者 Win 的界面 # 怎么画出的 game_field.draw(stdscr) # 读取用户输入得到action，判断是重启游戏还是结束游戏 # action = get_user_action(stdscr) responses = defaultdict(lambda: state) # 默认是当前状态，没有行为就会一直在当前界面循环 responses['Restart'], responses['Exit'] = 'Init', 'Exit' # 对应不同的行为转换到不同的状态 return responses[action] def game(): # 画出当前棋盘状态 game_field.draw(stdscr) # 读取用户输入得到action action = get_user_action(stdscr) if action == 'Restart': return 'Init' if action == 'Exit': return 'Exit' if game_field.move(action): # move successful if game_field.is_win(): return 'Win' if game_field.is_gameover(): return 'Gameover' return 'Game' state_actions = &#123; 'Init': init, 'Win': lambda: not_game('Win'), 'Gameover': lambda: not_game('Gameover'), 'Game': game &#125; curses.use_default_colors() # 设置终结状态最大数值为 32 game_field = GameField(win=128) state = 'Init' # 状态机开始循环 while state != 'Exit': state = state_actions[state]()curses.wrapper(main)","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study python练手项目集合 day 21","slug":"study python 21 day","date":"2020-01-08T12:00:00.000Z","updated":"2020-01-16T09:33:45.205Z","comments":true,"path":"2020/01/08/study python 21 day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/08/study%20python%2021%20day/","excerpt":"","text":"python练手项目1：URL:click python练手项目2：URL:click python练手项目3：URL:click python练手项目4：URL:click python安装模块加速方式：pip install 插件名字 -i https://pypi.tuna.tsinghua.edu.cn/simple","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"study 图片转换字符串项目 day 21-1","slug":"study python 21 day - 1","date":"2020-01-08T12:00:00.000Z","updated":"2020-01-13T14:22:19.606Z","comments":true,"path":"2020/01/08/study python 21 day - 1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/08/study%20python%2021%20day%20-%201/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding=utf-8 -*-#导入图片处理模块from PIL import Image#导入操作命令行参数处理模块import argparse#import matplotlib.image as mpimg#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件#也可直接指定高和宽#parser.add_argument('--width', type = int, default =80) #输出字符画宽#parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.file#直接指定高和宽#WIDTH = args.width#HEIGHT = args.heightWIDTH=80HEIGHT=80#输入70个字符，代替不同颜色ascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\\"^`'. \")# 将256灰度映射到70个字符上，256种颜色映射70个字符，因此需要除以一个参数def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length#除以一个参数，满足256种颜色到70个字符的映射 return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = \"\" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\\n' print(txt)","categories":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"keywords":[{"name":"项目","slug":"项目","permalink":"https://yanxigun99.github.io/categories/%E9%A1%B9%E7%9B%AE/"}]},{"title":"python mysql day 20","slug":"study python 20day","date":"2020-01-07T12:00:01.000Z","updated":"2020-01-13T14:14:41.192Z","comments":true,"path":"2020/01/07/study python 20day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/07/study%20python%2020day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294select * from employeeswhere hire_date &#x3D;(select max(hire_date) from employees)select *from employees where hire_date&#x3D;(select max(hire_date) from employees)select *from employees where hire_date&#x3D;(select max(hire_date) from employees)select * from employeeswhere hire_date&#x3D;(select hire_date from employees order by hire_date desc limit 2,1)select *from employees where hire_date&#x3D;(select hire_date from employees order by hire_date desc limit 2,1)select *from employees where hire_date&#x3D;(select hire_date from employees order by hire_date desc limit 2,1)select s.*,d.dept_no from salaries s,dept_manager dwhere s.to_date&#x3D;&#39;9999-01-01&#39;and d.to_date&#x3D;&#39;9999-01-01&#39;and s.emp_no&#x3D;d.emp_no select s.*,d.dept_no from salaries s,dept_manager d where s.to_date&#x3D;&#39;9999-01-01&#39;and d.to_date&#x3D;&#39;999-01-01&#39;and s.emp_no&#x3D;d,emp_noselect s.*,d.dept_no from salaries s,dept_manager dwhere s.to_date&#x3D;&#39;9999-01-01&#39;and d.to_date&#x3D;&#39;9999-01-01&#39;and s.emp_no&#x3D;d.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from dept_emp inner join employees where dept_emp.emp_no&#x3D;employees.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_nofrom dept_emp inner join employeeswhere dept_emp.emp_no&#x3D;employees.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from employeesleft join dept_emp on dept_emp.emp_no&#x3D;employees.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from employeesleft join dept_emp no dept_emp.emp_no&#x3D;employees.emp_noselect e.emp_no,s.salary from salaries as s inner join employees as eon e.emp_no&#x3D;s.emp_no where e.hire_date&#x3D;s.from_dateorder by e.emp_no descselect e.emp_no,s.salaries as s inner join employees as e on e.emp_no&#x3D;s.emp_no where e.hire_date&#x3D;s.from_dateorder by e.emp_no descselect e.emp_no,s.salaries as s inner join employees as eon e.emp_no&#x3D;s.emp_np where e.hire_date&#x3D;s.from_dateorder by e.emp_no descselect emp_no,count(emp_no)as t from salaries group by emp_no having t&gt;15select emp_no,count(emp_no ) as t from salaries group by emp_no having t&gt;15select emp_no,count(emp_no) as t from salaries group bu emp_no having t&gt;15select distinct salary from salaries where to_date&#x3D;&#39;9999-01-01&#39; order by salary descselect distinct salary from slaries where to_date&#x3D;&#39;9999-01-01&#39;order by salary descselect distinct salary from salaries where to_date&#x3D;&#39;9999-01-01&#39;order by salary desc select d.dept_no,d.emp_no,s.salary from salaries s inner join dept_manager don d.emp_no&#x3D;s.emp_no where d.to_date&#x3D;&#39;9999-01-01&#39;and s.to_date&#x3D;&#39;9999-01-01&#39;select d.dept_no,d.emp_no,s.salary from salaries s inner join dept_manager don d.emp_no&#x3D;s.emp_no where d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39; select d.dept_no,d.emp_no,s.salary from salaries s inner join dept_manager don d.emp_no&#x3D;s.emp_no where d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;select emp_no from (select * from employees left join dept_manager on employees.emp_no&#x3D;dept_manager.emp_no)where dept_no is nullselect emp_no from(select * from employees left join dept_manager on employees.emp_no&#x3D;dept_manager.emp_no)where dept_no is nullselect de.emp_no,dm.emp_no as manager_no from dept_emp as de inner join dept_manager as dmon de.dept_no&#x3D;dm.dept_nowhere de.to_date&#x3D;&#39;9999-01-01&#39; and dm.to_date&#x3D;&#39;9999-01-01&#39; and de.emp_no!&#x3D;dm.emp_noselect de.emp_no,dm.emp_no as manager_no from dept_emp as deinner join dept_manager as dmon de.dept_no&#x3D;dm.dept_nowhere de.to_date&#x3D;&#39;9999-01-01&#39;and dm.to_date&#x3D;&#39;9999-01-01&#39;and de.emp_no!&#x3D;dm.emp_noselect de.emp_no,dm.emp_no as manager_no from dept_emp as deinner join dept_manager as dmon de.dept_no&#x3D;&#39;9999-01-01&#39;and dm.to_date&#x3D;&#39;9999-01-01&#39;and de.emp_no!&#x3D;dm.emp_noselect d.dept_no,d.emp_no,max(s.salary) as salaryfrom dept_emp as d inner join salaries as s on d.emp_no&#x3D;s.emp_nowhere d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;group by dept_noselect d.dept_no,d.emp_no,max(s.salary) as salaryfrom dept_emp as d inner join salaries as s on d.emp_no&#x3D;s.emp_nogroup by dept_noselect title,count(title)as t from titles group by title having t&gt;&#x3D;2select title,count(title )as t from titles group by title having t&gt;&#x3D;2select title ,count(title)as t from title group by title having t&gt;&#x3D;2select title,count(distinct emp_no)as t from titles group by title having t&gt;&#x3D;2select title,count(distinct emp_no) as t from titles group by title having t&gt;&#x3D;2select * from employees where emp_no%2&#x3D;1 and last_name!&#x3D;&#39;Mary&#39;order by hire_date descselect *from employees where emp_no%2&#x3D;1 and last_name!&#x3D;&#39;mary&#39;order by hire_date desc select *from employees where emp_no%2&#x3D;1 and last_name !&#x3D;&#39;mary&#39;order by hire_date descSELECT t.title as title, AVG(salary) AS avgFROM titles AS tINNER JOIN salaries AS sON s.emp_no &#x3D; t.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; AND t.to_date &#x3D; &#39;9999-01-01&#39;GROUP BY t.titleselect t.title as title,avg(salary) as avgfrom titles as tinner join salaries as s on s.emp_no&#x3D;t.emp_noand s.to_date&#x3D;&#39;9999-01-01&#39;and t.to_date&#x3D;&#39;9999-01-01&#39;group by t.titleselect t.title as title, avg(salary) as avgfrom titles as tinner join salaries as s on s.emp_no&#x3D;t.emp_noand s.to_date&#x3D;&#39;9999-01-01&#39;and t.to_date&#x3D;&#39;9999-01-01&#39;group by t.titleselect emp_no,salary from salaries where to_date&#x3D;&#39;9999-01-01&#39; and salary&#x3D;(select salary from salaries order by salary desc limit 1,1)select emp_no,salary from salaries where to_date&#x3D;&#39;9999-01-01&#39;and salary&#x3D;(select salary from salaries order by salary desc limit 1,1)select e.emp_no,s.salary,e.last_name,e.first_name from employees as e inner join salaries as son e.emp_no&#x3D;s.emp_nowhere s.to_date&#x3D;&#39;9999-01-01&#39;and salary&#x3D;(select max(salary) from salaries where salary &lt; (select max(salary) from salaries))select e.emp_no,s.salary,e.last_name,e.first_namefrom employees as e inner join salaries as son e.emp_no&#x3D;s.emp_nowhere s.to_date&#x3D;&#39;9999-01-01&#39;and salary&#x3D;(select max(salary) from salaries where salary&lt;(select max(salary) from salaries))select e.last_name,e.first_name,dm.dept_name from(employees as e left join dept_emp as de on e.emp_no&#x3D;de.emp_no)left join departments as dm on dm.dept_no&#x3D;de.dept_noselect e.last_name,e.first_name, dm.dept_name from(employees as e left join dept_emp as de on e.emp_no&#x3D;de.emp_no)left join departments as dm on dm.dept_no&#x3D;de_dept_noselect e.last_name,e.first_name,dm.dept_name from(employees as e left join dept_emp as de on e.emp_no&#x3D;de.emp_no)left join departments as dm on dm.dept_no&#x3D;de.dept_noselect ( (select salary from salaries where emp_no&#x3D;10001 order by to_date desc limit 1) -(select salary from salaries where emp_no&#x3D;10001 order by to_date limit 1)) as growthselect((select salary from salaries where emp&#x3D;10001 order by to_date desc limit 1)-(select salary from salaries where emp&#x3D;10001 order by to_date limit 1))as growthselect((select salary from salaries where emp&#x3D;10001 order by to_date desc limit 1)- (select salary from salaries where emp&#x3D;10001 order by to_date limit 1))as growthselect a.emp_no,(b.salary-c.salary)as growthfrom employees as a inner join salaries as bon a.emp_no&#x3D;b.emp_no and b.to_date&#x3D;&#39;9999-01-01&#39;inner join salaries as con a.emp_no&#x3D;c.emp_no and a.hire_date&#x3D;c.from_dateorder by growth select a.emp_no,(b.salary-c.salary)as growthfrom employees as a inner join salaries as bon a.emp_no&#x3D;b.emp_no and b.to_date&#x3D;&#39;9999-01-01&#39;inner join salaries as con a.emp_no&#x3D;c.emp_noand a.hire_date&#x3D;c.hire_dateorder by growthselect de.dept_no,dm.dept_name,count(s.salary)as sumfrom(dept_emp as de inner join salaries as s on s.emp_no&#x3D;de.emp_no)inner join departments dm on dm.dept_no&#x3D;de.dept_nogroup by de.dept_noselect s1.emp_no,s1.salary,count(distinct s2.salary)as rankfrom salaries s1,salaries s2where s1.to_date&#x3D;&#39;9999-01-01&#39;and s2.to_date&#x3D;&#39;9999-01-01&#39; and s1.salary &lt;&#x3D; s2.salarygroup by s1.emp_noorder by s1.salary desc,s1.emp_no ascSELECT de.dept_no, s.emp_no, s.salary FROM (employees AS e INNER JOIN salaries AS s ON s.emp_no &#x3D; e.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39;)INNER JOIN dept_emp AS de ON e.emp_no &#x3D; de.emp_noWHERE de.emp_no NOT IN (SELECT emp_no FROM dept_manager)select de.demp_no,s.emp_no,s.salary from(employees as e inner join salaries as s on s.emp_no&#x3D;e.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)inner join dept_emp as de on e.emp_no&#x3D;de.emp_nowhere de.emp_no not in (select emp_no from dept_manager)SELECT sem.emp_no AS emp_no, sdm.emp_no AS manager_no, sem.salary AS emp_salary, sdm.salary AS manager_salaryFROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries s INNER JOIN dept_emp deON s.emp_no &#x3D; de.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sem, (SELECT s.salary, s.emp_no, dm.dept_no FROM salaries s INNER JOIN dept_manager dmON s.emp_no &#x3D; dm.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sdmWHERE sem.dept_no &#x3D; sdm.dept_no AND sem.salary &gt; sdm.salaryselect sem.emp_no as emp_no,sdm.emp_no as manager_no,sem.salary as emp_salary,sdm.salary as manager_salaryfrom(select s.salary,s.emp_no,de.dept_no from salarier s inner join demp_emp de on s.emp_no&#x3D;de.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)as sem,(select s.salary,s.emp_no,dm.dept_no from salaries s inner join dept_manager dm on s.emp_no&#x3D;dm.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)as sdmwhere dem.dept_no&#x3D;sdm.dept_no and sem.salary&gt;sdm.salarySELECT s2.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growthFROM salaries AS s1, salaries AS s2WHERE s1.emp_no &#x3D; s2.emp_no AND salary_growth &gt; 5000AND (strftime(&quot;%Y&quot;,s2.to_date) - strftime(&quot;%Y&quot;,s1.to_date) &#x3D; 1 OR strftime(&quot;%Y&quot;,s2.from_date) - strftime(&quot;%Y&quot;,s1.from_date) &#x3D; 1 )ORDER BY salary_growth DESCselect s2.emp_no,s2.from_date,(s2.salaty-s1.salary)as salaty_growthfrom salaties as s1,salaries as s2where s1.emp_no&#x3D;s2.emp_noand salary_growth&gt;5000and(strftime(&#39;%Y&#39;,s2.to_date)-strftime(&quot;%Y&quot;,s1.to_date)&#x3D;1 or strftime(&quot;%Y&quot;,s2.from_date)-strftime(&quot;%Y&quot;,s1.from_date)&#x3D;1 order by salary_growth desc","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://yanxigun99.github.io/tags/mysql/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"study linux day 20-1","slug":"study python 20 day -1","date":"2020-01-07T12:00:00.000Z","updated":"2020-01-13T14:18:05.278Z","comments":true,"path":"2020/01/07/study python 20 day -1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/07/study%20python%2020%20day%20-1/","excerpt":"","text":"linux命令集：URL:click linux教程：URL:click CentOS教程：URL:click","categories":[{"name":"linux","slug":"linux","permalink":"https://yanxigun99.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yanxigun99.github.io/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://yanxigun99.github.io/categories/linux/"}]},{"title":"python mysql day 19","slug":"study python 19day","date":"2020-01-06T12:00:01.000Z","updated":"2020-01-13T14:13:45.517Z","comments":true,"path":"2020/01/06/study python 19day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/06/study%20python%2019day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365select * from employeeswhere hire_date &#x3D;(select max(hire_date) from employees)select * from employeeswhere hire_date&#x3D;(select hire_date from employees order by hire_date desc limit 2,1)select s.*,d.dept_no from salaries s,dept_manager dwhere s.to_date&#x3D;&#39;9999-01-01&#39;and d.to_date&#x3D;&#39;9999-01-01&#39;and s.emp_no&#x3D;d.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from dept_emp inner join employees where dept_emp.emp_no&#x3D;employees.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from employeesleft join dept_emp on dept_emp.emp_no&#x3D;employees.emp_noselect e.emp_no,s.salary from salaries as s inner join employees as eon e.emp_no&#x3D;s.emp_no where e.hire_date&#x3D;s.from_dateorder by e.emp_no descselect emp_no,count(emp_no)as t from salaries group by emp_no having t&gt;15select distinct salary from salaries where to_date&#x3D;&#39;9999-01-01&#39; order by salary descselect d.dept_no,d.emp_no,s.salary from salaries s inner join dept_manager don d.emp_no&#x3D;s.emp_no where d.to_date&#x3D;&#39;9999-01-01&#39;and s.to_date&#x3D;&#39;9999-01-01&#39;select emp_no from (select * from employees left join dept_manager on employees.emp_no&#x3D;dept_manager.emp_no)where dept_no is nullselect de.emp_no,dm.emp_no as manager_no from dept_emp as de inner join dept_manager as dmon de.dept_no&#x3D;dm.dept_nowhere de.to_date&#x3D;&#39;9999-01-01&#39; and dm.to_date&#x3D;&#39;9999-01-01&#39; and de.emp_no!&#x3D;dm.emp_noselect d.dept_no,d.emp_no,max(s.salary) as salaryfrom dept_emp as d inner join salaries as s on d.emp_no&#x3D;s.emp_nowhere d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;group by dept_noselect title,count(title)as t from titles group by title having t&gt;&#x3D;2select title,count(distinct emp_no)as t from titles group by title having t&gt;&#x3D;2select * from employees where emp_no%2&#x3D;1 and last_name!&#x3D;&#39;Mary&#39;order by hire_date descSELECT t.title as title, AVG(salary) AS avgFROM titles AS tINNER JOIN salaries AS sON s.emp_no &#x3D; t.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; AND t.to_date &#x3D; &#39;9999-01-01&#39;GROUP BY t.titleselect emp_no,salary from salaries where to_date&#x3D;&#39;9999-01-01&#39; and salary&#x3D;(select salary from salaries order by salary desc limit 1,1)select e.emp_no,s.salary,e.last_name,e.first_name from employees as e inner join salaries as son e.emp_no&#x3D;s.emp_nowhere s.to_date&#x3D;&#39;9999-01-01&#39;and salary&#x3D;(select max(salary) from salaries where salary &lt; (select max(salary) from salaries))select e.last_name,e.first_name,dm.dept_name from(employees as e left join dept_emp as de on e.emp_no&#x3D;de.emp_no)left join departments as dm on dm.dept_no&#x3D;de.dept_noselect ( (select salary from salaries where emp_no&#x3D;10001 order by to_date desc limit 1) -(select salary from salaries where emp_no&#x3D;10001 order by to_date limit 1)) as growthselect a.emp_no,(b.salary-c.salary)as growthfrom employees as a inner join salaries as bon a.emp_no&#x3D;b.emp_no and b.to_date&#x3D;&#39;9999-01-01&#39;inner join salaries as con a.emp_no&#x3D;c.emp_no and a.hire_date&#x3D;c.from_dateorder by growth select de.dept_no,dm.dept_name,count(s.salary)as sumfrom(dept_emp as de inner join salaries as s on s.emp_no&#x3D;de.emp_no)inner join departments dm on dm.dept_no&#x3D;de.dept_nogroup by de.dept_noselect s1.emp_no,s1.salary,count(distinct s2.salary)as rankfrom salaries s1,salaries s2where s1.to_date&#x3D;&#39;9999-01-01&#39;and s2.to_date&#x3D;&#39;9999-01-01&#39; and s1.salary &lt;&#x3D; s2.salarygroup by s1.emp_noorder by s1.salary desc,s1.emp_no ascSELECT de.dept_no, s.emp_no, s.salary FROM (employees AS e INNER JOIN salaries AS s ON s.emp_no &#x3D; e.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39;)INNER JOIN dept_emp AS de ON e.emp_no &#x3D; de.emp_noWHERE de.emp_no NOT IN (SELECT emp_no FROM dept_manager)select de.demp_no,s.emp_no,s.salary from(employees as e inner join salaries as s on s.emp_no&#x3D;e.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)inner join dept_emp as de on e.emp_no&#x3D;de.emp_nowhere de.emp_no not in (select emp_no from dept_manager)SELECT sem.emp_no AS emp_no, sdm.emp_no AS manager_no, sem.salary AS emp_salary, sdm.salary AS manager_salaryFROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries s INNER JOIN dept_emp deON s.emp_no &#x3D; de.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sem, (SELECT s.salary, s.emp_no, dm.dept_no FROM salaries s INNER JOIN dept_manager dmON s.emp_no &#x3D; dm.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sdmWHERE sem.dept_no &#x3D; sdm.dept_no AND sem.salary &gt; sdm.salaryselect sem.emp_no as emp_no,sdm.emp_no as manager_no,sem.salary as emp_salary,sdm.salary as manager_salaryfrom(select s.salary,s.emp_no,de.dept_no from salarier s inner join demp_emp de on s.emp_no&#x3D;de.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)as sem,(select s.salary,s.emp_no,dm.dept_no from salaries s inner join dept_manager dm on s.emp_no&#x3D;dm.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)as sdmwhere dem.dept_no&#x3D;sdm.dept_no and sem.salary&gt;sdm.salarySELECT s2.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growthFROM salaries AS s1, salaries AS s2WHERE s1.emp_no &#x3D; s2.emp_no AND salary_growth &gt; 5000AND (strftime(&quot;%Y&quot;,s2.to_date) - strftime(&quot;%Y&quot;,s1.to_date) &#x3D; 1 OR strftime(&quot;%Y&quot;,s2.from_date) - strftime(&quot;%Y&quot;,s1.from_date) &#x3D; 1 )ORDER BY salary_growth DESCselect s2.emp_no,s2.from_date,(s2.salaty-s1.salary)as salaty_growthfrom salaties as s1,salaries as s2where s1.emp_no&#x3D;s2.emp_noand salary_growth&gt;5000and(strftime(&#39;%Y&#39;,s2.to_date)-strftime(&quot;%Y&quot;,s1.to_date)&#x3D;1 or strftime(&quot;%Y&quot;,s2.from_date)-strftime(&quot;%Y&quot;,s1.from_date)&#x3D;1 order by salary_growth descexplain select * from employeesexplain select *from employees select last_name ||&quot; &quot;||first_name as name from employeesselect lase_name ||&quot; &quot;||first_name as name from employeescreate table if not exists actor( actor_id smallint(5) not null, first_name varchar(45) not null, last_name varchar(45) not null, last_update timestamp not null default( datetime(&#39;now&#39;,&#39;localtime&#39;)), primary key(actor_id))create table if not exists actor( actor_id smallint(5) not null, first_name varchar(45) not null, last_name varchar(45) not null, last_update timestamp not null default(datetime(&#39;now&#39;,&#39;localtime&#39;)), primary key(actor_id))INSERT INTO actorVALUES (1, &#39;PENELOPE&#39;, &#39;GUINESS&#39;, &#39;2006-02-15 12:34:33&#39;),(2, &#39;NICK&#39;, &#39;WAHLBERG&#39;, &#39;2006-02-15 12:34:33&#39;)insert into actorvalue( 1,&#39;penelope&#39;,&#39;guiness&#39;,&#39;2006-02-15 12:34:33&#39;),(2,&#39;nick&#39;,&#39;wahlaberg&#39;,&#39;2006-02-15 12:34:33&#39;)INSERT INTO actorVALUES (1, &#39;PENELOPE&#39;, &#39;GUINESS&#39;, &#39;2006-02-15 12:34:33&#39;),(2, &#39;NICK&#39;, &#39;WAHLBERG&#39;, &#39;2006-02-15 12:34:33&#39;)insert into actorvalue( 1,&#39;penelope&#39;,&#39;guiness&#39;,&#39;2006-02-15 12:34:33&#39;),(2,&#39;nick&#39;,&#39;wahlaberg&#39;,&#39;2006-02-15 12:34:33&#39;)insert or ignore into actor values(3,&#39;ed&#39;,&#39;chase&#39;,&#39;2006-02-15 12:34:33&#39;)create table if not exists actor_name( first_name varchar(45) not null, last_name varchar(45) not null);insert into actor_name select first_name,last_name from actorcreate unique index uniq_idx_firstname on actor(first_name);create index idx_lastname on actor(last_name);create unique index uniq_idx_firstname on actor(first_nname);create index idx_lastname on actor(last_name);CREATE VIEW actor_name_view (fist_name_v,last_name_v)ASSELECT first_name,last_nameFROM actorcreate view actor_name_view (first_name_v,last_name_v)as select first_name,last_namefrom actorselect * from salaries indexed by idx_emp_no where emp_no&#x3D;10005select* from salaries indexed by idx_emp_no where emp_no&#x3D;10005alter table actor add column create_date datetime NOT null default &#39;0000-00-00 00:00:00&#39;alter table actor add column create_date datetime not nulldefault &#39;0000-00-00 00:00:00&#39;create trigger audit_log after insert on employees_testbegin insert into audit values(new.ID,new.NAME);endcreate trigger audit_log after insert on employees_testbegin insert into audit values(new.ID,new.NAME);enddelete from titles_test where id not in(select min(id)from titles_test group by emp_no)delete from titles_test where id not in (select min(id) from titles_test group by emp_no)update titles_test set to_date&#x3D;null,from_date&#x3D;&#39;2001-01-01&#39; where to_date&#x3D;&quot;9999-01-01&quot;update titles_test set to_date&#x3D;null,from_date&#x3D;&#39;2001-01-01&#39;where to_date&#x3D;&#39;9999-01-01&#39;update titles_test set emp_no&#x3D;replace(emp_no,&#39;10001&#39;,&#39;10005&#39;) where id&#x3D;5upate titles_test set emp_no&#x3D;replace(emp_no,&#39;10001&#39;,&#39;10005&#39;)where id&#x3D;5alter table titles_test rename to titles_2017alter table titlles_test rename to titles_2017DROP TABLE audit;CREATE TABLE audit( EMP_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(EMP_no) REFERENCES employees_test(ID));drop table audit;create table audit( emp_no int not null create_date datetime not null, foreign key(emp_no) references employees_test(ID);)select em.* from employees as em,emp_v as ev where ev.emp_no&#x3D;em.emp_noSELECT em.*from employees as em,emp_v as ev where ev.emp_no&#x3D;em.emp_noUPDATE salaries SET salary &#x3D; salary * 1.1 WHERE emp_no IN(SELECT s.emp_no FROM salaries AS s INNER JOIN emp_bonus AS eb ON s.emp_no &#x3D; eb.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39;)update salaries set salary&#x3D;salary*1.1 where emp_no in(select s.emp_no from salaries as s inner join emp_bonus as ebon s.emp_no&#x3D;eb.emp_no and s.to_date&#x3D;&#39;9999-01-01&#39;)select &quot;select count(*) from &quot;||name||&quot;;&quot; as cnts from sqlite_masterwhere type&#x3D;&#39;table&#39;select &#39;select count(*) from &#39;||name||&quot;;&quot;as cnts from sqlite_masterwhere type&#x3D;&#39;table&#39;select last_name||&quot;&#39;&quot;||first_name as namefrom employeesselect last_name||&quot;&#39;&quot;||first_name as namefrom employeesselect length(&quot;10,A,B&quot;)-length(replace(&quot;10,A,B&quot;,&quot;,&quot;,&quot;&quot;)) as cntselect length(&quot;10,A,B&quot;)-length(replace(&quot;10,A,B&quot;,&quot;,&quot;,&quot;&quot;)) as cntselect first_name from employees order by substr(first_name,length(first_name)-1)select first_name from employeesorder by substr(first_name,length(first_name)-1)select dept_no,group_concat(emp_no)as employeesfrom dept_emp group by dept_noselect dept_no,group_councat(emp_no)as employeesfrom dept_emp group by dept_noSELECT AVG(salary) AS avg_salary FROM salaries WHERE to_date &#x3D; &#39;9999-01-01&#39; AND salary NOT IN (SELECT MAX(salary) FROM salaries)AND salary NOT IN (SELECT MIN(salary) FROM salaries)select avg(salary)as avg_salary from salaries where to_date&#x3D;&#39;9999-01-01&#39;and salary not in (select max(salary)from salaries)and salary not in (select min(salary)from salaries)select * from employees limit 5,5select *from employees limit 5,5SELECT de.emp_no, de.dept_no, eb.btype, eb.receviedFROM dept_emp AS de LEFT JOIN emp_bonus AS eb ON de.emp_no &#x3D; eb.emp_noselect de.emp_no,de.dept_no,eb.btype,eb.receviedfrom dept_emp as de left join emp_bonus as ebon de.emp_no&#x3D;eb.emp_noselect e.* from employees as ewhere not exists (select emp_no from dept_emp where dept_emp.emp_no&#x3D;e.emp_no)select e.* from employees as ewhere not exists (select emp_no from dept_emp where dept_emp.emp_no&#x3D;e.emp_no)select em.* from employees as em,emp_v as ep where em.emp_no&#x3D;ep.emp_noselect em.* from employees as em,emp_v as ep where em.emp_no&#x3D;ep.emp_noselect e.emp_no,e.first_name,e.last_name,b.btype,s.salary,(case b.btype when 1 then s.salary*0.1 when 2 then s.salary*0.2 else s.salary*0.3 end)as bonusfrom employees as e inner join salaries as s on s.emp_no&#x3D;e.emp_noinner join emp_bonus as b on s.emp_no&#x3D;b.emp_nowhere s.to_date&#x3D;&#39;9999-01-01&#39;select e.emp_no,e.first_name,e.last_name,b.btyoe,s.salary,(case b.btypewhen 1 then s.salary*0.1when 2 then s.salary*0.2else s.salary*0.3 end)as busfrom employees as e inner join salaries as s on s.emp_no&#x3D;e.emp_noinner join emp_bonus as b on s.enp_no&#x3D;b.emp_nowhere s.to_date-&#39;9999-01-01&#39;select s1.emp_no,s1.salary,(select sum(s2.salary) from salaries as s2 where s2.emp_no&lt;&#x3D;s1.emp_no and s2.to_date&#x3D;&#39;9999-01-01&#39;)as running_total from salaries as s1 where s1.to_date&#x3D;&#39;9999-01-01&#39;select s1.emp_no,s1.salary,(select sum(s2.salary)from salaries as se where s2.emp_no&lt;&#x3D;s1.emp_noand s2.to_date&#x3D;&#39;9999-01-01&#39;)as running_totalfrom salaries as s1where s1.to_date&#x3D;&#39;9999-01-01&#39;select e1.first_name from employees as e1where (select count(e2.first_name)from employees as e2 where e2.first_name&lt;&#x3D;e1.first_name)%2&#x3D;1select e1.first_name feom employees as e1where (select count(e2.first_name)from employees as e2 where e2.first_name&lt;&#x3D;e1.first_name)%2&#x3D;1","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://yanxigun99.github.io/tags/mysql/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python python day 18","slug":"study python 18day","date":"2020-01-05T12:00:01.000Z","updated":"2020-01-13T14:12:23.847Z","comments":true,"path":"2020/01/05/study python 18day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/05/study%20python%2018day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#!/usr/bin/pythonwhile True: try: num=int(input()) w=list(map(int,input().split())) number=list(map(int,input().split())) prev=[0] for i in range(num): res=[] for j in range(number[i]+1): for item in prev: res.append(item+j*w[i]) res=set(res) prev=list(res) print(len(res)) except: breakfrom collection import Counterwhile True: try: a=int(input()) for i in range(a): c,start,res=Counter(input()),26,0 for j in c.most_common(): res+=j[1]*start start-=1 print(res) except: breakwhile True: try: a,b=input().split() print(a[:int(b)]) except: breakwhile True: try: print('ABCD'*int(input())) except: breakprint(eval(input()))while True: try: a,b,c=input(),input().split(),int(input()) pirnt(a[-c] if c!=0 else 0) except: break while True: try: st1=input() st2=input() if len(st1)&lt;len(st2): st1,st2=st2,st1 m=len(st1) n=len(st2) res=[[0 for i in range(m+1)] for i in range(n+1)] for i in range(n+1): res[i][0]=i for j in range(m+1): res[0][i]=j for i in range(1,n+1): for j in range(1,m+1): if st1[j-1]==st2[i-1]: res[i][j]=res[i-1][j-1] else: res[i][j]=min(res[i-1][j-2]+1,res[i-1][j]+1,res[i][j-1]+1) print(res[n][m]) except: break while True: try: string=sys.stdin.readline() line=int(string) if line=1 or line==2: print(-1) elif line==3: print(2) elif line%4==1 or line%4==3: print(2) elif line%4==2: print(4) else: print(3) except: break print(eval(input()))while True: try: a=int(input()) count=0 for i in range(1,a+1): if i%7==0: count+=1 elif '7' in str(i): count+=1 else: continue print(count) except: break try: count=int(input().split()[1]) array=list(map(int,input().strip().split())) print(' '.join(map(str,sorted(array)[:count]))) except: break while True: try: from collections import Counter a=input() c=list(map(lambda c:c[0],list(filter(lambda c:c[1]==1,Count(a).most_common())))) if not c:print(-1) for i in a: if i in c: print(i) break except: break import mathdef isPrime(n): for i in range(2,int(math.sqrt(n)+1)): fi n%i==0: return False return True import mathdef isPrime(n): for i in range(2,int(math.sqrt(n)+1)): fi n%i==0: return False return Truewhile True: try: num,start=int(input()) if num%2==1: start=0 for i in range(start,num,2): a,b=num+i,num-i if isPrime(a) and isPrime(b): print(b) print(a) break except: break while True: try: print(bin(int(input())).count('1')) except: break while True: try: a,b=input(),int(input()) maxStr,maxCnt=a[:b],a[:b] elif len(alpht_list)!=0 and len(digit_list)!=0 and len(symbol_list)!=0: res+=3 elif sum==2 and len(digit_list)!=0 and len(symbol_list)!=0 res+=5 else: pass if res&gt;=90: print('VERY_SECURE') elif res&gt;=80: print('SECURE') elif res&gt;=70: print('VERY_STRONG') elif res&gt;=60: print('STRONG') elif res&gt;=50: print('AVERAGE') elif res&gt;=25: print('WEAK') else: print('VERY_WEAK') except: breakwhile True: try: nums=list(map(int,input().split('.'))) flag=0 for i in range(len(nums)): if nums[i]&lt;0 or nums[i]&gt;255: flag=1 else: pass if flag==0: print('yes') else: print('no') except: break def run(n,m): if n==0 or m==0: return 1 else: return run(n-1,m)+run(n,m-1) while True: try: n,m=map(int,input().split()) print(run(n,m)) except: break curstr='' print(''.join(maxstrs)+','+str(maxlen)) except: break def part_data(data_list): part1=list() part2=list() part3=list() for data in data_list: if data%5==0: part1.append(data) elif data%3==0: part2.append(data) else: part3.append(data) diff=sum(part1)-sum(part2) if(sum(part3)-diff)%2!=0: return False target=(sum(part3)-diff)/2 res=search(part3,target) return resdef search(data_list,target): if len(data_list)==1: return data_list[0]=target else: data=data_list.pop() if data==target: ruturn True if search(data_list,target-data): return True if search(data_list,target): return True data_list.append(data)while True: try: n=int(input().split()) data_list=list(map(int,input().strip().split())) res=part_data(data_list) print('true' if res== True else 'false') except: breakwhile True: try: n = int(raw_input()) a = range(n + 1) order = raw_input() head, tail, i = 1, 4, 1 if n &lt;= 4: for s in order: if s == 'U': if i == 1: i = n else: i -= 1 else: if i == n: i = 1 else: i += 1 head, tail = 1, n else: for s in order: if s == 'U': if i == 1: i = n head, tail = n - 3, n else: i -= 1 if i &lt; head: head, tail = i, i + 3 else: if i == n: i = 1 head, tail = 1, 4 else: i += 1 if i &gt; tail: head, tail = i - 3, i ans = range(head, tail + 1) print(' '.join([str(j) for j in ans])) print( i) except: breakwhile True: try: s1=raw_input() s2=raw_input() count=0 idx=[0,1] n,m=len(s1),len(s2) if n&lt;m: for i in range(n): for j in range(i,n): if s1[i:j+1] in s2: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s1[idx[0]:idx[1]]) else: for i in range(m): for j in range(i,m): if s2[i:j+1] in s1: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s2[idx[0]:idx[1]]) except: break###This is a copy of Orli有异议 ####import sys def checkTwoKeys(twoKeys,a,result): count = 0 index = 0 for y in twoKeys: if a[0]==y.split()[0][:len(a[0])] and a[1]==y.split()[1][:len(a[1])]: count += 1 index = twoKeys.index(y) if count &gt; 1 or count == 0: print(\"unkown command\") elif count == 1: print(result[index]) oneKey = 'reset'twoKeys = ['reset board','reboot backplane','backplane abort','board add','board delete']result = ['board fault','impossible','install first','where to add','no board at all']for i in sys.stdin: a = i.strip().split() l = len(a) if l &lt;= 0 or l&gt;=3: print(\"unkown command\") elif l == 1: if a[0] == oneKey[:len(a[0])]: print(\"reset what\") else: print(\"unkown command\") elif l == 2: checkTwoKeys(twoKeys,a,result)def trans(num,x): total = 0 if len(x) == 1: if abs(num-x[0]) &lt; 0.001: return 1 else: return 0 else: for i in range(len(x)): a = x[i] b = x[:] b.pop(i) total += trans(num-a, b) + trans(num+a, b) + trans(num*a, b) + trans(num/a, b) return total while True: try: nums = raw_input().strip().split() num = [float(i) for i in nums] total = trans(24.0,num) if total == 0: print 'false' else: print 'true' except: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python linux day 17","slug":"study python 17day","date":"2020-01-04T12:00:01.000Z","updated":"2020-01-13T14:10:04.929Z","comments":true,"path":"2020/01/04/study python 17day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/04/study%20python%2017day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409系统信息 arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS &#x2F; DMI) hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性 hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作 cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息 cat &#x2F;proc&#x2F;interrupts 显示中断 cat &#x2F;proc&#x2F;meminfo 校验内存使用 cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用 cat &#x2F;proc&#x2F;version 显示内核的版本 cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计 cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录 cd &#x2F;home 进入 &#39;&#x2F; home&#39; 目录&#39; cd .. 返回上一级目录 cd ..&#x2F;.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &#39;dir1&#39; 的目录&#39; mkdir dir1 dir2 同时创建两个目录 mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 rm -f file1 删除一个叫做 &#39;file1&#39; 的文件&#39; rmdir dir1 删除一个叫做 &#39;dir1&#39; 的目录&#39; rm -rf dir1 删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名&#x2F;移动 一个目录 cp file1 file2 复制一个文件 cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录 cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;&#123;&#125;&quot; -resize 80x60 &quot;thumbs&#x2F;&#123;&#125;&quot; \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索 find &#x2F; -name file1 从 &#39;&#x2F;&#39; 开始进入根文件系统搜索文件和目录 find &#x2F; -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录 find &#x2F;home&#x2F;user1 -name \\*.bin 在目录 &#39;&#x2F; home&#x2F;user1&#39; 中搜索带有&#39;.bin&#39; 结尾的文件 find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find &#x2F; -name \\*.rpm -exec chmod 755 &#39;&#123;&#125;&#39; \\; 搜索以 &#39;.rpm&#39; 结尾的文件并定义其权限 find &#x2F; -xdev -name \\*.rpm 搜索以 &#39;.rpm&#39; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \\*.ps 寻找以 &#39;.ps&#39; 结尾的文件 - 先运行 &#39;updatedb&#39; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统 mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 &#39;&#x2F; mnt&#x2F;hda2&#39; 已经存在 umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#39;&#x2F; mnt&#x2F;hda2&#39; 退出 fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载 umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘 mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件 mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统 mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享 磁盘空间 df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &#39;dir1&#39; 已经使用的磁盘空间&#39; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &#39;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#39; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f&#x3D;&#39;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#39; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 返回顶部索引 ^用户和群组 groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &#39;-r&#39; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &#39;&#x2F;etc&#x2F;passwd&#39; 的文件格式和语法修正以及存在的用户 grpck 检查 &#39;&#x2F;etc&#x2F;passwd&#39; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 返回顶部索引 ^文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 ls -lh 显示权限 ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位 chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位 chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位 返回顶部索引 ^文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 返回顶部索引 ^打包和压缩文件 bunzip2 file1.bz2 解压一个叫做 &#39;file1.bz2&#39;的文件 bzip2 file1 压缩一个叫做 &#39;file1&#39; 的文件 gunzip file1.gz 解压一个叫做 &#39;file1.gz&#39;的文件 gzip file1 压缩一个叫做 &#39;file1&#39;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &#39;file1.rar&#39; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &#39;file1&#39;, &#39;file2&#39; 以及目录 &#39;dir1&#39; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &#39;file1&#39;, &#39;file2&#39; 以及 &#39;dir1&#39;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 返回顶部索引 ^RPM 包 - （Fedora, Redhat及类似系统） rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment&#x2F;Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装&#x2F;删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;&#96;arch&#96;&#x2F;package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 返回顶部索引 ^YUM 软件包升级器 - （Fedora, RedHat及类似系统） yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 返回顶部索引 ^DEB 包 (Debian, Ubuntu 以及类似系统) dpkg -i package.deb 安装&#x2F;更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 返回顶部索引 ^APT 软件工具 (Debian, Ubuntu 以及类似系统) apt-get install package_name 安装&#x2F;更新一个 deb 包 apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 返回顶部索引 ^查看文件内容 cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 返回顶部索引 ^文本处理 cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39;中查找关键词&quot;Aug&quot; grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39; 文件中所有包含数字的行 grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 &#39;&#x2F;var&#x2F;log&#39; 及随后的目录中搜索字符串&quot;Aug&quot; sed &#39;s&#x2F;stringa1&#x2F;stringa2&#x2F;g&#39; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &#39;&#x2F;^$&#x2F;d&#39; example.txt 从example.txt文件中删除所有空白行 sed &#39;&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d&#39; example.txt 从example.txt文件中删除所有注释和空白行 echo &#39;esempio&#39; | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; 合并上下单元格内容 sed -e &#39;1d&#39; result.txt 从文件example.txt 中排除第一行 sed -n &#39;&#x2F;stringa1&#x2F;p&#39; 查看只包含词汇 &quot;string1&quot;的行 sed -e &#39;s&#x2F; *$&#x2F;&#x2F;&#39; example.txt 删除每一行最后的空白字符 sed -e &#39;s&#x2F;stringa1&#x2F;&#x2F;g&#39; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &#39;1,5p;5q&#39; example.txt 查看从第一行到第5行内容 sed -n &#39;5p;5q&#39; example.txt 查看第5行 sed -e &#39;s&#x2F;00*&#x2F;0&#x2F;g&#39; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &#39;NR%2&#x3D;&#x3D;1&#39; 删除example.txt文件中的所有偶数行 echo a b c | awk &#39;&#123;print $1&#125;&#39; 查看一行第一栏 echo a b c | awk &#39;&#123;print $1,$3&#125;&#39; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &#39;+&#39; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &#39;file1&#39; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &#39;file2&#39; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 返回顶部索引 ^字符设置和文件格式转换 dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 返回顶部索引 ^文件系统分析 badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块 fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性 fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性 fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 返回顶部索引 ^初始化一个文件系统 mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统 mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统 fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 返回顶部索引 ^SWAP文件系统 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统 swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 返回顶部索引 ^备份 dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的完整备份 dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的交互式备份 restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份 rsync -rogpav --delete &#x2F;home &#x2F;tmp 同步两边的目录 rsync -rogpav -e ssh --delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录 dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr &#39;dd of&#x3D;hda.gz&#39; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件 tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 &#39;&#x2F;home&#x2F;user&#39; 目录的交互式备份操作 ( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个目录内容 ( tar c &#x2F;home ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find &#x2F;home&#x2F;user1 -name &#39;*.txt&#39; | xargs cp -av --target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; --parents 从一个目录查找并复制所有以 &#39;.txt&#39; 结尾的文件到另一个目录 find &#x2F;var&#x2F;log -name &#39;*.log&#39; | tar cv --files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 &#39;.log&#39; 结尾的文件并做成一个bzip包 dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 返回顶部索引 ^光盘 cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容 mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 返回顶部索引 ^网络 - （以太网和WIFI无线） ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &#39;eth0&#39; 网络设备 ifdown eth0 禁用一个 &#39;eth0&#39; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &#39;eth0&#39; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &#39;eth0&#39; route -n show routing table route add -net 0&#x2F;0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &#39;192.168.0.0&#x2F;16&#39; route del 0&#x2F;0 gw IP_gateway remove static route echo &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &#39;eth0&#39; ethtool eth0 show statistics of network card &#39;eth0&#39; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database GO TOP INDEX ^ Microsoft Windows networks (SAMBA) nbtscan ip_addr netbios name resolution nmblookup -A ip_addr netbios name resolution smbclient -L ip_addr&#x2F;hostname show remote shares of a windows host smbget -Rr smb:&#x2F;&#x2F;ip_addr&#x2F;share like wget can download files from a host windows via smb mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share mount a windows network share","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yanxigun99.github.io/tags/linux/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python linux day 17-1","slug":"study python 17day - 1","date":"2020-01-04T12:00:01.000Z","updated":"2020-01-13T14:11:05.137Z","comments":true,"path":"2020/01/04/study python 17day - 1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/04/study%20python%2017day%20-%201/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419系统信息 arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS &#x2F; DMI) hdparm -i &#x2F;dev&#x2F;hda 罗列一个磁盘的架构特性 hdparm -tT &#x2F;dev&#x2F;sda 在磁盘上执行测试性读取操作 cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息 cat &#x2F;proc&#x2F;interrupts 显示中断 cat &#x2F;proc&#x2F;meminfo 校验内存使用 cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用 cat &#x2F;proc&#x2F;version 显示内核的版本 cat &#x2F;proc&#x2F;net&#x2F;dev 显示网络适配器及统计 cat &#x2F;proc&#x2F;mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录 cd &#x2F;home 进入 &#39;&#x2F; home&#39; 目录&#39; cd .. 返回上一级目录 cd ..&#x2F;.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &#39;dir1&#39; 的目录&#39; mkdir dir1 dir2 同时创建两个目录 mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 rm -f file1 删除一个叫做 &#39;file1&#39; 的文件&#39; rmdir dir1 删除一个叫做 &#39;dir1&#39; 的目录&#39; rm -rf dir1 删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名&#x2F;移动 一个目录 cp file1 file2 复制一个文件 cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录 cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;&#123;&#125;&quot; -resize 80x60 &quot;thumbs&#x2F;&#123;&#125;&quot; \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索 find &#x2F; -name file1 从 &#39;&#x2F;&#39; 开始进入根文件系统搜索文件和目录 find &#x2F; -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录 find &#x2F;home&#x2F;user1 -name \\*.bin 在目录 &#39;&#x2F; home&#x2F;user1&#39; 中搜索带有&#39;.bin&#39; 结尾的文件 find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find &#x2F; -name \\*.rpm -exec chmod 755 &#39;&#123;&#125;&#39; \\; 搜索以 &#39;.rpm&#39; 结尾的文件并定义其权限 find &#x2F; -xdev -name \\*.rpm 搜索以 &#39;.rpm&#39; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \\*.ps 寻找以 &#39;.ps&#39; 结尾的文件 - 先运行 &#39;updatedb&#39; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统 mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 &#39;&#x2F; mnt&#x2F;hda2&#39; 已经存在 umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#39;&#x2F; mnt&#x2F;hda2&#39; 退出 fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载 umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘 mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件 mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统 mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share 挂载一个windows网络共享 磁盘空间 df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &#39;dir1&#39; 已经使用的磁盘空间&#39; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &#39;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#39; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f&#x3D;&#39;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#39; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组 groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &#39;-r&#39; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &#39;&#x2F;etc&#x2F;passwd&#39; 的文件格式和语法修正以及存在的用户 grpck 检查 &#39;&#x2F;etc&#x2F;passwd&#39; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 ls -lh 显示权限 ls &#x2F;tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find &#x2F; -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s &#x2F;bin&#x2F;file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s &#x2F;bin&#x2F;file1 禁用一个二进制文件的 SUID位 chmod g+s &#x2F;home&#x2F;public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s &#x2F;home&#x2F;public 禁用一个目录的 SGID 位 chmod o+t &#x2F;home&#x2F;public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t &#x2F;home&#x2F;public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩&#x2F;解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件 bunzip2 file1.bz2 解压一个叫做 &#39;file1.bz2&#39;的文件 bzip2 file1 压缩一个叫做 &#39;file1&#39; 的文件 gunzip file1.gz 解压一个叫做 &#39;file1.gz&#39;的文件 gzip file1 压缩一个叫做 &#39;file1&#39;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &#39;file1.rar&#39; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &#39;file1&#39;, &#39;file2&#39; 以及目录 &#39;dir1&#39; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &#39;file1&#39;, &#39;file2&#39; 以及 &#39;dir1&#39;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C &#x2F;tmp 将压缩包释放到 &#x2F;tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统） rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment&#x2F;Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装&#x2F;删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;&#96;arch&#96;&#x2F;package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统） yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统) dpkg -i package.deb 安装&#x2F;更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S &#x2F;bin&#x2F;ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统) apt-get install package_name 安装&#x2F;更新一个 deb 包 apt-cdrom install package_name 从光盘安装&#x2F;更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容 cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 文本处理 cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39;中查找关键词&quot;Aug&quot; grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 &#39;&#x2F;var&#x2F;log&#x2F;messages&#39; 文件中所有包含数字的行 grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 &#39;&#x2F;var&#x2F;log&#39; 及随后的目录中搜索字符串&quot;Aug&quot; sed &#39;s&#x2F;stringa1&#x2F;stringa2&#x2F;g&#39; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &#39;&#x2F;^$&#x2F;d&#39; example.txt 从example.txt文件中删除所有空白行 sed &#39;&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d&#39; example.txt 从example.txt文件中删除所有注释和空白行 echo &#39;esempio&#39; | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; 合并上下单元格内容 sed -e &#39;1d&#39; result.txt 从文件example.txt 中排除第一行 sed -n &#39;&#x2F;stringa1&#x2F;p&#39; 查看只包含词汇 &quot;string1&quot;的行 sed -e &#39;s&#x2F; *$&#x2F;&#x2F;&#39; example.txt 删除每一行最后的空白字符 sed -e &#39;s&#x2F;stringa1&#x2F;&#x2F;g&#39; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &#39;1,5p;5q&#39; example.txt 查看从第一行到第5行内容 sed -n &#39;5p;5q&#39; example.txt 查看第5行 sed -e &#39;s&#x2F;00*&#x2F;0&#x2F;g&#39; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &#39;NR%2&#x3D;&#x3D;1&#39; 删除example.txt文件中的所有偶数行 echo a b c | awk &#39;&#123;print $1&#125;&#39; 查看一行第一栏 echo a b c | awk &#39;&#123;print $1,$3&#125;&#39; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &#39;+&#39; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &#39;file1&#39; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &#39;file2&#39; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换 dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析 badblocks -v &#x2F;dev&#x2F;hda1 检查磁盘hda1上的坏磁块 fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上linux文件系统的完整性 fsck.ext2 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext2文件系统的完整性 e2fsck -j &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上ext3文件系统的完整性 fsck.vfat &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上fat文件系统的完整性 fsck.msdos &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 dosfsck &#x2F;dev&#x2F;hda1 修复&#x2F;检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统 mkfs &#x2F;dev&#x2F;hda1 在hda1分区创建一个文件系统 mke2fs &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j &#x2F;dev&#x2F;hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1 创建一个 FAT32 文件系统 fdformat -n &#x2F;dev&#x2F;fd0 格式化一个软盘 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 SWAP文件系统 mkswap &#x2F;dev&#x2F;hda3 创建一个swap文件系统 swapon &#x2F;dev&#x2F;hda3 启用一个新的swap文件系统 swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3 启用两个swap分区 备份 dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的完整备份 dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的交互式备份 restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份 rsync -rogpav --delete &#x2F;home &#x2F;tmp 同步两边的目录 rsync -rogpav -e ssh --delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录 dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr &#39;dd of&#x3D;hda.gz&#39; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件 tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 &#39;&#x2F;home&#x2F;user&#39; 目录的交互式备份操作 ( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个目录内容 ( tar c &#x2F;home ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find &#x2F;home&#x2F;user1 -name &#39;*.txt&#39; | xargs cp -av --target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; --parents 从一个目录查找并复制所有以 &#39;.txt&#39; 结尾的文件到另一个目录 find &#x2F;var&#x2F;log -name &#39;*.log&#39; | tar cv --files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 &#39;.log&#39; 结尾的文件并做成一个bzip包 dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容 光盘 cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force 清空一个可复写的光盘内容 mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o .&#x2F;cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso &#x2F;mnt&#x2F;iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线） ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &#39;eth0&#39; 网络设备 ifdown eth0 禁用一个 &#39;eth0&#39; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &#39;eth0&#39; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &#39;eth0&#39; route -n show routing table route add -net 0&#x2F;0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &#39;192.168.0.0&#x2F;16&#39; route del 0&#x2F;0 gw IP_gateway remove static route echo &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &#39;eth0&#39; ethtool eth0 show statistics of network card &#39;eth0&#39; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database JPS工具jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux&#x2F;unix平台上简单察看当前java进程的一些简单情况。 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。jps存放在JAVA_HOME&#x2F;bin&#x2F;jps，使用时为了方便请将JAVA_HOME&#x2F;bin&#x2F;加入到Path.$&gt; jps23991 Jps23789 BossMain23651 Resin比较常用的参数：-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数$&gt; jps -q286802378923651-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null$&gt; jps -m28715 Jps -m23789 BossMain23651 Resin -socketwait 32768 -stdout &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stdout.log -stderr &#x2F;data&#x2F;aoxj&#x2F;resin&#x2F;log&#x2F;stderr.log-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名$&gt; jps -l28729 sun.tools.jps.Jps23789 com.asiainfo.aimc.bossbi.BossMain23651 com.caucho.server.resin.Resin-v 输出传递给JVM的参数$&gt; jps -v23789 BossMain28802 Jps -Denv.class.path&#x3D;&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;trustwork140.jar:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;:&#x2F;data&#x2F;aoxj&#x2F;bossbi&#x2F;twsecurity&#x2F;java&#x2F;twcmcc.jar:&#x2F;data&#x2F;aoxj&#x2F;jdk15&#x2F;lib&#x2F;rt.jar:&#x2F;data&#x2F;aoxj&#x2F;jdk15&#x2F;lib&#x2F;tools.jar -Dapplication.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;jdk15 -Xms8m23651 Resin -Xss1m -Dresin.home&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Dserver.root&#x3D;&#x2F;data&#x2F;aoxj&#x2F;resin -Djava.util.logging.manager&#x3D;com.caucho.log.LogManagerImpl -Djavax.management.builder.initial&#x3D;com.caucho.jmx.MBeanServerBuilderImplsudo jps看到的进程数量最全jps 192.168.0.77列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099————————————————版权声明：本文为CSDN博主「happydecai」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;happydecai&#x2F;article&#x2F;details&#x2F;79709447","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yanxigun99.github.io/tags/linux/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python MongoDB day 16-1","slug":"study python 16day -1","date":"2020-01-03T12:00:01.000Z","updated":"2020-01-13T14:06:42.407Z","comments":true,"path":"2020/01/03/study python 16day -1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/03/study%20python%2016day%20-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174impor pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017\")mydb=myclicen[\"mydatabase\"]print(myclient.list_database_name())dblist=myclient.list_database_names()if \"mydatabase\" in dblist: print(\"The databse exists\")import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017\")mydb=myclient[\"mydatabase\"]mycol=mybd[\"customers\"]print(mydb.list_collection_names())collist=mydb.list_collection_names()if \"customers\" in collist: print(\"The collection exists\")import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]mydict=&#123;\"name\":\"Bill\",\"address\"：\"Highway 37\"&#125;x=mycol.insert_one(mydict)print(x,inserted_id)import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycil=mydb[\"customers\"]mylist = [ &#123; \"name\": \"Amy\", \"address\": \"Apple st 652\"&#125;, &#123; \"name\": \"Hannah\", \"address\": \"Mountain 21\"&#125;, &#123; \"name\": \"Michael\", \"address\": \"Valley 345\"&#125;, &#123; \"name\": \"Sandy\", \"address\": \"Ocean blvd 2\"&#125;, &#123; \"name\": \"Betty\", \"address\": \"Green Grass 1\"&#125;, &#123; \"name\": \"Richard\", \"address\": \"Sky st 331\"&#125;, &#123; \"name\": \"Susan\", \"address\": \"One way 98\"&#125;, &#123; \"name\": \"Vicky\", \"address\": \"Yellow Garden 2\"&#125;, &#123; \"name\": \"Ben\", \"address\": \"Park Lane 38\"&#125;, &#123; \"name\": \"William\", \"address\": \"Central st 954\"&#125;, &#123; \"name\": \"Chuck\", \"address\": \"Main Road 989\"&#125;, &#123; \"name\": \"Viola\", \"address\": \"Sideway 1633\"&#125;]x=mycol.insert_many(mylist)print(x,inserted_ids)import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]mylist = [ &#123; \"name\": \"Amy\", \"address\": \"Apple st 652\"&#125;, &#123; \"name\": \"Hannah\", \"address\": \"Mountain 21\"&#125;, &#123; \"name\": \"Michael\", \"address\": \"Valley 345\"&#125;, &#123; \"name\": \"Sandy\", \"address\": \"Ocean blvd 2\"&#125;, &#123; \"name\": \"Betty\", \"address\": \"Green Grass 1\"&#125;, &#123; \"name\": \"Richard\", \"address\": \"Sky st 331\"&#125;, &#123; \"name\": \"Susan\", \"address\": \"One way 98\"&#125;, &#123; \"name\": \"Vicky\", \"address\": \"Yellow Garden 2\"&#125;, &#123; \"name\": \"Ben\", \"address\": \"Park Lane 38\"&#125;, &#123; \"name\": \"William\", \"address\": \"Central st 954\"&#125;, &#123; \"name\": \"Chuck\", \"address\": \"Main Road 989\"&#125;, &#123; \"name\": \"Viola\", \"address\": \"Sideway 1633\"&#125;]x=mycol.insert_many(mylist)print(x.inserted_ids)import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]x=mycol.find_one()print(x)import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]for x in mycol.find(): print(x)for x in mycol.find(&#123;&#125;,&#123;\"_id\":0,\"name\":1,\"address\":1&#125;): print(x)for x in mycol.find(&#123;&#125;,&#123;\"address\":0&#125;): print(x)for x in mycol.find(&#123;&#125;,&#123;\"name\":1,\"address\":0&#125;)import pymongomyclient=pymongo.MongoClient(\"mongodb://27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]myquery=&#123;\"address\":\"park lane 38\"&#125;mydoc=mycol.find(myquery)for x in mydoc: print(x)myquery=&#123;\"address\":&#123;\"$gt\":\"S\"&#125;&#125;mydoc=mycol.find(myquery)for x in mydoc: print(x)myquery=&#123;\"address\":&#123;\"$regex\":\"^S\"&#125;&#125;mydoc=mycol.find(myquery)for x in mydoc: print(x)import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]mydoc=mycol.find().sort(\"name\")for x in mydoc: print(x)mydoc=mydoc.find().sort(\"name\",-1)for x in mydoc: print(x)myquery=&#123;\"address\":\"Mountain 21\"&#125;mycol.delete_one(myquery)myquery=&#123;\"address\":&#123;\"$regex\":\"^S\"&#125;&#125;x=mycol.delete_many(myquery)print(x.delete_count,\"documents deleted.\")x=mycol.delete_many(&#123;&#125;)print(x.deleted_count,\"documents deleted.\")mycol.drop()import pymongomyclient=pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb=myclient[\"mydatabase\"]mycol=mydb[\"customers\"]myquery=&#123;\"address\":\"value 345\"&#125;newvalues=&#123;\"$set\":&#123;\"address\":\"Canyon 123\"&#125;&#125;mycol.update_one(myquery,newvalues)for x in mycol.find(): print(x)myquery = &#123; \"address\": &#123; \"$regex\": \"^S\" &#125; &#125;newvalues = &#123; \"$set\": &#123; \"name\": \"Minnie\" &#125; &#125;x=mycol.update_many(myquery,newvalues)print(x.modified_count,\"documents updated.\")myresult=mycol.find().limit(5)for x in myresult: print(x)","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://yanxigun99.github.io/tags/MongoDB/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python MYSQL day 16-2","slug":"study python 16day -2","date":"2020-01-03T12:00:01.000Z","updated":"2020-01-13T14:07:54.334Z","comments":true,"path":"2020/01/03/study python 16day -2/","link":"","permalink":"https://yanxigun99.github.io/2020/01/03/study%20python%2016day%20-2/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576select * from employeeswhere hire_date&#x3D;(select max(hire_date) from employees)select * from employeeswhere hire_date&#x3D;(select hire_date from employees order by hire_date desc limit 2,1)select s.*,d.dept_no from salaries s,dept_manager d where s.to_date&#x3D;&#39;9999-01-01&#39;and d.to_date&#x3D;&#39;9999-01-01&#39;and s.emp_no&#x3D;d.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from dept_emp inner join employeeswhere dept_emp.emp_no&#x3D;employees.emp_noselect employees.last_name,employees.first_name,dept_emp.dept_no from employeesleft join dept_emp on dept_emp.emp_no&#x3D;employees.emp_noselect e.emp_no,s.salary from salaries as s inner join employees as eon e.emp_no&#x3D;s.emp_no where e.hire_date&#x3D;s.from_dateorder by e.emp_no descselect emp_no,COUNT(emp_no) AS t from salaries GROUP BY emp_no HAVING t&gt;15select salary from salaries where to_date&#x3D;&#39;9999-01-01&#39; GROUP BY salary order by salary descselect d.dept_no,d.emp_no,s.salary from dept_manager as d inner join salaries as s on d.emp_no&#x3D;s.emp_no and d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;select emp_no from employees where emp_no not in(select emp_no from dept_manager)select de.emp_no,dm.emp_no as manager_no from dept_emp as deinner join dept_manager as dmon de.dept_no&#x3D;dm.dept_nowhere dm.to_date&#x3D;&#39;9999-01-01&#39;and de.to_date&#x3D;&#39;9999-01-01&#39;and de.emp_no&lt;&gt;dm.emp_noselect d.dept_no,s.emp_no,max(s.salary)as salary from dept_emp as d inner join salaries as s on d.emp_no&#x3D;s.emp_nowhere d.to_date&#x3D;&#39;9999-01-01&#39;and s.to_date&#x3D;&#39;9999-01-01&#39;group by d.dept_noselect title, count(title)as t from titlesgroup by title having t&gt;&#x3D;2select title,count(distinct emp_no)as t from titlesgroup by title having t&gt;&#x3D;2select * from employees where last_name&lt;&gt;&#39;Mary&#39; and emp_no%2&#x3D;1order by hire_date descselect t.title,avg(s.salary)as avg from titles as t inner join salaries as son t.emp_no&#x3D;s.emp_nowhere t.to_date&#x3D;&#39;9999-01-01&#39;and s.to_date&#x3D;&#39;9999-01-01&#39;group by t.titleselect emp_no,salary from salarieswhere to_date&#x3D;&#39;9999-01-01&#39;order by salary desc limit 1,1select e.emp_no,max(s.salary) as salary,e.last_name,e.first_name from employees as e inner join salaries as s on e.emp_no&#x3D;s.emp_nowhere s.to_date&#x3D;&#39;9999-01-01&#39;and s.salary not in(select max(salary) from salaries where to_date&#x3D;&#39;9999-01-01&#39;)select e.last_name,e.first_name,d.dept_name from(employees as e left join dept_emp as de on e.emp_no&#x3D;de.emp_no)left join departments as d on de.dept_no&#x3D;d.dept_noselect (max(salary)-min(salary))as growth from salaries where emp_no&#x3D;&#39;10001&#39;select a.emp_no,(b.salary-c.salary) as growthfrom employees as ainner join salaries as bon a.emp_no&#x3D;b.emp_no and b.to_date&#x3D;&#39;9999-01-01&#39;inner join salaries as c on a.emp_no&#x3D;c.emp_no and a.hire_date&#x3D;c.from_dateorder by growth","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://yanxigun99.github.io/tags/MYSQL/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python mysql day 16","slug":"study python 16day","date":"2020-01-02T12:00:01.000Z","updated":"2020-01-13T14:04:08.288Z","comments":true,"path":"2020/01/02/study python 16day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/02/study%20python%2016day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446#创建名为‘mydatabase’的数据库import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;CREATE DATABASE mydatabase&#39;)improt mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;SHOW DATABASES&#39;)for x in mycursor: print(x)import mysql.connectormydb&#x3D;mysql.connerctor.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;import mysql.connerctormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passed&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;CREATE TABLE customers(name VARCHAR(255)),address VARCHAR(255)&#39;))import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;SHOW TABLES&#39;)for x in mycursor: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.excute(&#39;CREATE TABLE customers(id INT AUTO_INCREMENT PRIMARY KEY,name VARCHAR(255),address VARCHAR(255))&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;ALTER TABLE customers ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;INSERT INTO customers(name,address) VALUES(%s,%s)&#39;val&#x3D;(&#39;john&#39;,&#39;highway 21&#39;)mycursor.execute(sql,val)mydb.commit()print(mycursor.rowcount,&#39;record inserted.&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;INSERT INTO customers(name, address) VALUES(%s,%s)&#39;val&#x3D;[ (&#39;Peter&#39;, &#39;Lowstreet 4&#39;), (&#39;Amy&#39;, &#39;Apple st 652&#39;), (&#39;Hannah&#39;, &#39;Mountain 21&#39;), (&#39;Michael&#39;, &#39;Valley 345&#39;), (&#39;Sandy&#39;, &#39;Ocean blvd 2&#39;), (&#39;Betty&#39;, &#39;Green Grass 1&#39;), (&#39;Richard&#39;, &#39;Sky st 331&#39;), (&#39;Susan&#39;, &#39;One way 98&#39;), (&#39;Vicky&#39;, &#39;Yellow Garden 2&#39;), (&#39;Ben&#39;, &#39;Park Lane 38&#39;), (&#39;William&#39;, &#39;Central st 954&#39;), (&#39;Chuck&#39;, &#39;Main Road 989&#39;), (&#39;Viola&#39;, &#39;Sideway 1633&#39;)]mycursor.executemany(sql,val)mydb.commit()print(mycursor.rowcount,&#39;was inserted.&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;INSERT INTO customers(name,address)VALUES(%s,%s)&#39;val&#x3D;(&#39;Michelle&#39;,&#39;blue village&#39;)mycursor.execute(sql,val)mydb.commit()print(&#39;1 record inserted,ID:&#39;,mycursor.lastrowid)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;SELECT * FROM customers&#39;)myresult&#x3D;mycursor.fetchall()for i in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursot.execute(&#39;SELECT name,address FROM customers&#39;)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(SELECT *FROM customers)result&#x3D;mycursor.fetchone()print(myresult)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;SELECT * FRON customers WHERE address&#x3D;&#39;park lane 38&#39;&#39;mycursor.exeute(sql)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;SELECT * FROM customers WHERE address LIKE &#39;%way%&#39;&#39;mycursor.execute(sql)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;SELECT *FROM customers WHERE address&#x3D;%s&#39;adr&#x3D;(&#39;Yellow Garden 2&#39;)mycursor.execute(sql,adr)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;SELECT * FROM customers ORDER BY name&#39;mycursor.execute(sql)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;SELECT *FROM customers ORDER BY name DESC&#39;mycursor.execute(sql)myresult-mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;DELETE FROM customers WHERE address&#x3D;&#39;mountain 21&#39;&#39;mycursor.execute(sql)mydb.commit()print(mycursor.rowcount,&#39;record(s) deleted&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;DELETE FROM customers WHERE address&#x3D;%s&#39;adr&#x3D;(&#39;yellow garden 2&#39;,)mycursor.execute(sql,adr)mydb.commit()print(mycursor.rowcount,&#39;record(s) deleted&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;DROP TABLE customers&#39;mycursor.execute(sql)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;DROP TABLE IF EXISTS customers&#39;mycursor.execute(sql)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;UPDATE customers SET address&#x3D;&#39;canyon 123&#39; WHERE address&#x3D;&#39;value 345&#39;&#39;mycursor.execute(sql)mydb.commit()print(mycurtor.rowcount,&#39;record(s) affacted&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&#39;UPDATE customers SET address&#x3D;%s WHERE address&#x3D;%s&#39;val&#x3D;(&#39;valley 345&#39;,&#39;canyon 123&#39;)mycursor.execute(sql,val)mybd.commit()print(mycursor.rowcount,&#39;record(s) affected&#39;)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;SELECT * FROM customers LIMIT 5&#39;)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()mycursor.execute(&#39;SELECT * FROM customers LIMIT 5 OFFSET 2&#39;)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)import mysql.connectormydb&#x3D;mysql.connector.connect( host&#x3D;&#39;localhost&#39; user&#x3D;&#39;yourusername&#39; passwd&#x3D;&#39;yourpassword&#39; database&#x3D;&#39;mydatabase&#39;)mycursor&#x3D;mydb.cursor()sql&#x3D;&quot;SELECT users.name AS user, products.name AS favorite FROM users INNER JOIN productes ON users.fav&#x3D;products.id&quot;mycursor.execute(sql)myresult&#x3D;mycursor.fetchall()for x in myresult: print(x)sql&#x3D;&#39;SELECT users.name AS user,products.name AS favorite FROM users LEFT JOIN products ON users.fav&#x3D;products.id&#39;sql&#x3D;&quot;SELECT\\users.name AS user,\\products.name AS favorite\\FROM users\\RIGHT JOIN products ON users.fav&#x3D;products.id&quot;","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://yanxigun99.github.io/tags/mysql/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 15","slug":"study python 15day","date":"2020-01-02T12:00:01.000Z","updated":"2020-01-13T14:02:32.549Z","comments":true,"path":"2020/01/02/study python 15day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/02/study%20python%2015day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330l,r=map(int,input().split())#除以3的余数100100100100if l%3==2: flagl=1else: flagl=0if r%3==2: flagr=1else: flagr=0str1=(l-1)//3*2+flaglstr2=r//3*2+flagrprint(str2-str1)t=int(input())for i in range(t): n=int(input()) s=input() j=0 answer=0 while j&lt;n: if s[j]=='.': answer+=1 j+=3 else: j+=1 print(answer)n=int(input())s=input()l=0r=0str1=['N','E','S','W']str2=['N','W','S','E']for i in s: if i=='L': l+=1 else: r+=1if l&gt;r: print(str2[(l-r)%4])elif r&gt;l: print(str1[(r-l)%4])else: print('N')n,k=map(int,input().split())count=0for x in range(1,n+1): for y in range(k+1,n+1): if x%y&gt;=k: count+=1print(count)def gcd(a, b): \"\"\"Return greatest common divisor using Euclid's Algorithm.\"\"\" while b: a, b = b, a % b return adef lcm(a, b): \"\"\"Return lowest common multiple.\"\"\" return a * b // gcd(a, b)while True: try: a,b=map(int,input().split()) print(lcm(a,b)) except: breakdef lifang(n): return n**(1/3)n=float(input())print('%0.1f'%lifang(n))str=input()print(str[::-1])a,zheng,fu=input().split(),[],[]for i in a: fu.append(int(i)) if int(i)&lt;0 else zheng.append(int(i))count=len(fu)print(count)print(round(sum(zheng)/len(zheng),1)if zheng else \"0.0\")while True: try: n=int(input()) for i in range(n): s=input() while len(s)&gt;8: print(s[:8]) s=s[8:] print(s.ljust(8,'0')) except: breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakwhile True: try: a,b,c=input(),map(int,input().split()),input() print(\" \".join(map(str,sorted(b))) if c==\"0\" else \" \".join(map(str,sorted(b,reverse=True)))) except:breakwhile True: try: n=int(input()) data_list=map(int,input().split()) num=0 res=0 geshu=0 for i in data_list: if i&gt;0: num+=1 res+=i elif i&lt;0: geshu+=1 res = res/num print(\"%d %.1f\"%(geshu,res)) except: breakwhile True: try: n=int(input()) count=0 for i in range(0,n+1): a=i**2 if i==a%(10**len(str(i))): count+=1 print(count) except: breakwhile True: try: n=int(input()) ans=0 for i in range(n): ans+=2+3*i print(ans) except: #print('-1') breakwhile True: try: a,b,c=input(),map(int,input().split()),input() if c=='0': print(' '.join(map(str,sorted(b))) else: print(' '.join(map(str,sorted(b,reverse=True)))) except: breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakdef longestPalindrome(s): if s==s[::-1]:return len(s) maxLen=0 for i in range(len(s)): if i-maxLen&gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]: maxLen+=2 continue if i-maxLen&gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]: maxLen+=1 return maxLenwhile True: try: a=input() if a: print(longestPalindrome(a)) except: breakwhile True: try: n, curNum = int(input()), 1 res = [[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(i + 1): res[i - j][j] = curNum curNum += 1 for i in res: print(\" \".join(map(str, (filter(lambda i: i != 0, i))))) except: breakwhile True: try: #key，string分别代表输入的key的加要密的字符串 #chars是密钥对应的字母表，res是要返回的结果。 key, string, chars, res = input(), input(), [], \"\" #经过下面的循环，chars前面几个是密匙的字母 for i in key: if i not in chars: chars.append(i) #如果输入的key中有小写字母，转为大写字母。 chars = list(map(lambda c: c.upper(), chars)) #剩下的字母，填充到chars里面。 for i in range(65, 91): if chr(i) not in chars: chars.append(chr(i)) # 将输入加密。 for i in string: if i.isupper(): res += chars[ord(i) - 65] elif i.islower(): res += chars[ord(i) - 97].lower() else: res += i print(res) except: break# -*- coding: utf-8 -*-# !/usr/bin/python3# 解题思路：动态规划dp[i][j]表示st1[0:j - 1]和st2[0:i - 1]的最小距离；# 那么st1和st2的距离与dp[i][j], dp[i - 1][j]和dp[i][j - 1]有关；# 如果st1[j] == st2[i], dp[i + 1][j + 1] = dp[i - 1][j - 1];# 如果st1[j] != st2[i], dp[i + 1][j + 1] = min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1);# 边界条件：第0行和第0列表示空字符串分别于st1和st2的子字符串的距离，dp[i][0] = i, dp[0][j] = j while True: try: st1 = input() st2 = input() if len(st1) &lt; len(st2): st1, st2 = st2, st1 m = len(st1) n = len(st2) res = [[0 for i in range(m + 1)] for i in range(n + 1)] for i in range(n + 1): res[i][0] = i for j in range(m + 1): res[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if st1[j - 1] == st2[i - 1]: res[i][j] = res[i - 1][j - 1] else: res[i][j] = min(res[i - 1][j - 1] + 1, res[i - 1][j] + 1, res[i][j - 1] + 1) print(res[n][m]) except: breakimport sys while True: try: string = sys.stdin.readline() line = int(string) if line == 1 or line == 2: print(-1) elif line == 3: print(2) elif line%4==1 or line%4==3: print(2) elif line%4==2: print(4) else: print(3) except: break#找规律吧，小伙伴们~while True: try: a=int(input()) count=0 for i in range(1,a+1): if i%7==0: count+=1 elif '7' in str(i): count+=1 else: continue print(int(count)) except: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python Mysql day 14-1","slug":"study python 14day-1","date":"2020-01-01T12:00:01.000Z","updated":"2020-01-13T13:57:50.839Z","comments":true,"path":"2020/01/01/study python 14day-1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/01/study%20python%2014day-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404倒数第三个员工信息SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1;LIMIT m,n : 表示从第m+1条开始，取n条数据；LIMIT n ： 表示从第0条开始，取n条数据，是limit(0,n)的缩写薪资涨15次以上的SELECT emp_no, COUNT(emp_no) AS t FROM salaries GROUP BY emp_no HAVING t &gt; 15去重当前薪资SELECT DISTINCT salary FROM salariesWHERE to_date &#x3D; &#39;9999-01-01&#39; ORDER BY salary DESC不是经理的员工SELECT emp_no FROM employeesWHERE emp_no NOT IN (SELECT emp_no FROM dept_manager)title进行分组，显示大于2的组SELECT title, COUNT(title) AS t FROM titlesGROUP BY title HAVING t &gt;&#x3D; 2同上，忽略重复的emp_noSELECT title, COUNT(DISTINCT emp_no) AS t FROM titlesGROUP BY title HAVING t &gt;&#x3D; 2当前各个title类对应的员工平均薪资SELECT title , AVG(salary) AS avgFROM salaries s,titles tWHERE s.emp_no &#x3D; t.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; AND t.to_date &#x3D; &#39;9999-01-01&#39;GROUP BY t.title;查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growthSELECT (MAX(salary)-MIN(salary)) AS growth FROM salaries WHERE emp_no &#x3D; &#39;10001&#39;查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_noy以及其对应的薪水涨幅growth，并按照growth进行升序select a.emp_no, (b.salary - c.salary) as growthfrom employees as a inner join salaries as b on a.emp_no &#x3D; b.emp_no and b.to_date &#x3D; &#39;9999-01-01&#39; inner join salaries as c on a.emp_no &#x3D; c.emp_no and a.hire_date &#x3D; c.from_dateorder by growth asc统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sumSELECT de.dept_no, dp.dept_name, COUNT(s.salary) AS sum FROM (dept_emp AS de INNER JOIN salaries AS s ON de.emp_no &#x3D; s.emp_no) INNER JOIN departments AS dp ON de.dept_no &#x3D; dp.dept_no GROUP BY de.dept_no对所有员工的当前(to_date&#x3D;&#39;9999-01-01&#39;)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rankFROM salaries AS s1, salaries AS s2WHERE s1.to_date &#x3D; &#39;9999-01-01&#39; AND s2.to_date &#x3D; &#39;9999-01-01&#39; AND s1.salary &lt;&#x3D; s2.salaryGROUP BY s1.emp_noORDER BY s1.salary DESC, s1.emp_no ASC获取员工其当前的薪水比其manager当前薪水还高的相关信息，SELECT sem.emp_no AS emp_no, sdm.emp_no AS manager_no, sem.salary AS emp_salary, sdm.salary AS manager_salaryFROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries s INNER JOIN dept_emp deON s.emp_no &#x3D; de.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sem, (SELECT s.salary, s.emp_no, dm.dept_no FROM salaries s INNER JOIN dept_manager dmON s.emp_no &#x3D; dm.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39; ) AS sdmWHERE sem.dept_no &#x3D; sdm.dept_no AND sem.salary &gt; sdm.salary汇总各个部门当前员工的title类型的分配数目SELECT de.dept_no, dp.dept_name, t.title, COUNT(t.title) AS countFROM titles AS t INNER JOIN dept_emp AS de ON t.emp_no &#x3D; de.emp_no AND de.to_date &#x3D; &#39;9999-01-01&#39; AND t.to_date &#x3D; &#39;9999-01-01&#39;INNER JOIN departments AS dp ON de.dept_no &#x3D; dp.dept_noGROUP BY de.dept_no, t.title给出每个员工每年薪水涨幅超过5000的员工SELECT s2.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growthFROM salaries AS s1, salaries AS s2WHERE s1.emp_no &#x3D; s2.emp_no AND salary_growth &gt; 5000AND (strftime(&quot;%Y&quot;,s2.to_date) - strftime(&quot;%Y&quot;,s1.to_date) &#x3D; 1 OR strftime(&quot;%Y&quot;,s2.from_date) - strftime(&quot;%Y&quot;,s1.from_date) &#x3D; 1 )ORDER BY salary_growth DESC获取select * from employees对应的执行计划EXPLAIN SELECT * FROM employees将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分SELECT last_name||&quot; &quot;||first_name AS Name FROM employees创建表CREATE TABLE actor(actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&#39;now&#39;,&#39;localtime&#39;)) -- ,-- PRIMARY KEY(actor_id))插入数据INSERT INTO actorVALUES (1, &#39;PENELOPE&#39;, &#39;GUINESS&#39;, &#39;2006-02-15 12:34:33&#39;),(2, &#39;NICK&#39;, &#39;WAHLBERG&#39;, &#39;2006-02-15 12:34:33&#39;)对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作INSERT OR IGNORE INTO actor VALUES (3, &#39;ED&#39;, &#39;CHASE&#39;, &#39;2006-02-15 12:34:33&#39;)INSERT OR REPLACE INTO actor VALUES (3, &#39;ED&#39;, &#39;CHASE&#39;, &#39;2006-02-15 12:34:33&#39;)创建新表导入数据INSERT INTO actor_name SELECT first_name,last_name FROM actor;对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastnameCREATE UNIQUE INDEX uniq_idx_firstname ON actor(first_name);CREATE INDEX idx_lastname ON actor(last_name);针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，fist_name为first_name_v，last_name修改为last_name_v：CREATE VIEW actor_name_view ASSELECT first_name AS fist_name_v, last_name AS last_name_vFROM actor针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no &#x3D; 10005新增加一列ALTER TABLE actor ADD COLUMN create_date datetime构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中CREATE TRIGGER audit_log AFTER INSERT ON employees_testBEGIN INSERT INTO audit VALUES(NEW.ID,NEW.NAME);END;删除emp_no重复的记录，只保留最小的id对应的记录DELETE FROM titles_test WHERE id NOT IN (SELECT MIN(id) FROM titles_test GROUP BY emp_no)将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01update titles_test set to_date&#x3D;null ,from_date &#x3D;&#39;2001-01-01&#39;where to_date&#x3D;&#39;9999-01-01&#39;将titles_test表名修改为titles_2017ALTER TABLE titles_test RENAME TO titles_2017在audit表上创建外键约束，其emp_no对应employees_test表的主键idDROP TABLE audit;CREATE TABLE audit( EMP_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(EMP_no) REFERENCES employees_test(ID));将所有获取奖金的员工当前的薪水增加10%UPDATE salaries SET salary &#x3D; salary * 1.1 WHERE emp_no IN(SELECT s.emp_no FROM salaries AS s INNER JOIN emp_bonus AS eb ON s.emp_no &#x3D; eb.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39;)针对库中的所有表生成select count(*)对应的SQL语句SELECT &quot;select count(*) from &quot; || name || &quot;;&quot; AS cntsFROM sqlite_master WHERE type &#x3D; &#39;table&#39;查找字符串&#39;10,A,B&#39; 中逗号&#39;,&#39;出现的次数cnt。SELECT (length(&quot;10,A,B&quot;)-length(replace(&quot;10,A,B&quot;,&quot;,&quot;,&quot;&quot;)))&#x2F;length(&quot;,&quot;) AS cnt获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列SELECT first_name FROM employees ORDER BY substr(first_name,length(first_name)-1)按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接SELECT dept_no, group_concat(emp_no) AS employeesFROM dept_emp GROUP BY dept_no查找排除当前最大、最小salary之后的员工的平均工资avg_salaryELECT AVG(salary) AS avg_salary FROM salaries WHERE to_date &#x3D; &#39;9999-01-01&#39; AND salary NOT IN (SELECT MAX(salary) FROM salaries)AND salary NOT IN (SELECT MIN(salary) FROM salaries)使用含有关键字exists查找未分配具体部门的员工的所有信息exists关键字:强调的是是否返回结果集，不要求知道返回什么。只要返回了字段，就是真select * from employees ee where not exists ( select emp_no from dept_emp de where de.emp_no &#x3D; ee.emp_no)奖金运算SELECT e.emp_no, e.first_name, e.last_name, b.btype, s.salary, (CASE b.btype WHEN 1 THEN s.salary * 0.1 WHEN 2 THEN s.salary * 0.2 ELSE s.salary * 0.3 END) AS bonusFROM employees AS e INNER JOIN emp_bonus AS b ON e.emp_no &#x3D; b.emp_noINNER JOIN salaries AS s ON e.emp_no &#x3D; s.emp_no AND s.to_date &#x3D; &#39;9999-01-01&#39;按照salary的累计和running_total，其中running_total为前所有员工的salary累计和，其他以此类推。 具体结果如下Demo展示SELECT s1.emp_no, s1.salary, (SELECT SUM(s2.salary) FROM salaries AS s2 WHERE s2.emp_no &lt;&#x3D; s1.emp_no AND s2.to_date &#x3D; &#39;9999-01-01&#39;) AS running_total FROM salaries AS s1 WHERE s1.to_date &#x3D; &#39;9999-01-01&#39;对于employees表中，给出奇数行的first_nameSELECT e1.first_name FROM (SELECT e2.first_name, (SELECT COUNT(*) FROM employees AS e3 WHERE e3.first_name &lt;&#x3D; e2.first_name) AS rowid FROM employees AS e2) AS e1WHERE e1.rowid % 2 &#x3D; 1","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 14-1","slug":"study python 14day -1","date":"2020-01-01T12:00:01.000Z","updated":"2020-01-13T14:01:02.906Z","comments":true,"path":"2020/01/01/study python 14day -1/","link":"","permalink":"https://yanxigun99.github.io/2020/01/01/study%20python%2014day%20-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375#!/usr/bin/python#冒泡排序1def bubblesort(a,n): for i in range(n): for j in range(1,n-i): if(a[j-1]&gt;a[j]): a[j-1],a[j]=a[j],a[j-1]#冒泡排序2def bubblesort2(a,n): flag=True k=n while flag: flag=False for j in range(1,k): if (a[j-1]&gt;a[j]): a[j-1],a[j]=a[j],a[j-1] flag=True k-=1 #冒泡排序3def bubblesort3(a,n): flag=n while flag&gt;0: k=flag flag=0 for j in range(1,k): if(a[j-1]&gt;a[j]): a[j-1],a[j]=a[j],a[j-1] flag=j #直接插入排序1def insertsort1(a,n): for i in range(1,n): for j in range(i-1,-1,-1): if(a[j]&lt;a[i]): break if(j!=i-1): temp=a[i] for k in range(i-1,j,-1): a[k+1]=a[k] a[k+1]=temp #直接插入排序2def insertsort2(a,n): for i in range(1,n): if(a[i]&lt;a[i-1]): temp=a[i] for j in range(i-1,-1,-1): a[j+1]=a[j] a[j+1]=temp#直接插入排序3def insertsort3(a,n): for i in range(1,n): for j in range(i-1,-1,-1): if(a[j]&gt;a[j+1]): a[j],a[j+1]=a[j+1],a[j] #希尔排序def shellsort1(a,n): for gap in range(n/2,0,/2): for i in range(0,gap): for j in range(i+gap,n,gap): if(a[j]&lt;a[j-gap]): temp=a[j] k=j-gap while k&gt;=0 and a[k]&gt;temp: a[k+gap]=a[k] k-=gap a[k+gap]=temp #希尔排序2def sheelsort2(a,n): for gap in range(n/2,0,/2): for j in range(gap,n): if(a[j]&lt;a[j-gap]): temp=a[j] k=j-gap while k&gt;=0 and a[k]&gt;temp: a[k+gap]=a[k] k-=gap a[k+gap]=temp #希尔排序3def sheelsort3(a,n): for gap in range(n/2,0,/2): for i in range(gap,n): for j in range(i-gap,-1,-gap): if(a[j]&gt;a[j+gap]): a[j],a[j+gap]=a[j+gap],a[j] #直接选择排序1def selectsort1(a,n): for i in range(n): nmin=i for j in range(i+1,n): if(a[j]&lt;a[nmin]): nmin=j a[i],a[nmin]=a[nmin],a[i] #归并排序def mergesort(li): if len(li)==1: return li mid=len(li)//2 left=li[:mid] right=li[mid:] l1=mergesort(left) r1=mergesort(right) return merge(l1,r1)def merge(left,right): result=[] while len(left)&gt;0 and len(right)&gt;0: if left[0]&lt;=right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) result+=left result+=right return result#快速排序def quicksort(arr): if len(arr)&lt;=1: return arr pivot=arr[len(arr)//2] left=[x for x in arr if x&lt;pivot] right=[x for x in arr if x&gt;pivot] middle=[x for x in arr if x==pivot] return quicksort(left)+middle+quicksort(right)#堆排序def heapify(arr,n,i): largest=i l=2*i+1 r=2*i+2 if l&lt;n and arr[i]&lt;arr[r]: largest=l if r&lt;n and arr[largest]&lt;arr[r]: largest=r if largest!=i: arr[i],arr[largest]=arr[largest],arr[i] heapify(arr,n,largest) def heapsort(arr): n=len(arr) for i in range(n,-1,-1): heapify(arr,n,i) for i in range(n-1,0,-1): arr[i],arr[0]=arr[0],arr[i] heapify(arr,i,0) import syswhile True: try: s = sys.stdin.readline().strip() a = int(s.split()[0]) b = int(s.split()[1]) m=a n=b while(a!=b): if a&gt;b: a=a-b else: b=b-a print(int(m*n/a)) except Exception: breakdef lifang(a): a=float(a) return a**(1/3) b=input()print('%0.1f'%lifang(b))while True: try: inlist=list(map(int,input().split())) fushu=[] zhengshu=[] for i in inlist: if i&lt;0: fushu.append(i) else: zhengshu.append(i) print(len(fushu)) zhengshu_len=len(zhengshu) sum=0 if zhengshu_len==0: print('0.0') else: for j in zhengshu: sum+=j print(round((sum/zhengshu_len),1 )) except: breakwhile True: try: a = int(input()) for i in range(a): s = input() while len(s)&gt;8: print(s[:8]) s = s[8:] print(s.ljust(8,'0')) except: breakimport bisectwhile True: try: n = int(input()) l = map(int,input().split()) b = [] res = [] for i in l: pos = bisect.bisect_left(b,i) res+=[pos+1] if pos == len(b): b.append(i) else: b[pos]=i print(len(b)) #print(res) except: breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakwhile True: try: a,b,c=input(),map(int,input().split()),input() print(\" \".join(map(str,sorted(b))) if c==\"0\" else \" \".join(map(str,sorted(b,reverse=True)))) except:breakwhile True: try: n=eval(input()) num=0 for i in range(n): num+=2+3*i print(num) except:# print(-1) breakwhile True: try: n = int(input()) c = 0 for i in range(0,n+1): m = (i*i)%(10**len(str(i))) if m == i : c+=1 print(c) except: breakimport syswhile True: try: priceGoods = &#123;'A1':2, 'A2':3, 'A3':4, 'A4':5, 'A5':8, 'A6':6&#125; priceMoney = [1 , 2 , 5 , 10] numGoods = &#123;'A1':0, 'A2':0, 'A3':0, 'A4':0, 'A5':0, 'A6':0&#125; numMoney = [0] * 4 balance = 0 def printMoney(line): print ('1 yuan coin number=%s' % (line[0])) print ('2 yuan coin number=%s' % (line[1])) print ('5 yuan coin number=%s' % (line[2])) print ('10 yuan coin number=%s' % (line[3])) def printGoods(priceGoods,numGoods,flag):# 0:sorted goods name;1:sorted num of goods if flag == 0: for i in range(6): good = 'A'+str(i+1) print (good+' '+str(priceGoods[good])+' '+str(numGoods[good])) if flag == 1: #print (numGoods) numGoodsSorted = sorted(numGoods.items(),key = lambda a:a[1],reverse = True) for i in range(6): print (numGoodsSorted[i][0]+' '+str(priceGoods[numGoodsSorted[i][0]])+' '+str(numGoodsSorted[i][1])) line = input().split(';')[:-1] for i in line: func = i.split() if func[0] == 'r': func[1] = func[1].split('-') for i in range(6): numGoods['A'+str(i+1)] += int(func[1][i]) for i in range(4): numMoney[i] += int(func[2].split('-')[i]) #1 2 5 10 print ('S001:Initialization is successful') elif func[0] == 'p': if int(func[1]) not in priceMoney: print ('E002:Denomination error') elif int(func[1]) in [5,10] and numMoney[0] + numMoney[1] * 2 &lt; int(func[1]): print ('E003:Change is not enough, pay fail') elif int(func[1]) == 10 and balance &gt; 10:# only print when $10 input print ('E004:Pay the balance is beyond the scope biggest') elif numGoods['A1'] == numGoods['A2'] == numGoods['A3'] == numGoods['A4'] == numGoods['A5'] == numGoods['A6'] == 0: print ('E005:All the goods sold out') else: numMoney[priceMoney.index(int(func[1]))] += 1 balance += int(func[1]) print ('S002:Pay success,balance=%d'%(balance)) elif func[0] == 'b': if func[1] not in ['A1','A2','A3','A4','A5','A6']: print ('E006:Goods does not exist') elif numGoods[func[1]] == 0: print ('E007:The goods sold out') elif balance &lt; priceGoods[func[1]]: print ('E008:Lack of balance') else: balance -= priceGoods[func[1]] numGoods[func[1]] -= 1 print ('S003:Buy success,balance=%d'%(balance)) elif func[0] == 'c': if balance == 0: sys.stdout.write('E009:Work failure')#no line break else: numCall = [0] * 4 #1 2 5 10 for i in range(-1,-5,-1): numCall[i] = min(balance // priceMoney[i] , numMoney[i]) balance -= numCall[i] * priceMoney[i] numMoney[i] -= numCall[i] printMoney(numCall) balance = 0 elif func[0] == 'q': if func[1] == '0': printGoods(priceGoods,numGoods,1) elif func[1] == '1': printMoney(numMoney) else: sys.stdout.write('E010:Parameter error')#no line break except: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 排序 学习网站 day 14","slug":"study python 14day","date":"2020-01-01T12:00:00.000Z","updated":"2020-01-13T13:59:41.663Z","comments":true,"path":"2020/01/01/study python 14day/","link":"","permalink":"https://yanxigun99.github.io/2020/01/01/study%20python%2014day/","excerpt":"","text":"小白排序：URL:click W3school：URL:click 菜鸟教程：URL:click 在线编程工具：URL:click 正则表达式实例：URL:click 正则表达式语法规则：URL:click","categories":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/categories/python/"}]},{"title":"python time and datetime day 13-2","slug":"study python 13day -2","date":"2019-12-31T12:00:01.000Z","updated":"2020-01-13T13:45:32.873Z","comments":true,"path":"2019/12/31/study python 13day -2/","link":"","permalink":"https://yanxigun99.github.io/2019/12/31/study%20python%2013day%20-2/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677一、time的常用方法：import time,datetime# 时间有三种展现方式：时间戳，时间元组，格式化的时间print(time.time())#当前时间戳print(int(time.time()))print(time.strftime('%Y-%m-%d %H:%M:%S'))#格式化的时间print(time.strftime('%Y-%m-%d'))print(time.strftime('%H:%M:%S'))print(time.mktime())#获取标准时区的时间元组，如果传入了时间戳，就是把时间戳转换成时间元组print(time.mktime(1516194265))执行结果：1516197631.056301815161976312018-01-17 22:00:312018-01-1722:00:31time.struct_time(tm_year=2018, tm_mon=1, tm_mday=17, tm_hour=14, tm_min=0, tm_sec=31, tm_wday=2, tm_yday=17, tm_isdst=0)time.struct_time(tm_year=2018, tm_mon=1, tm_mday=17, tm_hour=13, tm_min=4, tm_sec=25, tm_wday=2, tm_yday=17, tm_isdst=0)二、 datetime常用方法：# 使用datetime和time获取当前时间now1 = datetime.datetime.now()now2=time.strftime('%Y-%m-%d %H:%M:%S')print(now1)print(now2)now = datetime.datetime.now()d1 = now - datetime.timedelta(hours=1)#获取前一小时d2 = now - datetime.timedelta(days=1)#获取前一天print(now)print(d1)执行结果：2018-01-17 22:03:04.6869232018-01-17 22:03:042018-01-17 22:03:04.6874862018-01-17 21:03:04.687486三、使用datetime获取代码执行的时长# 使用时间戳获取代码执行时间s_time = time.time()for i in range(0,10): time.sleep(1)e_time=time.time()print('代码运行时间是：',e_time - s_time)执行结果：代码运行时间是： 10.003105163574219四、时间戳和字符串的互相转化# 字符串格式化时间转换时间戳str_time = '2018-1-17'print(time.mktime(time.strptime(str_time,'%Y-%m-%d')))# 时间戳转换成格式化的时间字符串gsh_time= time.time()print(time.strftime('%Y-%m-%d',time.localtime(gsh_time)))# datetime对象转换成时间戳dt = datetime.datetime.now()print(time.mktime(dt.timetuple()))# 时间戳转换成datetime对象sjc_time = time.time()print(datetime.datetime.fromtimestamp(sjc_time))执行结果：1516118400.02018-01-171516198008.02018-01-17 22:06:48.944055","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python list day 13-1","slug":"study python 13day - 1","date":"2019-12-31T12:00:01.000Z","updated":"2020-01-13T13:44:23.891Z","comments":true,"path":"2019/12/31/study python 13day - 1/","link":"","permalink":"https://yanxigun99.github.io/2019/12/31/study%20python%2013day%20-%201/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152Python list 常用操作Python3 实例1.list 定义实例&gt;&gt;&gt; li = [\"a\", \"b\", \"mpilgrim\", \"z\", \"example\"]&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'z', 'example']&gt;&gt;&gt; li[1] 'b'2.list 负数索引实例&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'z', 'example']&gt;&gt;&gt; li[-1]'example'&gt;&gt;&gt; li[-3]'mpilgrim'&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'z', 'example']&gt;&gt;&gt; li[1:3] ['b', 'mpilgrim']&gt;&gt;&gt; li[1:-1]['b', 'mpilgrim', 'z']&gt;&gt;&gt; li[0:3] ['a', 'b', 'mpilgrim']3.list 增加元素实例&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'z', 'example']&gt;&gt;&gt; li.append(\"new\")&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'z', 'example', 'new']&gt;&gt;&gt; li.insert(2, \"new\")&gt;&gt;&gt; li['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new']&gt;&gt;&gt; li.extend([\"two\", \"elements\"])&gt;&gt;&gt; li['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']4.list 搜索实例&gt;&gt;&gt; li['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']&gt;&gt;&gt; li.index(\"example\")5&gt;&gt;&gt; li.index(\"new\")2&gt;&gt;&gt; li.index(\"c\")Traceback (innermost last): File \"&lt;interactive input&gt;\", line 1, in ?ValueError: list.index(x): x not in list&gt;&gt;&gt; \"c\" in liFalse5.list 删除元素实例&gt;&gt;&gt; li['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']&gt;&gt;&gt; li.remove(\"z\") &gt;&gt;&gt; li['a', 'b', 'new', 'mpilgrim', 'example', 'new', 'two', 'elements']&gt;&gt;&gt; li.remove(\"new\") # 删除首次出现的一个值&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'example', 'new', 'two', 'elements'] # 第二个 'new' 未删除&gt;&gt;&gt; li.remove(\"c\") #list 中没有找到值, Python 会引发一个异常Traceback (innermost last): File \"&lt;interactive input&gt;\", line 1, in ?ValueError: list.remove(x): x not in list&gt;&gt;&gt; li.pop() # pop 会做两件事: 删除 list 的最后一个元素, 然后返回删除元素的值。'elements'&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'example', 'new', 'two']6.list 运算符实例&gt;&gt;&gt; li = ['a', 'b', 'mpilgrim']&gt;&gt;&gt; li = li + ['example', 'new']&gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'example', 'new']&gt;&gt;&gt; li += ['two'] &gt;&gt;&gt; li['a', 'b', 'mpilgrim', 'example', 'new', 'two']&gt;&gt;&gt; li = [1, 2] * 3&gt;&gt;&gt; li[1, 2, 1, 2, 1, 2]7.使用join链接list成为字符串实例&gt;&gt;&gt; params = &#123;\"server\":\"mpilgrim\", \"database\":\"master\", \"uid\":\"sa\", \"pwd\":\"secret\"&#125;&gt;&gt;&gt; [\"%s=%s\" % (k, v) for k, v in params.items()]['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']&gt;&gt;&gt; \";\".join([\"%s=%s\" % (k, v) for k, v in params.items()])'server=mpilgrim;uid=sa;database=master;pwd=secret'join 只能用于元素是字符串的 list; 它不进行任何的类型强制转换。连接一个存在一个或多个非字符串元素的 list 将引发一个异常。8.list 分割字符串实例&gt;&gt;&gt; li = ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']&gt;&gt;&gt; s = \";\".join(li)&gt;&gt;&gt; s'server=mpilgrim;uid=sa;database=master;pwd=secret'&gt;&gt;&gt; s.split(\";\") ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']&gt;&gt;&gt; s.split(\";\", 1)['server=mpilgrim', 'uid=sa;database=master;pwd=secret']split 与 join 正好相反, 它将一个字符串分割成多元素 list。注意, 分隔符 (\";\") 被完全去掉了, 它没有在返回的 list 中的任意元素中出现。split 接受一个可选的第二个参数, 它是要分割的次数。9.list 的映射解析实例&gt;&gt;&gt; li = [1, 9, 8, 4]&gt;&gt;&gt; [elem*2 for elem in li] [2, 18, 16, 8]&gt;&gt;&gt; li[1, 9, 8, 4]&gt;&gt;&gt; li = [elem*2 for elem in li]&gt;&gt;&gt; li[2, 18, 16, 8]10.dictionary 中的解析实例&gt;&gt;&gt; params = &#123;\"server\":\"mpilgrim\", \"database\":\"master\", \"uid\":\"sa\", \"pwd\":\"secret\"&#125;&gt;&gt;&gt; params.keys()dict_keys(['server', 'database', 'uid', 'pwd'])&gt;&gt;&gt; params.values()dict_values(['mpilgrim', 'master', 'sa', 'secret'])&gt;&gt;&gt; params.items()dict_items([('server', 'mpilgrim'), ('database', 'master'), ('uid', 'sa'), ('pwd', 'secret')])&gt;&gt;&gt; [k for k, v in params.items()]['server', 'database', 'uid', 'pwd']&gt;&gt;&gt; [v for k, v in params.items()]['mpilgrim', 'master', 'sa', 'secret']&gt;&gt;&gt; [\"%s=%s\" % (k, v) for k, v in params.items()]['server=mpilgrim', 'database=master', 'uid=sa', 'pwd=secret']11.list 过滤实例&gt;&gt;&gt; li = [\"a\", \"mpilgrim\", \"foo\", \"b\", \"c\", \"b\", \"d\", \"d\"]&gt;&gt;&gt; [elem for elem in li if len(elem) &gt; 1]['mpilgrim', 'foo']&gt;&gt;&gt; [elem for elem in li if elem != \"b\"]['a', 'mpilgrim', 'foo', 'c', 'd', 'd']&gt;&gt;&gt; [elem for elem in li if li.count(elem) == 1]['a', 'mpilgrim', 'foo', 'c']","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 13","slug":"study python 13day","date":"2019-12-31T12:00:01.000Z","updated":"2020-01-13T13:42:38.503Z","comments":true,"path":"2019/12/31/study python 13day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/31/study%20python%2013day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517for i in range(1,1001): n=len(str(i)) sum=0 temp=i while temp&gt;0: digit=temp%10 sum+=digit**n temp//=10 if sum==i: print('&#123;0&#125;是阿姆斯特朗数'.format(i)) else: print('&#123;0&#125;不是阿姆斯特朗数'.format(i))n=34print('十进制数是：',n)print('二进制数是：',bin(n))print('八进制数是：',oct(n))print('十六进制数是：',hex(n))c = input(\"请输入一个字符: \") # 用户输入ASCII码，并将输入的数字转为整型a = int(input(\"请输入一个ASCII码: \")) print( c + \" 的ASCII 码为\", ord(c))print( a , \" 对应的字符为\", chr(a))def hcf(x,y): if x&gt;=y: lower=y else: lower=x for i in range(1,lower+1): if x%i==0 and y%i==0: hx=i return hxprint(hcf(9,18))def hcf(x,y): if x&gt;=y: higher=x else: higher=y for i in range(higher,x*y+1): if i%x==0 and i%y==0: hrm=i break return hrmprint(hcf(54,24))# 定义函数def add(x, y): \"\"\"相加\"\"\" return x + y def subtract(x, y): \"\"\"相减\"\"\" return x - y def multiply(x, y): \"\"\"相乘\"\"\" return x * y def divide(x, y): \"\"\"相除\"\"\" return x / y # 用户输入print(\"选择运算：\")print(\"1、相加\")print(\"2、相减\")print(\"3、相乘\")print(\"4、相除\") choice = input(\"输入你的选择(1/2/3/4):\") num1 = int(input(\"输入第一个数字: \"))num2 = int(input(\"输入第二个数字: \")) if choice == '1': print(num1,\"+\",num2,\"=\", add(num1,num2)) elif choice == '2': print(num1,\"-\",num2,\"=\", subtract(num1,num2)) elif choice == '3': print(num1,\"*\",num2,\"=\", multiply(num1,num2)) elif choice == '4': print(num1,\"/\",num2,\"=\", divide(num1,num2))else: print(\"非法输入\")import calendaryear=2015mm=6print(calendar.month(year,mm))def fib(n): if n&lt;=1: return n else: return fib(n-1)+fib(n-2)n=10for i in range(1,11): print(fib(i),end=',')with open('test.txt','w')as out_file: out_file.write('this is a python')with open('test.txt','r')as in_file: a=in_file.read()print(a)str='www.python.org'print(str.isalnum())print(str.isalpha())print(str.islower())print(str.isupper())print(str.isdigit())print(str.istitle())print(str.isspace())str='www.python.org'print(str.capitalize())print(str.lower())print(str.upper())print(str.title())import calendarstr=calendar.monthrange(2019,12)print(str)import datetimedef getYesterday(): today=datetime.date.today() oneday=datetime.timedelta(days=1) yesterday=today-oneday return yesterday # 输出print(getYesterday())def exec_code(): LOC = \"\"\" def factorial(num): fact=1 for i in range(1,num+1): fact = fact*i return fact print(factorial(5)) \"\"\" exec(LOC) exec_code()def sweplist(list1): n=len(list1) temp=list1[0] list1[0]=list1[n-1] list1[n-1]=temp return list1l=[1,2,3,4]t=sweplist(l)print(t)def sweplist(list1,p1,p2): list1[p1],list1[p2]=list1[p2],list1[p1] return list1li=[1,2,3,4]p1=1p2=2print(sweplist(li,p1,p2))li=[1,2,3,4]b=[ele for ele in reversed(li)]print(b)li=[1,2,3,4,5]if 4 in li: print('存在')else: print('不存在')li=[1,2,3,4]print('请空前',li)li.clear()print('清空后',li)li=[1,2,3,4]li2=li.copy()print(li)print(li2)li=[1,'2','2',2,3,4,5,6,9]c=li.count('2')print(c)li=[1,2,3,4,5]sum=sum(li)print(sum)li=[1,2,3,4,5]result=1for i in li: result*=iprint(result)li.sort()print(li[0])print(li[-1])li='132443'newli=li.replace(li[0],'',1)print(li)li='123456789'li1='123'if li1 in li: print('yes')else: print('no')import re def Find(string): # findall() 查找匹配正则表达式的字符串 url = re.findall('https?://(?:[-\\w.]|(?:%[\\da-fA-F]&#123;2&#125;))+', string) return url string = 'Runoob 的网页地址为：https://www.runoob.com，Google 的网页地址为：https://www.google.com'print(\"Urls: \", Find(string))next codedef rotate(input,d): Lfirst = input[0 : d] Lsecond = input[d :] Rfirst = input[0 : len(input)-d] Rsecond = input[len(input)-d : ] print( \"头部切片翻转 : \", (Lsecond + Lfirst) ) print( \"尾部切片翻转 : \", (Rsecond + Rfirst) ) if __name__ == \"__main__\": input = 'Runoob' d=2 # 截取两个字符 rotate(input,d)def dictionairy(): # 声明字典 key_value =&#123;&#125; # 初始化 key_value[2] = 56 key_value[1] = 2 key_value[5] = 12 key_value[4] = 24 key_value[6] = 18 key_value[3] = 323 print (\"按值(value)排序:\") print(sorted(key_value.items(), key = lambda kv:(kv[1], kv[0]))) #print(sorted(key_value.items(), key = lambda kv:(kv[1], kv[0]))) #print(sorted(key_value.items(), key = lambda kv:(kv[1], kv[0]))) def main(): dictionairy() main()def dictionairy(): # 声明字典 key_value =&#123;&#125; # 初始化 key_value[2] = 56 key_value[1] = 2 key_value[5] = 12 key_value[4] = 24 key_value[6] = 18 key_value[3] = 323 print (\"按键(key)排序:\") # sorted(key_value) 返回一个迭代器 # 字典按键排序 for i in sorted (key_value) : print ((i, key_value[i]), end =\" \") def main(): # 调用函数 dictionairy() # 主函数if __name__==\"__main__\": main() lis = [&#123; \"name\" : \"Taobao\", \"age\" : 100&#125;, &#123; \"name\" : \"Runoob\", \"age\" : 7 &#125;, &#123; \"name\" : \"Google\", \"age\" : 100 &#125;, &#123; \"name\" : \"Wiki\" , \"age\" : 200 &#125;] # 通过 age 升序排序print (\"列表通过 age 升序排序: \")print (sorted(lis, key = lambda i: i['age']) ) print (\"\\r\") # 先按 age 排序，再按 name 排序print (\"列表通过 age 和 name 排序: \")print (sorted(lis, key = lambda i: (i['age'], i['name'])) ) print (\"\\r\") # 按 age 降序排序print (\"列表通过 age 降序排序: \")print (sorted(lis, key = lambda i: i['age'],reverse=True) )dict = &#123;'a': 100, 'b':200, 'c':300&#125; def re(dic): sum=0 for i in dict: sum+=dic[i] return sumprint(re(dict)) dict = &#123;'a': 100, 'b':200, 'c':300&#125;print(dict)del dict['a']print(dict)dict1 = &#123;'a': 100, 'b':200, 'c':300&#125;dict2 = &#123;'d': 100, 'e':200, 'f':300&#125;dict2.update(dict1)print(dict2)import time a='2019-5-10 23:40:00'#timeArray = time.strptime(a1, \"%Y-%m-%d %H:%M:%S\")timearr=time.strptime(a,'%Y-%m-%d %H:%M:%S')print(timearr)#timeStamp = int(time.mktime(timeArray))timestamp=int(time.mktime(timearr))print(timestamp)#otherStyleTime = time.strftime(\"%Y/%m/%d %H:%M:%S\", timeArray)otherstyle=time.strftime('%Y/%m/%d %H:%M:%S',timearr)print(otherstyle)import timeimport datetime # 先获得时间数组格式的日期threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3))# 转换为时间戳timeStamp = int(time.mktime(threeDayAgo.timetuple()))# 转换为其他字符串格式otherStyleTime = threeDayAgo.strftime(\"%Y-%m-%d %H:%M:%S\")print(otherStyleTime)import timeimport datetimethreedayago=(datetime.datetime.now())-datetime.timedelta(days=3)print(threedayago)timestamp=int(time.mktime(threedayago.timetuple()))print(timestamp)otherstyletime=threedayago.strftime('%Y-%m-%d %H:%M:%S')print(otherstyletime)import timetimenow=int(time.time())print(timenow)localt=time.localtime(timenow)print(localt)#localt2=time.strptime(timenow)#print(localt2)otherstyletime=time.strftime('%Y-%m-%d',localt)print(otherstyletime)import datetimedt=datetime.datetime.now()print(dt)otherst=dt.strftime('%Y-%m-%d')print(otherst)name = \"RUNOOB\" # 接收用户输入# name = input(\"输入你的名字: \\n\\n\") lngth = len(name) l = \"\" for x in range(0, lngth): c = name[x] c = c.upper() if (c == \"A\"): print(\"..######..\\n..#....#..\\n..######..\", end = \" \") print(\"\\n..#....#..\\n..#....#..\\n\\n\") elif (c == \"B\"): print(\"..######..\\n..#....#..\\n..#####...\", end = \" \") print(\"\\n..#....#..\\n..######..\\n\\n\") elif (c == \"C\"): print(\"..######..\\n..#.......\\n..#.......\", end = \" \") print(\"\\n..#.......\\n..######..\\n\\n\") elif (c == \"D\"): print(\"..#####...\\n..#....#..\\n..#....#..\", end = \" \") print(\"\\n..#....#..\\n..#####...\\n\\n\") elif (c == \"E\"): print(\"..######..\\n..#.......\\n..#####...\", end = \" \") print(\"\\n..#.......\\n..######..\\n\\n\") elif (c == \"F\"): print(\"..######..\\n..#.......\\n..#####...\", end = \" \") print(\"\\n..#.......\\n..#.......\\n\\n\") elif (c == \"G\"): print(\"..######..\\n..#.......\\n..#.####..\", end = \" \") print(\"\\n..#....#..\\n..#####...\\n\\n\") elif (c == \"H\"): print(\"..#....#..\\n..#....#..\\n..######..\", end = \" \") print(\"\\n..#....#..\\n..#....#..\\n\\n\") elif (c == \"I\"): print(\"..######..\\n....##....\\n....##....\", end = \" \") print(\"\\n....##....\\n..######..\\n\\n\") elif (c == \"J\"): print(\"..######..\\n....##....\\n....##....\", end = \" \") print(\"\\n..#.##....\\n..####....\\n\\n\") elif (c == \"K\"): print(\"..#...#...\\n..#..#....\\n..##......\", end = \" \") print(\"\\n..#..#....\\n..#...#...\\n\\n\") elif (c == \"L\"): print(\"..#.......\\n..#.......\\n..#.......\", end = \" \") print(\"\\n..#.......\\n..######..\\n\\n\") elif (c == \"M\"): print(\"..#....#..\\n..##..##..\\n..#.##.#..\", end = \" \") print(\"\\n..#....#..\\n..#....#..\\n\\n\") elif (c == \"N\"): print(\"..#....#..\\n..##...#..\\n..#.#..#..\", end = \" \") print(\"\\n..#..#.#..\\n..#...##..\\n\\n\") elif (c == \"O\"): print(\"..######..\\n..#....#..\\n..#....#..\", end = \" \") print(\"\\n..#....#..\\n..######..\\n\\n\") elif (c == \"P\"): print(\"..######..\\n..#....#..\\n..######..\", end = \" \") print(\"\\n..#.......\\n..#.......\\n\\n\") elif (c == \"Q\"): print(\"..######..\\n..#....#..\\n..#.#..#..\", end = \" \") print(\"\\n..#..#.#..\\n..######..\\n\\n\") elif (c == \"R\"): print(\"..######..\\n..#....#..\\n..#.##...\", end = \" \") print(\"\\n..#...#...\\n..#....#..\\n\\n\") elif (c == \"S\"): print(\"..######..\\n..#.......\\n..######..\", end = \" \") print(\"\\n.......#..\\n..######..\\n\\n\") elif (c == \"T\"): print(\"..######..\\n....##....\\n....##....\", end = \" \") print(\"\\n....##....\\n....##....\\n\\n\") elif (c == \"U\"): print(\"..#....#..\\n..#....#..\\n..#....#..\", end = \" \") print(\"\\n..#....#..\\n..######..\\n\\n\") elif (c == \"V\"): print(\"..#....#..\\n..#....#..\\n..#....#..\", end = \" \") print(\"\\n...#..#...\\n....##....\\n\\n\") elif (c == \"W\"): print(\"..#....#..\\n..#....#..\\n..#.##.#..\", end = \" \") print(\"\\n..##..##..\\n..#....#..\\n\\n\") elif (c == \"X\"): print(\"..#....#..\\n...#..#...\\n....##....\", end = \" \") print(\"\\n...#..#...\\n..#....#..\\n\\n\") elif (c == \"Y\"): print(\"..#....#..\\n...#..#...\\n....##....\", end = \" \") print(\"\\n....##....\\n....##....\\n\\n\") elif (c == \"Z\"): print(\"..######..\\n......#...\\n.....#....\", end = \" \") print(\"\\n....#.....\\n..######..\\n\\n\") elif (c == \" \"): print(\"..........\\n..........\\n..........\", end = \" \") print(\"\\n..........\\n\\n\") elif (c == \".\"): print(\"----..----\\n\\n\")","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 12","slug":"study python 12day","date":"2019-12-30T12:00:01.000Z","updated":"2020-01-13T13:41:39.521Z","comments":true,"path":"2019/12/30/study python 12day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/30/study%20python%2012day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460N=3student=[]for i in range(5): student.append('','',[])def input_stu(stu): for i in range(N): stu[i][0]=input('shuru:\\n') stu[i][1]=input('shuru:\\n') for j in range(3): stu[i][2].append(int(input('score:\\n'))) def output_stu(stu): for i in range(N): print('%-6s%-10s'%(stu[i][0],stu[i][0])) for i in range(3): print('%-8d'%stu[i][2][j])if __name__='__main__': input_stu(student) print(student) out_stu(studengt)prt=[]for i in range(5): num=int(input()) prt.append(num)print(prt)prt=[]for i in range(5): num=int(input()) prt.append(num)print(prt)prt.reverse()print(prt)a=[1,2,3]b=[4,5,6]c=[1,3,2]c.sort()print(c)print(a+b+c)a.extend(b)print(a)if __name__ == '__main__': for i in range(5): n = 0 if i != 1: n += 1 if i == 3: n += 1 if i == 4: n += 1 if i != 4: n += 1 if n == 3: print 64 + idef peven(n): i=0 s=0.0 for i in range(2,n+1,2): s+=1.0/i return sdef podd(n): s=0.0 for i in range(1,n+1,2): s+=1.0/i return sdef dcall(fp,n): s=fp(n) return sn=int(input())if n%2==0: sum=dcall(peven,n)else: sum=dcall(podd,n)print(sum)s=[1,2,3,4,5]for i in range(len(s)): print(s[i])person = &#123;\"li\":18,\"wang\":50,\"zhang\":20,\"sun\":22&#125;m='li'for i in person.keys(): if person[m]&lt;person[i]: m=iprint(person[m])if __name__ == '__main__': str1 = raw_input('input string:\\n') str2 = raw_input('input string:\\n') str3 = raw_input('input string:\\n') print str1,str2,str3 if str1 &gt; str2 : str1,str2 = str2,str1 if str1 &gt; str3 : str1,str3 = str3,str1 if str2 &gt; str3 : str2,str3 = str3,str2 print 'after being sorted.' print str1,str2,str3if __name__ == '__main__': i = 0 j = 1 x = 0 while (i &lt; 5) : x = 4 * j for i in range(0,5) : if(x%4 != 0) : break else : i += 1 x = (x/4) * 5 +1 j += 1 print xa=809for i in range(10,100): b=i*a if b&gt;=1000 and b&lt;10000 and 8*i&lt;100 and 9*i &gt;=100: print(b,'=800*',i,'+9*',i)if __name__ == '__main__': n = 0 p = raw_input('input a octal number:\\n') for i in range(len(p)): n = n * 8 + ord(p[i]) - ord('0') print nsum=4s=4print(sum)for i in range(2,8): if i&lt;=2: s*=7 else: s*=8 sum+=s print(sum)delimiter = ','mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist))mylist = ['Brazil', 'Russia', 'India', 'China']print(','.join(mylist))n=int(input('输入一个数字：\\n'))flag=1c9=1m9=9sum=9while flag!=0: if sum%n==0: flag=0 else: m9*=10 sum+=m9 c9+=1print('%d个9可以被%d整除：%d'%(c9,n,sum))r=sum/nprint('%d/%d=%d'%(sum,n,r))if __name__=__main__: c='eruqewr' b='sjdfsajdf' a=c+b print(c)class student: x=0 c=0def f(stu): stu.x=20 stu.c='c'a=student()a.x=3a.c='a'f(a)print(a.x,a.c)if __name__ == '__main__': n = 1 while n &lt;= 7: a = int(raw_input('input a number:\\n')) while a &lt; 1 or a &gt; 50: a = int(raw_input('input a number:\\n')) print a * '*' n += 1from sys import stdoutif __name__ == '__main__': a = int(raw_input('输入四个数字:\\n')) aa = [] aa.append(a % 10) aa.append(a % 100 / 10) aa.append(a % 1000 / 100) aa.append(a / 1000) for i in range(4): aa[i] += 5 aa[i] %= 10 for i in range(2): aa[i],aa[3 - i] = aa[3 - i],aa[i] for i in range(3,-1,-1): stdout.write(str(aa[i]))#list #新建列表 testList=[10086,'中国移动',[1,2,4,5]] #访问列表长度 print len(testList) #到列表结尾 print testList[1:] #向列表添加元素 testList.append('i\\'m new here!') print len(testList) print testList[-1] #弹出列表的最后一个元素 print testList.pop(1) print len(testList) print testList #list comprehension #后面有介绍，暂时掠过 matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print matrix print matrix[1] col2 = [row[1] for row in matrix]#get a column from a matrix print col2 col2even = [row[1] for row in matrix if row[1] % 2 == 0]#filter odd item print col2eventestlist=[10086,'中国移动',[1,2,3,4,5]]print(len(testlist))print(testlist[1:])testlist.append('i\\'m new here!')print(len(testlist))print(testlist[-1])print(testlist.pop(1))print(len(testlist))print(testlist)matrix=[[1,2,3],[2,3,4],[4,5,6]]print(matrix)print(matrix[1])col2=[row[1] for row in matrix]print(col2)col2even=[row[1] for row in matrix if row[1]%2==0]print(col2even)import timeprint(time.ctime(time.time()))print(time.asctime(time.localtime(time.time())))print(time.asctime(time.gmtime(time.time())))import timestart=time.time()for i in range(3000): print(i)end=time.time()print(end-start)print('hello world')num1 = input('输入第一个数字：')num2 = input('输入第二个数字：') # 求和sum = float(num1) + float(num2) # 显示计算结果print('数字 &#123;0&#125; 和 &#123;1&#125; 相加结果为： &#123;2&#125;'.format(num1, num2, sum))num=float(9)num_aqrt=num**0.5print('%0.3f的平方根为%0.3f'%(num,num_aqrt))import cmatha=float(input())b=float(input())c=float(input())d=(b**2)-4*a*csol1=(-b-cmath.sqrt(d))/(2*a)sol2=(-b+cmath.sqrt(d))/(2*a)print('结果为&#123;0&#125;和&#123;1&#125;'.format(sol1,sol2))import cmatha=float(input())b=float(input())c=float(input())s=(a+b+c)/2area=(s*(s-a)*(s-b)*(s-c)*0.5)print('三角形面积为%0.2f'%area)def findArea(r): pi=3.14 return pi*r*rprint(findArea(5))import randomprint(random.randint(0,9))# 用户输入摄氏温度 # 接收用户输入celsius = float(input('输入摄氏温度: ')) # 计算华氏温度fahrenheit = (celsius * 1.8) + 32print('%0.1f 摄氏温度转为华氏温度为 %0.1f ' %(celsius,fahrenheit))x = input('输入 x 值: ')y = input('输入 y 值: ') # 创建临时变量，并交换temp = xx = yy = temp print('交换后 x 的值为: &#123;&#125;'.format(x))print('交换后 y 的值为: &#123;&#125;'.format(y))num=input()if num&gt;0: print('正数')elif num==0: print('零')else： print('负数')def is_number(s): try: float(s) return True except ValueError: pass try: import unicodedata unicodedata.numeric(s) return True except (TypeError, ValueError): pass return False # 测试字符串和数字print(is_number('foo')) # Falseprint(is_number('1')) # Trueprint(is_number('1.3')) # Trueprint(is_number('-1.37')) # Trueprint(is_number('1e3')) # True # 测试 Unicode# 阿拉伯语 5print(is_number('٥')) # True# 泰语 2print(is_number('๒')) # True# 中文数字print(is_number('四')) # True# 版权号print(is_number('©')) # Falsenum=input()if num%2==0: print('&#123;0&#125;数字为偶数'.format(num))else: print('&#123;0&#125;数字为奇数'.format(num))year=int(input())if year%4==0: if year%100==0: if year%400==0: print('&#123;0&#125;是闰年'.format(year)) else: print('&#123;0&#125;不是闰年'.format(year)) else: print('&#123;0&#125;是闰年'.format(year))else: print('&#123;0&#125;不是闰年'.format(year))# 最简单的print(max(1, 2))print(max('a', 'b')) # 也可以对列表和元组使用print(max([1,2]))print(max((1,2))) # 更多实例print(\"80, 100, 1000 最大值为: \", max(80, 100, 1000))print(\"-20, 100, 400最大值为: \", max(-20, 100, 400))print(\"-80, -20, -10最大值为: \", max(-80, -20, -10))print(\"0, 100, -400最大值为:\", max(0, 100, -400))num=int(input())if num&gt;1: for i in range(2,num): if(num%i)==0: print(num,'不是质数') break else: print(num,'是质数')else: print(num,'不是质数')n=int(input())for num in range(1,n+1): if num&gt;1: for j in range(2,num): if (num%j)==0: break else: print(num)while True: n=int(input()) if n&lt;0: print('负数没有乘阶') elif n==0: print('0的乘阶是1') else: sum=1 for i in range(1,n+1): sum*=i print('&#123;0&#125;的乘阶是&#123;1&#125;'.format(n,sum))for i in range(1,10): for j in range(1,i+1): print('&#123;&#125;x&#123;&#125;=&#123;&#125;\\t'.format(j,i,i*j),end='') print()n=int(input())n1=0n2=1count=2if n&lt;=0: print('输入一个正数')elif n==1: print(n1)else: print(n1,',',n2,end=',') while count&lt;n: nth=n1+n2 print(nth,end=',') n1=n2 n2=nth count+=1","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 11","slug":"study python 11day","date":"2019-12-29T12:00:01.000Z","updated":"2020-01-13T13:39:35.350Z","comments":true,"path":"2019/12/29/study python 11day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/29/study%20python%2011day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433def face(n): sum=0 if n==1: sum=1 else: sum=n*face(n-1) return sumprint(face(5))def output(s,l): if l==0: return print(s[l-1]) output(s,l-1)s=input()l=len(s)output(s,l)def age(n): if n==1: c=10 else: c=age(n-1)+2 return cprint(age(5))x = int(raw_input(\"请输入一个数:\\n\"))a = x / 10000b = x % 10000 / 1000c = x % 1000 / 100d = x % 100 / 10e = x % 10 if a != 0: print \"5 位数：\",e,d,c,b,aelif b != 0: print \"4 位数：\",e,d,c,b,elif c != 0: print \"3 位数：\",e,d,celif d != 0: print \"2 位数：\",e,delse: print \"1 位数：\",ea=int(input())x=str(a)flag=Truefor i in range(len(x)/2): if x[i]!=x[-i-1]: flag=False breakif flag: print('%d yes'%a)else: print('%d no'%a)letter = raw_input(\"please input:\")#while letter != 'Y':if letter == 'S': print ('please input second letter:') letter = raw_input(\"please input:\") if letter == 'a': print ('Saturday') elif letter == 'u': print ('Sunday') else: print ('data error') elif letter == 'F': print ('Friday') elif letter == 'M': print ('Monday') elif letter == 'T': print ('please input second letter') letter = raw_input(\"please input:\") if letter == 'u': print ('Tuesday') elif letter == 'h': print ('Thursday') else: print ('data error') elif letter == 'W': print ('Wednesday')else: print ('data error')a=[1,2,3]print(a[::-1])a=[1,2,3]s1=','.join(str(n) for n in a)print(s1)def hello_word(): print('hello world')def three_hellos(): for i in range(3): hello_word()if __name__=='__main__': three_hellos()class bcolors: HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m'print bcolors.WARNING + \"警告的颜色字体?\" + bcolors.ENDCfor i in range(2,101): for j in range(2,i): if(i%j)==0: break else: print(i) if __name__ == \"__main__\": N = 10 # input data print '请输入10个数字:\\n' l = [] for i in range(N): l.append(int(raw_input('输入一个数字:\\n'))) print for i in range(N): print l[i] print # 排列10个数字 for i in range(N - 1): min = i for j in range(i + 1,N): if l[min] &gt; l[j]:min = j l[i],l[min] = l[min],l[i] print '排列之后：' for i in range(N): print l[i]if __name__ == '__main__': a = [] sum = 0.0 for i in range(3): a.append([]) for j in range(3): a[i].append(float(raw_input(\"input num:\\n\"))) for i in range(3): sum += a[i][i] print sumif __name__ == '__main__': # 方法一 ： 0 作为加入数字的占位符 a = [1,4,6,9,13,16,19,28,40,100,0] print '原始列表:' for i in range(len(a)): print a[i], number = int(raw_input(\"\\n插入一个数字:\\n\")) end = a[9] if number &gt; end: a[10] = number else: for i in range(10): if a[i] &gt; number: temp1 = a[i] a[i] = number for j in range(i + 1,11): temp2 = a[j] a[j] = temp1 temp1 = temp2 break print '排序后列表:' for i in range(11): print a[i],if __name__ == '__main__': a = [9,6,5,4,1] N = len(a) print a for i in range(len(a) / 2): a[i],a[N - i - 1] = a[N - i - 1],a[i] print aef varfunc(): var = 0 print 'var = %d' % var var += 1if __name__ == '__main__': for i in range(3): varfunc()# 类的属性# 作为类的一个属性吧class Static: StaticVar = 5 def varfunc(self): self.StaticVar += 1 print self.StaticVarprint Static.StaticVara = Static()for i in range(3): a.varfunc()num = 2def autofunc(): num = 1 print 'internal block num = %d' % num num += 1for i in range(3): print 'The num = %d' % num num += 1 autofunc()class Num: nNum = 1 def inc(self): self.nNum += 1 print 'nNum = %d' % self.nNumif __name__ == '__main__': nNum = 2 inst = Num() for i in range(3): nNum += 1 print 'The num = %d' % nNum inst.inc()X = [[12, 7, 3], [4, 5, 6], [7, 8, 9]]Y = [[5, 8, 1], [6, 7, 3], [4, 5, 9]]result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]for i in range(len(X)): for j in range(len(X[0])): result[i][j]=X[i][j]+Y[i][j]for i in result: print(i)sum=0for i in range(1,101): sum+=iprint(sum)TRUE = 1FALSE = 0def SQ(x): return x * xprint('如果输入的数字小于 50，程序将停止运行。')again = 1while again: num = int(input('请输入一个数字：')) print('运算结果为: %d' % (SQ(num))) if SQ(num) &gt;= 50: again = TRUE else: again = FALSEdef exchange(a,b): a,b = b,a return (a,b) if __name__ == '__main__': x = 10 y = 20 print 'x = %d,y = %d' % (x,y) x,y = exchange(x,y) print 'x = %d,y = %d' % (x,y)x=10y=20if x&gt;y: print('%d dayu %d'%(x,y))elif x==y: print('%d dengyu %d'%(x,y))elif x&lt;y: print('%d xiaoyu %d'%(x,y))else: print('error')MAXIMUM = lambda x,y : (x &gt; y) * x + (x &lt; y) * yMINIMUM = lambda x,y : (x &gt; y) * y + (x &lt; y) * x if __name__ == '__main__': a = 10 b = 20 print 'The largar one is %d' % MAXIMUM(a,b) print 'The lower one is %d' % MINIMUM(a,b)import randomprint(random.uniform(10,20))if __name__ == '__main__': a = 0x77 b = a &amp; 3 print 'a &amp; b = %d' % b b &amp;= 7 print 'a &amp; b = %d' % bif __name__ == '__main__': a = 077 b = a | 3 print 'a | b is %d' % b b |= 7 print 'a | b is %d' % bif __name__ == '__main__': a = 077 b = a ^ 3 print 'The a ^ 3 = %d' % b b ^= 7 print 'The a ^ b = %d' % bif __name__ == '__main__': a = int(raw_input('input a number:\\n')) b = a &gt;&gt; 4 c = ~(~0 &lt;&lt; 4) d = b &amp; c print '%o\\t%o' %(a,d)if __name__ == '__main__': a = 234 b = ~a print 'The a\\'s 1 complement is %d' % b a = ~a print 'The a\\'s 2 complement is %d' % aif __name__ == '__main__': from Tkinter import * canvas = Canvas(width=800, height=600, bg='yellow') canvas.pack(expand=YES, fill=BOTH) k = 1 j = 1 for i in range(0,26): canvas.create_oval(310 - k,250 - k,310 + k,250 + k, width=1) k += j j += 0.3 mainloop()if __name__ == '__main__': from Tkinter import * canvas = Canvas(width=300, height=300, bg='green') canvas.pack(expand=YES, fill=BOTH) x0 = 263 y0 = 263 y1 = 275 x1 = 275 for i in range(19): canvas.create_line(x0,y0,x0,y1, width=1, fill='red') x0 = x0 - 5 y0 = y0 - 5 x1 = x1 + 5 y1 = y1 + 5 x0 = 263 y1 = 275 y0 = 263 for i in range(21): canvas.create_line(x0,y0,x0,y1,fill = 'red') x0 += 5 y0 += 5 y1 += 5 mainloop()if __name__ == '__main__': from Tkinter import * root = Tk() root.title('Canvas') canvas = Canvas(root,width = 400,height = 400,bg = 'yellow') x0 = 263 y0 = 263 y1 = 275 x1 = 275 for i in range(19): canvas.create_rectangle(x0,y0,x1,y1) x0 -= 5 y0 -= 5 x1 += 5 y1 += 5 canvas.pack() root.mainloop()if __name__ == '__main__': from Tkinter import * canvas = Canvas(width = 300,height = 300,bg = 'green') canvas.pack(expand = YES,fill = BOTH) x0 = 150 y0 = 100 canvas.create_oval(x0 - 10,y0 - 10,x0 + 10,y0 + 10) canvas.create_oval(x0 - 20,y0 - 20,x0 + 20,y0 + 20) canvas.create_oval(x0 - 50,y0 - 50,x0 + 50,y0 + 50) import math B = 0.809 for i in range(16): a = 2 * math.pi / 16 * i x = math.ceil(x0 + 48 * math.cos(a)) y = math.ceil(y0 + 48 * math.sin(a) * B) canvas.create_line(x0,y0,x,y,fill = 'red') canvas.create_oval(x0 - 60,y0 - 60,x0 + 60,y0 + 60) for k in range(501): for i in range(17): a = (2 * math.pi / 16) * i + (2 * math.pi / 180) * k x = math.ceil(x0 + 48 * math.cos(a)) y = math.ceil(y0 + 48 + math.sin(a) * B) canvas.create_line(x0,y0,x,y,fill = 'red') for j in range(51): a = (2 * math.pi / 16) * i + (2* math.pi / 180) * k - 1 x = math.ceil(x0 + 48 * math.cos(a)) y = math.ceil(y0 + 48 * math.sin(a) * B) canvas.create_line(x0,y0,x,y,fill = 'red') mainloop()sStr1 = 'strlen'print len(sStr1)","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 10","slug":"study python 10day","date":"2019-12-28T12:00:01.000Z","updated":"2020-01-13T13:38:33.497Z","comments":true,"path":"2019/12/28/study python 10day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/28/study%20python%2010day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452for i in range(1,5): for j in range(1,5): for k in range(1,5): if (i!=j)and(i!=k)and(j!=k): print(i,j,k)i=int(raw_input('净利润：'))arr=[1000000,600000,400000,200000,100000,0]rat=[0.01,0.015,0.03,0.05,0.075,0.1]r=0for idx in range(0,6): if i&gt;arr[idx]: r+=(i-arr[idx])*rat[idx] print(i-arr[idx])*rat[idx] i=arr[idx]print(r)for i in range(1,85): if 168%i==0: j=168/i if i&gt;j and (i+j)%2==0 and (i-j)%2==0: m=(i+j)/2 n=(i-j)/2 x=n*n-100 print(x)year=int(raw_input('year:\\n'))month=int(raw_input('month:\\n'))day=int(raw_input('day:/n'))months=(0,31,59,90,120,151,181,212,243,273,304,334)if 0&lt;month&lt;=12: sum=months[month-1]else: print('data error')sum+=dayleap=0if(year%400==0)or((year%4==0)and(year%100!=0)): leap=1if(leap==1)and(month&gt;2): sum+=1print('it is the %dth day.'%sum)l=[]for i in range(3): x=int(input()) l.append(x)l.sort()print(l)def fib(n): a,b=1,1 for i in range(n-1): a,b=b,a+b return(a)print(fib(10))a=[1,2,3]b=a[:]print(b)for i in range(1,10): print() for j in range(1,i+1): print('%d*%d=%d'%(i,j,i*j),end=\" \")import timemyD=&#123;1:'a',2:'b'&#125;for key,value in dict.items(myD): print(key,value) time.sleep(1)import timeprint(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))time.sleep(1)print(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))h=0leap=1from math import sqrtfrom sys import stdoutfor m in range(101,201): k=int(sqrt(m+1)) for i in range(2,k+1): if m%i==0: leap=0 break if leap==1: print('%-4d'%m) h+=1 if h%10==0: print('') leap=1print('the total is %d'%h)for n in range(100,1000): i=n/100 j=n/10%10 k=n%10 if n==i**3+j**3+k**3: print(n)def reduceNum(n): print '&#123;&#125; = '.format(n), if not isinstance(n, int) or n &lt;= 0 : print '请输入一个正确的数字 !' exit(0) elif n in [1] : print '&#123;&#125;'.format(n) while n not in [1] : # 循环保证递归 for index in xrange(2, n + 1) : if n % index == 0: n /= index # n 等于 n/index if n == 1: print index else : # index 一定是素数 print '&#123;&#125; *'.format(index), breakreduceNum(90)reduceNum(100)scort=int(input())if scort&gt;=90: grade='A'elif scort&gt;=60: grade='B'else: grade='C'print('%d shuyu %s'%(scort,grade))import datetime if __name__ == '__main__': # 输出今日日期，格式为 dd/mm/yyyy。更多选项可以查看 strftime() 方法 print(datetime.date.today().strftime('%d/%m/%Y')) # 创建日期对象 miyazakiBirthDate = datetime.date(1941, 1, 5) print(miyazakiBirthDate.strftime('%d/%m/%Y')) # 日期算术运算 miyazakiBirthNextDay = miyazakiBirthDate + datetime.timedelta(days=1) print(miyazakiBirthNextDay.strftime('%d/%m/%Y')) # 日期替换 miyazakiFirstBirthday = miyazakiBirthDate.replace(year=miyazakiBirthDate.year + 1) print(miyazakiFirstBirthday.strftime('%d/%m/%Y'))import strings=input()letters=0space=0digit=0others=0i=0while i&lt;len(s): c=s[i] i+=1 if c.isalpha(): letters+=1 elif c.isspace(): space+=1 elif c.isdigit(): digit+=1 else: others+=1print('char=%d,space=%d,digit=%d,others=%d'%(letters,space,digit,others))Tn = 0Sn = []n = int(raw_input('n = '))a = int(raw_input('a = '))for count in range(n): Tn = Tn + a a = a * 10 Sn.append(Tn) print Tn Sn = reduce(lambda x,y : x + y,Sn)print \"计算和为：\",Snfrom sys import stdoutfor j in range(2,1001): k = [] n = -1 s = j for i in range(1,j): if j % i == 0: n += 1 s -= i k.append(i) if s == 0: print j for i in range(n): stdout.write(str(k[i])) stdout.write(' ') print k[n]tour=[]height=[]hei=100tim=10for i in range(1,tim+1): if i==1: tour.append(hei) else: tour.append(hei*2) hei/=2.0 height.append(hei)print('zong:tour=&#123;0&#125;'.format(sum(tour)))print('time10:height=&#123;0&#125;'.format(height[-1]))x2=1for day in range(9,0,-1): x1=(x2+1)*2 x2=x1print(x1)for i in range(ord('x'),ord('z') + 1): for j in range(ord('x'),ord('z') + 1): if i != j: for k in range(ord('x'),ord('z') + 1): if (i != k) and (j != k): if (i != ord('x')) and (k != ord('x')) and (k != ord('z')): print 'order is a -- %s\\t b -- %s\\tc--%s' % (chr(i),chr(j),chr(k))from sys import stdoutfor i in range(4): for j in range(2 - i + 1): stdout.write(' ') for k in range(2 * i + 1): stdout.write('*') print for i in range(3): for j in range(i + 1): stdout.write(' ') for k in range(4 - 2 * i + 1): stdout.write('*') printa=2.0b=1.0s=0for n in range(1,21): s+=a/b t=a a=a+b b=tprint(s)n=0s=0t=1for n in range(1,21): t*=n s+=tprint('1!+2!+3!+.....+20!=%d'%s)if __name__ == '__main__': a = [] for i in range(10): a.append([]) for j in range(10): a[i].append(0) for i in range(10): a[i][0] = 1 a[i][i] = 1 for i in range(2,10): for j in range(1,i): a[i][j] = a[i - 1][j-1] + a[i - 1][j] from sys import stdout for i in range(10): for j in range(i + 1): stdout.write(str(a[i][j])) stdout.write(' ') prints1='qwertyyuuii's2='wer'print(s1.find(s2))if __name__ == '__main__': from Tkinter import * x = 360 y = 160 top = y - 30 bottom = y - 30 canvas = Canvas(width = 400,height = 600,bg = 'white') for i in range(20): canvas.create_oval(250 - top,250 - bottom,250 + top,250 + bottom) top -= 5 bottom += 5 canvas.pack() mainloop()if __name__ == '__main__': from Tkinter import * canvas = Canvas(width = 400,height = 600,bg = 'white') left = 20 right = 50 top = 50 num = 15 for i in range(num): canvas.create_oval(250 - right,250 - left,250 + right,250 + left) canvas.create_oval(250 - 20,250 - top,250 + 20,250 + top) canvas.create_rectangle(20 - 2 * i,20 - 2 * i,10 * (i + 2),10 * ( i + 2)) right += 5 left += 5 top += 10 canvas.pack() mainloop()import mathclass PTS: def __init__(self): self.x = 0 self.y = 0points = []def LineToDemo(): from Tkinter import * screenx = 400 screeny = 400 canvas = Canvas(width = screenx,height = screeny,bg = 'white') AspectRatio = 0.85 MAXPTS = 15 h = screeny w = screenx xcenter = w / 2 ycenter = h / 2 radius = (h - 30) / (AspectRatio * 2) - 20 step = 360 / MAXPTS angle = 0.0 for i in range(MAXPTS): rads = angle * math.pi / 180.0 p = PTS() p.x = xcenter + int(math.cos(rads) * radius) p.y = ycenter - int(math.sin(rads) * radius * AspectRatio) angle += step points.append(p) canvas.create_oval(xcenter - radius,ycenter - radius, xcenter + radius,ycenter + radius) for i in range(MAXPTS): for j in range(i,MAXPTS): canvas.create_line(points[i].x,points[i].y,points[j].x,points[j].y) canvas.pack() mainloop()if __name__ == '__main__': LineToDemo()if __name__ == '__main__': n1 = int(raw_input('n1 = :\\n')) n2 = int(raw_input('n2 = :\\n')) n3 = int(raw_input('n3 = :\\n')) def swap(p1,p2): return p2,p1 if n1 &gt; n2 : n1,n2 = swap(n1,n2) if n1 &gt; n3 : n1,n3 = swap(n1,n3) if n2 &gt; n3 : n2,n3 = swap(n2,n3)def inp(numbers): for i in range(6): numbers.append(int(raw_input('输入一个数字:\\n')))p = 0 def arr_max(array): max = 0 for i in range(1,len(array) - 1): p = i if array[p] &gt; array[max] : max = p k = max array[0],array[k] = array[k],array[0]def arr_min(array): min = 0 for i in range(1,len(array) - 1): p = i if array[p] &lt; array[min] : min = p l = min array[5],array[l] = array[l],array[5] def outp(numbers): for i in range(len(numbers)): print numbers[i] if __name__ == '__main__': array = [] inp(array) # 输入 6 个数字并放入数组 arr_max(array) # 获取最大元素并与第一个元素交换 arr_min(array) # 获取最小元素并与最后一个元素交换 print '计算结果：' outp(array)if __name__ == '__main__': n = int(raw_input('整数 n 为:\\n')) m = int(raw_input('向后移 m 个位置为:\\n')) def move(array,n,m): array_end = array[n - 1] for i in range(n - 1,-1,- 1): array[i] = array[i - 1] array[0] = array_end m -= 1 if m &gt; 0:move(array,n,m) number = [] for i in range(n): number.append(int(raw_input('输入一个数字:\\n'))) print '原始列表:',number move(number,n,m) print '移动之后:',numberif __name__ == '__main__': nmax = 50 n = int(raw_input('请输入总人数:')) num = [] for i in range(n): num.append(i + 1) i = 0 k = 0 m = 0 while m &lt; n - 1: if num[i] != 0 : k += 1 if k == 3: num[i] = 0 k = 0 m += 1 i += 1 if i == n : i = 0 i = 0 while num[i] == 0: i += 1 print num[i]if __name__ == '__main__': s = raw_input('please input a string:\\n') print 'the string has %d characters.' % len(s)","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 正则表达式 day 09-1","slug":"study python 9day-1","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:27:15.244Z","comments":true,"path":"2019/12/27/study python 9day-1/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307Python 正则表达式正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。re 模块使 Python 语言拥有全部的正则表达式功能。compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。本章节主要介绍Python中常用的正则表达式处理函数。re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法：re.match(pattern, string, flags=0)函数参数说明：参数 描述pattern 匹配的正则表达式string 要匹配的字符串。flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法 描述group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import re print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配 print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配以上实例运行输出结果为：(0, 3)None实例#!/usr/bin/python import re line = \"Cats are smarter than dogs\" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print \"matchObj.group() : \", matchObj.group() print \"matchObj.group(1) : \", matchObj.group(1) print \"matchObj.group(2) : \", matchObj.group(2) else: print \"No match!!\"以上实例执行结果如下：matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarterre.search方法re.search 扫描整个字符串并返回第一个成功的匹配。函数语法：re.search(pattern, string, flags=0)函数参数说明：参数 描述pattern 匹配的正则表达式string 要匹配的字符串。flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。匹配成功re.search方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法 描述group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import re print(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配 print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配以上实例运行输出结果为：(0, 3)(11, 14)实例#!/usr/bin/python import re line = \"Cats are smarter than dogs\"; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj: print \"searchObj.group() : \", searchObj.group() print \"searchObj.group(1) : \", searchObj.group(1) print \"searchObj.group(2) : \", searchObj.group(2) else: print \"Nothing found!!\"以上实例执行结果如下：searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarterre.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。实例#!/usr/bin/python import re line = \"Cats are smarter than dogs\"; matchObj = re.match( r'dogs', line, re.M|re.I) if matchObj: print \"match --&gt; matchObj.group() : \", matchObj.group() else: print \"No match!!\" matchObj = re.search( r'dogs', line, re.M|re.I) if matchObj: print \"search --&gt; searchObj.group() : \", matchObj.group() else: print \"No match!!\"以上实例运行结果如下：No match!!search --&gt; searchObj.group() : dogs检索和替换Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。语法：re.sub(pattern, repl, string, count=0, flags=0)参数：pattern : 正则中的模式字符串。repl : 替换的字符串，也可为一个函数。string : 要被查找替换的原始字符串。count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import re phone = \"2004-959-559 # 这是一个国外电话号码\" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', \"\", phone) print \"电话号码是: \", num # 删除非数字(-)的字符串 num = re.sub(r'\\D', \"\", phone) print \"电话号码是 : \", num以上实例执行结果如下：电话号码是: 2004-959-559 电话号码是 : 2004959559repl 参数是一个函数以下实例中将字符串中的匹配的数字乘以 2：实例#!/usr/bin/python # -*- coding: UTF-8 -*- import re # 将匹配的数字乘以 2 def double(matched): value = int(matched.group('value')) return str(value * 2) s = 'A23G4HFD567' print(re.sub('(?P&lt;value&gt;\\d+)', double, s))执行输出结果为：A46G8HFD1134re.compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。语法格式为：re.compile(pattern[, flags])参数：pattern : 一个字符串形式的正则表达式flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：re.I 忽略大小写re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境re.M 多行模式re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库re.X 为了增加可读性，忽略空格和 # 后面的注释实例实例&gt;&gt;&gt;import re &gt;&gt;&gt; pattern = re.compile(r'\\d+') # 用于匹配至少一个数字 &gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配 &gt;&gt;&gt; print m None &gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配 &gt;&gt;&gt; print m None &gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配 &gt;&gt;&gt; print m # 返回一个 Match 对象 &lt;_sre.SRE_Match object at 0x10a42aac0&gt; &gt;&gt;&gt; m.group(0) # 可省略 0 '12' &gt;&gt;&gt; m.start(0) # 可省略 0 3 &gt;&gt;&gt; m.end(0) # 可省略 0 5 &gt;&gt;&gt; m.span(0) # 可省略 0 (3, 5)在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。再看看一个例子：实例&gt;&gt;&gt;import re &gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写 &gt;&gt;&gt; m = pattern.match('Hello World Wide Web') &gt;&gt;&gt; print m # 匹配成功，返回一个 Match 对象 &lt;_sre.SRE_Match object at 0x10bea83e8&gt; &gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串 'Hello World' &gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引 (0, 11) &gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串 'Hello' &gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引 (0, 5) &gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串 'World' &gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串 (6, 11) &gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...) ('Hello', 'World') &gt;&gt;&gt; m.group(3) # 不存在第三个分组 Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; IndexError: no such groupfindall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为：findall(string[, pos[, endpos]])参数：string : 待匹配的字符串。pos : 可选参数，指定字符串的起始位置，默认为 0。endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。查找字符串中的所有数字：实例# -*- coding:UTF8 -*- import re pattern = re.compile(r'\\d+') # 查找数字 result1 = pattern.findall('runoob 123 google 456') result2 = pattern.findall('run88oob123google456', 0, 10) print(result1) print(result2)输出结果：['123', '456']['88', '12']re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。re.finditer(pattern, string, flags=0)参数：参数 描述pattern 匹配的正则表达式string 要匹配的字符串。flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志实例# -*- coding: UTF-8 -*- import re it = re.finditer(r\"\\d+\",\"12a32bc43jf3\") for match in it: print (match.group() )输出结果：12 32 43 3re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：re.split(pattern, string[, maxsplit=0, flags=0])参数：参数 描述pattern 匹配的正则表达式string 要匹配的字符串。maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志实例&gt;&gt;&gt;import re &gt;&gt;&gt; re.split('\\W+', 'runoob, runoob, runoob.') ['runoob', 'runoob', 'runoob', ''] &gt;&gt;&gt; re.split('(\\W+)', ' runoob, runoob, runoob.') ['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', ''] &gt;&gt;&gt; re.split('\\W+', ' runoob, runoob, runoob.', 1) ['', 'runoob, runoob, runoob.'] &gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割 ['hello world']正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。re.MatchObjectgroup() 返回被 RE 匹配的字符串。start() 返回匹配开始的位置end() 返回匹配结束的位置span() 返回一个元组包含匹配 (开始,结束) 的位置正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：修饰符 描述re.I 使匹配对大小写不敏感re.L 做本地化识别（locale-aware）匹配re.M 多行匹配，影响 ^ 和 $re.S 使 . 匹配包括换行在内的所有字符re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式：字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。多数字母和数字前加一个反斜杠时会拥有不同的含义。标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。反斜杠本身需要使用反斜杠转义。由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\\t'，等价于 '\\\\t')匹配相应的特殊字符。下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。模式 描述^ 匹配字符串的开头$ 匹配字符串的末尾。. 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[...] 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'[^...] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re* 匹配0个或多个的表达式。re+ 匹配1个或多个的表达式。re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re&#123; n&#125; 精确匹配 n 个前面表达式。例如， o&#123;2&#125; 不能匹配 \"Bob\" 中的 \"o\"，但是能匹配 \"food\" 中的两个 o。re&#123; n,&#125; 匹配 n 个前面表达式。例如， o&#123;2,&#125; 不能匹配\"Bob\"中的\"o\"，但能匹配 \"foooood\"中的所有 o。\"o&#123;1,&#125;\" 等价于 \"o+\"。\"o&#123;0,&#125;\" 则等价于 \"o*\"。re&#123; n, m&#125; 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b 匹配a或b(re) 对正则表达式分组并记住匹配的文本(?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re) 类似 (...), 但是不表示一个组(?imx: re) 在括号中使用i, m, 或 x 可选标志(?-imx: re) 在括号中不使用i, m, 或 x 可选标志(?#...) 注释.(?= re) 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re) 匹配的独立模式，省去回溯。\\w 匹配字母数字及下划线\\W 匹配非字母数字及下划线\\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f].\\S 匹配任意非空字符\\d 匹配任意数字，等价于 [0-9].\\D 匹配任意非数字\\A 匹配字符串开始\\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\\z 匹配字符串结束\\G 匹配最后匹配完成的位置。\\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。\\B 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。\\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等\\1...\\9 匹配第n个分组的内容。\\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。正则表达式实例字符匹配实例 描述python 匹配 \"python\".字符类实例 描述[Pp]ython 匹配 \"Python\" 或 \"python\"rub[ye] 匹配 \"ruby\" 或 \"rube\"[aeiou] 匹配中括号内的任意一个字母[0-9] 匹配任何数字。类似于 [0123456789][a-z] 匹配任何小写字母[A-Z] 匹配任何大写字母[a-zA-Z0-9] 匹配任何字母及数字[^aeiou] 除了aeiou字母以外的所有字符[^0-9] 匹配除了数字外的字符特殊字符类实例 描述. 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。\\d 匹配一个数字字符。等价于 [0-9]。\\D 匹配一个非数字字符。等价于 [^0-9]。\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\\w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。\\W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python CGI day 09-3","slug":"study python 9day-3","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:29:25.885Z","comments":true,"path":"2019/12/27/study python 9day-3/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-3/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645Python CGI编程什么是 CGICGI 目前由 NCSA 维护，NCSA 定义 CGI 如下：CGI(Common Gateway Interface)，通用网关接口，它是一段程序，运行在服务器上如：HTTP 服务器，提供同客户端 HTML 页面的接口。网页浏览为了更好的了解 CGI 是如何工作的，我们可以从在网页上点击一个链接或 URL 的流程：1、使用你的浏览器访问 URL 并连接到 HTTP web 服务器。2、Web 服务器接收到请求信息后会解析 URL，并查找访问的文件在服务器上是否存在，如果存在返回文件的内容，否则返回错误信息。3、浏览器从服务器上接收信息，并显示接收的文件或者错误信息。CGI 程序可以是 Python 脚本，PERL 脚本，SHELL 脚本，C 或者 C++ 程序等。CGI架构图Web 服务器支持及配置在你进行 CGI 编程前，确保您的 Web 服务器支持 CGI 及已经配置了 CGI 的处理程序。Apache 支持 CGI 配置：设置好CGI目录：ScriptAlias /cgi-bin/ /var/www/cgi-bin/所有的HTTP服务器执行 CGI 程序都保存在一个预先配置的目录。这个目录被称为 CGI 目录，并按照惯例，它被命名为 /var/www/cgi-bin 目录。CGI 文件的扩展名为 .cgi，python 也可以使用 .py 扩展名。默认情况下，Linux 服务器配置运行的 cgi-bin 目录中为 /var/www。如果你想指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示：&lt;Directory \"/var/www/cgi-bin\"&gt; AllowOverride None Options +ExecCGI Order allow,deny Allow from all&lt;/Directory&gt;在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：AddHandler cgi-script .cgi .pl .py第一个CGI程序我们使用 Python 创建第一个 CGI 程序，文件名为 hello.py，文件位于 /var/www/cgi-bin 目录中，内容如下：#!/usr/bin/python# -*- coding: UTF-8 -*-print \"Content-type:text/html\"print # 空行，告诉服务器结束头部print '&lt;html&gt;'print '&lt;head&gt;'print '&lt;meta charset=\"utf-8\"&gt;'print '&lt;title&gt;Hello World - 我的第一个 CGI 程序！&lt;/title&gt;'print '&lt;/head&gt;'print '&lt;body&gt;'print '&lt;h2&gt;Hello World! 我是来自菜鸟教程的第一CGI程序&lt;/h2&gt;'print '&lt;/body&gt;'print '&lt;/html&gt;'文件保存后修改 hello.py，修改文件权限为 755：chmod 755 hello.py 以上程序在浏览器访问 http://localhost/cgi-bin/hello.py 显示结果如下：Hello World! 我是来自菜鸟教程的第一CGI程序这个的hello.py脚本是一个简单的Python脚本，脚本第一行的输出内容\"Content-type:text/html\"发送到浏览器并告知浏览器显示的内容类型为\"text/html\"。用 print 输出一个空行用于告诉服务器结束头部信息。HTTP头部hello.py文件内容中的\" Content-type:text/html\"即为HTTP头部的一部分，它会发送给浏览器告诉浏览器文件的内容类型。HTTP头部的格式如下：HTTP 字段名: 字段内容例如：Content-type: text/html以下表格介绍了CGI程序中HTTP头部经常使用的信息：头 描述Content-type: 请求的与实体对应的MIME信息。例如: Content-type:text/htmlExpires: Date 响应过期的日期和时间Location: URL 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源Last-modified: Date 请求资源的最后修改时间Content-length: N 请求的内容长度Set-Cookie: String 设置Http CookieCGI环境变量所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用：变量名 描述CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。CONTENT_LENGTH 如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。HTTP_COOKIE 客户机内的 COOKIE 内容。HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息。PATH_INFO 这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。QUERY_STRING 如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。REMOTE_ADDR 这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。REMOTE_HOST 这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。SCRIPT_FILENAME CGI脚本的完整路径SCRIPT_NAME CGI脚本的的名称SERVER_NAME 这是你的 WEB 服务器的主机名、别名或IP地址。SERVER_SOFTWARE 这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)以下是一个简单的CGI脚本输出CGI的环境变量：#!/usr/bin/python# -*- coding: UTF-8 -*-# filename:test.pyimport osprint \"Content-type: text/html\"printprint \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;b&gt;环境变量&lt;/b&gt;&lt;br&gt;\";print \"&lt;ul&gt;\"for key in os.environ.keys(): print \"&lt;li&gt;&lt;span style='color:green'&gt;%30s &lt;/span&gt; : %s &lt;/li&gt;\" % (key,os.environ[key])print \"&lt;/ul&gt;\"将以上点保存为 test.py ,并修改文件权限为 755，执行结果如下：GET和POST方法浏览器客户端通过两种方法向服务器传递信息，这两种方法就是 GET 方法和 POST 方法。使用GET方法传输数据GET方法发送编码后的用户信息到服务端，数据信息包含在请求页面的URL上，以\"?\"号分割, 如下所示：http://www.test.com/cgi-bin/hello.py?key1=value1&amp;key2=value2有关 GET 请求的其他一些注释：GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据简单的url实例：GET方法以下是一个简单的URL，使用GET方法向hello_get.py程序发送两个参数：/cgi-bin/test.py?name=菜鸟教程&amp;url=http://www.runoob.com以下为hello_get.py文件的代码：#!/usr/bin/python# -*- coding: UTF-8 -*-# filename：test.py# CGI处理模块import cgi, cgitb # 创建 FieldStorage 的实例化form = cgi.FieldStorage() # 获取数据site_name = form.getvalue('name')site_url = form.getvalue('url')print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\"print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt;%s官网：%s&lt;/h2&gt;\" % (site_name, site_url)print \"&lt;/body&gt;\"print \"&lt;/html&gt;\"文件保存后修改 hello_get.py，修改文件权限为 755：chmod 755 hello_get.py 浏览器请求输出结果：简单的表单实例：GET方法以下是一个通过HTML的表单使用GET方法向服务器发送两个数据，提交的服务器脚本同样是hello_get.py文件，hello_get.html 代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/hello_get.py\" method=\"get\"&gt;站点名称: &lt;input type=\"text\" name=\"name\"&gt; &lt;br /&gt;站点 URL: &lt;input type=\"text\" name=\"url\" /&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;默认情况下 cgi-bin 目录只能存放脚本文件，我们将 hello_get.html 存储在 test 目录下，修改文件权限为 755：chmod 755 hello_get.htmlGif 演示如下所示：使用POST方法传递数据使用POST方法向服务器传递数据是更安全可靠的，像一些敏感信息如用户密码等需要使用POST传输数据。以下同样是hello_get.py ，它也可以处理浏览器提交的POST表单数据:#!/usr/bin/python# -*- coding: UTF-8 -*-# CGI处理模块import cgi, cgitb # 创建 FieldStorage 的实例化form = cgi.FieldStorage() # 获取数据site_name = form.getvalue('name')site_url = form.getvalue('url')print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\"print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt;%s官网：%s&lt;/h2&gt;\" % (site_name, site_url)print \"&lt;/body&gt;\"print \"&lt;/html&gt;\"以下为表单通过POST方法（method=\"post\"）向服务器脚本 hello_get.py 提交数据:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/hello_get.py\" method=\"post\"&gt;站点名称: &lt;input type=\"text\" name=\"name\"&gt; &lt;br /&gt;站点 URL: &lt;input type=\"text\" name=\"url\" /&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;Gif 演示如下所示：通过CGI程序传递checkbox数据checkbox用于提交一个或者多个选项数据，HTML代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/checkbox.py\" method=\"POST\" target=\"_blank\"&gt;&lt;input type=\"checkbox\" name=\"runoob\" value=\"on\" /&gt; 菜鸟教程&lt;input type=\"checkbox\" name=\"google\" value=\"on\" /&gt; Google&lt;input type=\"submit\" value=\"选择站点\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;以下为 checkbox.py 文件的代码：#!/usr/bin/python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form = cgi.FieldStorage() # 接收字段数据if form.getvalue('google'): google_flag = \"是\"else: google_flag = \"否\"if form.getvalue('runoob'): runoob_flag = \"是\"else: runoob_flag = \"否\"print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\"print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt; 菜鸟教程是否选择了 : %s&lt;/h2&gt;\" % runoob_flagprint \"&lt;h2&gt; Google 是否选择了 : %s&lt;/h2&gt;\" % google_flagprint \"&lt;/body&gt;\"print \"&lt;/html&gt;\"修改 checkbox.py 权限：chmod 755 checkbox.py浏览器访问 Gif 演示图：通过CGI程序传递Radio数据Radio 只向服务器传递一个数据，HTML代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/radiobutton.py\" method=\"post\" target=\"_blank\"&gt;&lt;input type=\"radio\" name=\"site\" value=\"runoob\" /&gt; 菜鸟教程&lt;input type=\"radio\" name=\"site\" value=\"google\" /&gt; Google&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;radiobutton.py 脚本代码如下：#!/usr/bin/python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form = cgi.FieldStorage() # 接收字段数据if form.getvalue('site'): site = form.getvalue('site')else: site = \"提交数据为空\"print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\"print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt; 选中的网站是 %s&lt;/h2&gt;\" % siteprint \"&lt;/body&gt;\"print \"&lt;/html&gt;\"修改 radiobutton.py 权限：chmod 755 radiobutton.py浏览器访问 Gif 演示图：通过CGI程序传递 Textarea 数据Textarea 向服务器传递多行数据，HTML代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/textarea.py\" method=\"post\" target=\"_blank\"&gt;&lt;textarea name=\"textcontent\" cols=\"40\" rows=\"4\"&gt;在这里输入内容...&lt;/textarea&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;textarea.py 脚本代码如下：#!/usr/bin/python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form = cgi.FieldStorage() # 接收字段数据if form.getvalue('textcontent'): text_content = form.getvalue('textcontent')else: text_content = \"没有内容\"print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\";print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;\" % text_contentprint \"&lt;/body&gt;\"print \"&lt;/html&gt;\"修改 textarea.py 权限：chmod 755 textarea.py浏览器访问 Gif 演示图：通过CGI程序传递下拉数据。HTML 下拉框代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/cgi-bin/dropdown.py\" method=\"post\" target=\"_blank\"&gt;&lt;select name=\"dropdown\"&gt;&lt;option value=\"runoob\" selected&gt;菜鸟教程&lt;/option&gt;&lt;option value=\"google\"&gt;Google&lt;/option&gt;&lt;/select&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;dropdown.py 脚本代码如下所示：#!/usr/bin/python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form = cgi.FieldStorage() # 接收字段数据if form.getvalue('dropdown'): dropdown_value = form.getvalue('dropdown')else: dropdown_value = \"没有内容\"print \"Content-type:text/html\"printprint \"&lt;html&gt;\"print \"&lt;head&gt;\"print \"&lt;meta charset=\\\"utf-8\\\"&gt;\"print \"&lt;title&gt;菜鸟教程 CGI 测试实例&lt;/title&gt;\"print \"&lt;/head&gt;\"print \"&lt;body&gt;\"print \"&lt;h2&gt; 选中的选项是：%s&lt;/h2&gt;\" % dropdown_valueprint \"&lt;/body&gt;\"print \"&lt;/html&gt;\"修改 dropdown.py 权限：chmod 755 dropdown.py浏览器访问 Gif 演示图：CGI中使用Cookie在 http 协议一个很大的缺点就是不对用户身份的进行判断，这样给编程人员带来很大的不便， 而 cookie 功能的出现弥补了这个不足。cookie 就是在客户访问脚本的同时，通过客户的浏览器，在客户硬盘上写入纪录数据 ，当下次客户访问脚本时取回数据信息，从而达到身份判别的功能，cookie 常用在身份校验中。 cookie的语法http cookie的发送是通过http头部来实现的，他早于文件的传递，头部set-cookie的语法如下：Set-cookie:name=name;expires=date;path=path;domain=domain;secure name=name: 需要设置cookie的值(name不能使用\";\"和\",\"号),有多个name值时用 \";\" 分隔，例如：name1=name1;name2=name2;name3=name3。expires=date: cookie的有效期限,格式： expires=\"Wdy,DD-Mon-YYYY HH:MM:SS\"path=path: 设置cookie支持的路径,如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效，例如： path=\"/cgi-bin/\"，如果path是一个文件，则cookie指对这个文件生效，例如：path=\"/cgi-bin/cookie.cgi\"。domain=domain: 对cookie生效的域名，例如：domain=\"www.runoob.com\"secure: 如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递。cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息。Cookie设置Cookie的设置非常简单，cookie会在http头部单独发送。以下实例在cookie中设置了name 和 expires：#!/usr/bin/python# -*- coding: UTF-8 -*-# print 'Content-Type: text/html'print 'Set-Cookie: name=\"菜鸟教程\";expires=Wed, 28 Aug 2016 18:30:00 GMT'printprint \"\"\"&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Cookie set OK!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"将以上代码保存到 cookie_set.py，并修改 cookie_set.py 权限：chmod 755 cookie_set.py以上实例使用了 Set-Cookie 头信息来设置Cookie信息，可选项中设置了Cookie的其他属性，如过期时间Expires，域名Domain，路径Path。这些信息设置在 \"Content-type:text/html\"之前。检索Cookie信息Cookie信息检索页非常简单，Cookie信息存储在CGI的环境变量HTTP_COOKIE中，存储格式如下：key1=value1;key2=value2;key3=value3....以下是一个简单的CGI检索cookie信息的程序：#!/usr/bin/python# -*- coding: UTF-8 -*-# 导入模块import osimport Cookieprint \"Content-type: text/html\"printprint \"\"\"&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;读取cookie信息&lt;/h1&gt;\"\"\"if 'HTTP_COOKIE' in os.environ: cookie_string=os.environ.get('HTTP_COOKIE') c=Cookie.SimpleCookie() c.load(cookie_string) try: data=c['name'].value print \"cookie data: \"+data+\"&lt;br&gt;\" except KeyError: print \"cookie 没有设置或者已过期&lt;br&gt;\"print \"\"\"&lt;/body&gt;&lt;/html&gt;\"\"\"将以上代码保存到 cookie_get.py，并修改 cookie_get.py 权限：chmod 755 cookie_get.py以上 cookie 设置颜色 Gif 如下所示：文件上传实例HTML设置上传文件的表单需要设置 enctype 属性为 multipart/form-data，代码如下所示：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form enctype=\"multipart/form-data\" action=\"/cgi-bin/save_file.py\" method=\"post\"&gt; &lt;p&gt;选中文件: &lt;input type=\"file\" name=\"filename\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"上传\" /&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;save_file.py脚本文件代码如下：#!/usr/bin/python# -*- coding: UTF-8 -*-import cgi, osimport cgitb; cgitb.enable()form = cgi.FieldStorage()# 获取文件名fileitem = form['filename']# 检测文件是否上传if fileitem.filename: # 设置文件路径 fn = os.path.basename(fileitem.filename) open('/tmp/' + fn, 'wb').write(fileitem.file.read()) message = '文件 \"' + fn + '\" 上传成功' else: message = '文件没有上传' print \"\"\"\\Content-Type: text/html\\n&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;%s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\"\" % (message,)将以上代码保存到 save_file.py，并修改 save_file.py 权限：chmod 755 save_file.py以上 cookie 设置颜色 Gif 如下所示：如果你使用的系统是Unix/Linux，你必须替换文件分隔符，在window下只需要使用open()语句即可：fn = os.path.basename(fileitem.filename.replace(\"\\\\\", \"/\" ))文件下载对话框我们先在当前目录下创建 foo.txt 文件，用于程序的下载。文件下载通过设置HTTP头信息来实现，功能代码如下：#!/usr/bin/python# -*- coding: UTF-8 -*-# HTTP 头部print \"Content-Disposition: attachment; filename=\\\"foo.txt\\\"\";print# 打开文件fo = open(\"foo.txt\", \"rb\")str = fo.read();print str# 关闭文件fo.close()","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 网络编程 day 09-5","slug":"study python 9day-5","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:31:23.059Z","comments":true,"path":"2019/12/27/study python 9day-5/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-5/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Python 网络编程Python 提供了两个级别访问的网络服务。：低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。什么是 Socket?Socket又称\"套接字\"，应用程序通常通过\"套接字\"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。socket()函数Python 中，我们用 socket（）函数来创建套接字，语法格式如下：socket.socket([family[, type[, proto]]])参数family: 套接字家族可以使AF_UNIX或者AF_INETtype: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAMprotocol: 一般不填默认为0.Socket 对象(内建)方法函数 描述服务器端套接字s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来客户端套接字s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常公共用途的套接字函数s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。s.sendall() 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。s.close() 关闭套接字s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port)s.setsockopt(level,optname,value) 设置给定套接字选项的值。s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。s.fileno() 返回套接字的文件描述符。s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。s.makefile() 创建一个与该套接字相关连的文件简单实例服务端我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 port(端口)。接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端。完整代码如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名：server.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口 s.bind((host, port)) # 绑定端口 s.listen(5) # 等待客户端连接 while True: c,addr = s.accept() # 建立客户端连接 print '连接地址：', addr c.send('欢迎访问菜鸟教程！') c.close() # 关闭连接客户端接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 12345。socket.connect(hosname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。完整代码如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名：client.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口号 s.connect((host, port)) print s.recv(1024) s.close()现在我们打开两个终端，第一个终端执行 server.py 文件：$ python server.py第二个终端执行 client.py 文件：$ python client.py 欢迎访问菜鸟教程！这时我们再打开第一个终端，就会看到有以下信息输出：连接地址： ('192.168.0.118', 62461)Python Internet 模块以下列出了 Python 网络编程的一些重要模块：协议 功能用处 端口号 Python 模块HTTP 网页访问 80 httplib, urllib, xmlrpclibNNTP 阅读和张贴新闻文章，俗称为\"帖子\" 119 nntplibFTP 文件传输 20 ftplib, urllibSMTP 发送邮件 25 smtplibPOP3 接收邮件 110 poplibIMAP4 获取邮件 143 imaplibTelnet 命令行 23 telnetlibGopher 信息查找 70 gopherlib, urllib","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 数字 数组 列表 元组 集合 字典 day 09-2","slug":"study python 9day-2","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:28:20.963Z","comments":true,"path":"2019/12/27/study python 9day-2/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846Python Number(数字)Python Number 数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。以下实例在变量赋值时 Number 对象将被创建：var1 = 1var2 = 10您也可以使用del语句删除一些 Number 对象引用。del语句的语法是：del var1[,var2[,var3[....,varN]]]]您可以通过使用del语句删除单个或多个对象，例如：del vardel var_a, var_bPython 支持四种不同的数值类型：整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。长整型(long integers) - 无限大小的整数，整数最后是一个大写或小写的L。浮点型(floating point real values) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数(complex numbers) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。int long float complex10 51924361L 0.0 3.14j100 -0x19323L 15.20 45.j-786 0122L -21.9 9.322e-36j080 0xDEFABCECBDAECBFBAEl 32.3+e18 .876j-0490 535633629843L -90. -.6545+0J-0x260 -052318172735L -32.54e100 3e+26J0x69 -4721885298529L 70.2-E12 4.53e-7j长整型也可以使用小写\"L\"，但是还是建议您使用大写\"L\"，避免与数字\"1\"混淆。Python使用\"L\"来显示长整型。Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型Python Number 类型转换int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 Python math 模块、cmath 模块Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。Python math 模块提供了许多对浮点数的数学运算函数。Python cmath 模块包含了一些用于复数运算的函数。cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。要使用 math 或 cmath 函数必须先导入：import math查看 math 查看包中的内容:&gt;&gt;&gt; import math&gt;&gt;&gt; dir(math)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']&gt;&gt;&gt;下文会介绍各个函数的具体应用。查看 cmath 查看包中的内容&gt;&gt;&gt; import cmath&gt;&gt;&gt; dir(cmath)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'e', 'exp', 'inf', 'infj', 'isclose', 'isfinite', 'isinf', 'isnan', 'log', 'log10', 'nan', 'nanj', 'phase', 'pi', 'polar', 'rect', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau']&gt;&gt;&gt;实例&gt;&gt;&gt; import cmath&gt;&gt;&gt; cmath.sqrt(-1)1j&gt;&gt;&gt; cmath.sqrt(9)(3+0j)&gt;&gt;&gt; cmath.sin(1)(0.8414709848078965+0j)&gt;&gt;&gt; cmath.log10(100)(2+0j)&gt;&gt;&gt;Python数学函数函数 返回值 ( 描述 )abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。sqrt(x) 返回数字x的平方根Python随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。Python包含以下常用随机数函数：函数 描述choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1random() 随机生成下一个实数，它在[0,1)范围内。seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。shuffle(lst) 将序列的所有元素随机排序uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。Python三角函数Python包括以下三角函数：函数 描述acos(x) 返回x的反余弦弧度值。asin(x) 返回x的反正弦弧度值。atan(x) 返回x的反正切弧度值。atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。cos(x) 返回x的弧度的余弦值。hypot(x, y) 返回欧几里德范数 sqrt(x*x + y*y)。sin(x) 返回的x弧度的正弦值。tan(x) 返回x弧度的正切值。degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0radians(x) 将角度转换为弧度Python 字符串字符串是 Python 中最常用的数据类型。我们可以使用引号('或\")来创建字符串。创建字符串很简单，只要为变量分配一个值即可。例如：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#000000\"&gt;var1 &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;=&lt;/span&gt; &lt;span style=\"color:#008800\"&gt;'Hello World!'&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;var2 &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;=&lt;/span&gt; &lt;span style=\"color:#008800\"&gt;\"Python Runoob\"&lt;/span&gt;&lt;/span&gt;Python 访问字符串中的值Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。Python 访问子字符串，可以使用方括号来截取字符串，如下实例：实例(Python 2.0+)#!/usr/bin/python var1 = 'Hello World!' var2 = \"Python Runoob\" print \"var1[0]: \", var1[0] print \"var2[1:5]: \", var2[1:5]以上实例执行结果：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#000000\"&gt;var1&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;[&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;0&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;]:&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; Hvar2&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;[&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;1&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;:&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;5&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;]:&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; ytho&lt;/span&gt;&lt;/span&gt;Python 字符串连接我们可以对字符串进行截取并与其他字符串进行连接，如下实例：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- var1 = 'Hello World!' print \"输出 :- \", var1[:6] + 'Runoob!'以上实例执行结果&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#666600\"&gt;输出&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;:-&lt;/span&gt; &lt;span style=\"color:#660066\"&gt;Hello&lt;/span&gt; &lt;span style=\"color:#660066\"&gt;Runoob&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;!&lt;/span&gt;&lt;/span&gt;Python 转义字符在需要在字符中使用特殊字符时，python 用反斜杠 \\ 转义字符。如下表：转义字符 描述\\(在行尾时) 续行符\\\\ 反斜杠符号\\' 单引号\\\" 双引号\\a 响铃\\b 退格(Backspace)\\e 转义\\000 空\\n 换行\\v 纵向制表符\\t 横向制表符\\r 回车\\f 换页\\oyy 八进制数，yy代表的字符，例如：\\o12代表换行\\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行\\other 其它的字符以普通格式输出Python字符串运算符下表实例变量 a 值为字符串 \"Hello\"，b 变量值为 \"Python\"：操作符 描述 实例+ 字符串连接 &gt;&gt;&gt;a + b 'HelloPython'* 重复输出字符串 &gt;&gt;&gt;a * 2 'HelloHello'[] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1] 'e'[ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4] 'ell'in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;\"H\" in a Truenot in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;\"M\" not in a Truer/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母\"r\"（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r'\\n' \\n &gt;&gt;&gt; print R'\\n' \\n% 格式字符串 请看下一章节实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- a = \"Hello\" b = \"Python\" print \"a + b 输出结果：\", a + b print \"a * 2 输出结果：\", a * 2 print \"a[1] 输出结果：\", a[1] print \"a[1:4] 输出结果：\", a[1:4] if( \"H\" in a) : print \"H 在变量 a 中\" else : print \"H 不在变量 a 中\" if( \"M\" not in a) : print \"M 不在变量 a 中\" else : print \"M 在变量 a 中\" print r'\\n' print R'\\n'以上程序执行结果为：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#000000\"&gt;a &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;+&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; b &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;输出结果：&lt;/span&gt; &lt;span style=\"color:#660066\"&gt;HelloPython&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;a &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;*&lt;/span&gt; &lt;span style=\"color:#006666\"&gt;2&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;输出结果：&lt;/span&gt; &lt;span style=\"color:#660066\"&gt;HelloHello&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;a&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;[&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;1&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;]&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;输出结果：&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; ea&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;[&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;1&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;:&lt;/span&gt;&lt;span style=\"color:#006666\"&gt;4&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;]&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;输出结果：&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; ellH &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;在变量&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; a &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;中&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;M &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;不在变量&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; a &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;中&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;\\n\\n&lt;/span&gt;&lt;/span&gt;Python 字符串格式化Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。如下实例：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#880000\"&gt;#!/usr/bin/python&lt;/span&gt;&lt;span style=\"color:#000088\"&gt;print&lt;/span&gt; &lt;span style=\"color:#008800\"&gt;\"My name is %s and weight is %d kg!\"&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;%&lt;/span&gt; &lt;span style=\"color:#666600\"&gt;(&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'Zara'&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;,&lt;/span&gt; &lt;span style=\"color:#006666\"&gt;21&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;)&lt;/span&gt; &lt;/span&gt;以上实例输出结果：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#660066\"&gt;My&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; name &lt;/span&gt;&lt;span style=\"color:#000088\"&gt;is&lt;/span&gt; &lt;span style=\"color:#660066\"&gt;Zara&lt;/span&gt; &lt;span style=\"color:#000088\"&gt;and&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; weight &lt;/span&gt;&lt;span style=\"color:#000088\"&gt;is&lt;/span&gt; &lt;span style=\"color:#006666\"&gt;21&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; kg&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;!&lt;/span&gt;&lt;/span&gt;python 字符串格式化符号: 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %F 和 %E 的简写 %p 用十六进制数格式化变量的地址格式化操作符辅助指令:符号 功能* 定义宽度或者小数点精度- 用做左对齐+ 在正数前面显示加号( + )&lt;sp&gt; 在正数前面显示空格# 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')0 显示的数字前面填充'0'而不是默认的空格% '%%'输出一个单一的'%'(var) 映射变量(字典参数)m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。Python三引号（triple quotes）python中三引号可以将复杂的字符串进行复制:python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。&lt;span style=\"color:#333333\"&gt; &lt;span style=\"color:#666600\"&gt;&gt;&gt;&gt;&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; hi &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;=&lt;/span&gt; &lt;span style=\"color:#008800\"&gt;'''hi there'''&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;&gt;&gt;&gt;&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; hi &lt;/span&gt;&lt;span style=\"color:#880000\"&gt;# repr()&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'hi\\nthere'&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;&gt;&gt;&gt;&lt;/span&gt; &lt;span style=\"color:#000088\"&gt;print&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; hi &lt;/span&gt;&lt;span style=\"color:#880000\"&gt;# str()&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;hi there &lt;/span&gt;&lt;/span&gt;三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。一个典型的用例是，当你需要一块HTML或者SQL时，这时当用三引号标记，使用传统的转义字符体系将十分费神。&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#000000\"&gt; errHTML &lt;/span&gt;&lt;span style=\"color:#666600\"&gt;=&lt;/span&gt; &lt;span style=\"color:#008800\"&gt;'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=\"window.history.back()\"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;'''&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;cursor&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;.&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;execute&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;(&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'''CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)'''&lt;/span&gt;&lt;span style=\"color:#666600\"&gt;)&lt;/span&gt;&lt;/span&gt;Unicode 字符串Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#666600\"&gt;&gt;&gt;&gt;&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; u&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'Hello World !'&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;u&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'Hello World !'&lt;/span&gt;&lt;/span&gt;引号前小写的\"u\"表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。如下例所示：&lt;span style=\"color:#333333\"&gt;&lt;span style=\"color:#666600\"&gt;&gt;&gt;&gt;&lt;/span&gt;&lt;span style=\"color:#000000\"&gt; u&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'Hello\\u0020World !'&lt;/span&gt;&lt;span style=\"color:#000000\"&gt;u&lt;/span&gt;&lt;span style=\"color:#008800\"&gt;'Hello World !'&lt;/span&gt;&lt;/span&gt;被替换的 \\u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。python的字符串内建函数字符串方法是从python1.6到2.0慢慢加进来的——它们也被加到了Jython中。这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。方法 描述string.capitalize()把字符串的第一个字符大写string.center(width)返回一个原字符串居中,并使用空格填充至长度 width 的新字符串string.count(str, beg=0, end=len(string))返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数string.decode(encoding='UTF-8', errors='strict')以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 'ignore' 或 者'replace'string.encode(encoding='UTF-8', errors='strict')以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'string.endswith(obj, beg=0, end=len(string))检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.string.expandtabs(tabsize=8)把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。string.find(str, beg=0, end=len(string))检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1string.format()格式化字符串string.index(str, beg=0, end=len(string))跟find()方法一样，只不过如果str不在 string中会报一个异常.string.isalnum()如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 Falsestring.isalpha()如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 Falsestring.isdecimal()如果 string 只包含十进制数字则返回 True 否则返回 False.string.isdigit()如果 string 只包含数字则返回 True 否则返回 False.string.islower()如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 Falsestring.isnumeric()如果 string 中只包含数字字符，则返回 True，否则返回 Falsestring.isspace()如果 string 中只包含空格，则返回 True，否则返回 False.string.istitle()如果 string 是标题化的(见 title())则返回 True，否则返回 Falsestring.isupper()如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 Falsestring.join(seq)以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串string.ljust(width)返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串string.lower()转换 string 中所有大写字符为小写.string.lstrip()截掉 string 左边的空格string.maketrans(intab, outtab])maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。max(str)返回字符串 str 中最大的字母。min(str)返回字符串 str 中最小的字母。string.partition(str)有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.string.replace(str1, str2, num=string.count(str1))把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.string.rfind(str, beg=0,end=len(string) )类似于 find()函数，不过是从右边开始查找.string.rindex( str, beg=0,end=len(string))类似于 index()，不过是从右边开始.string.rjust(width)返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串string.rpartition(str)类似于 partition()函数,不过是从右边开始查找string.rstrip()删除 string 字符串末尾的空格.string.split(str=\"\", num=string.count(str))以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串string.splitlines([keepends])按照行('\\r', '\\r\\n', \\n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。string.startswith(obj, beg=0,end=len(string))检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.string.strip([obj])在 string 上执行 lstrip()和 rstrip()string.swapcase()翻转 string 中的大小写string.title()返回\"标题化\"的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())string.translate(str, del=\"\")根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中string.upper()转换 string 中的小写字母为大写string.zfill(width)返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0Python数学常量常量 描述pi 数学常量 pi（圆周率，一般以π来表示）e 数学常量 e，e即自然常数（自然常数）。Python 列表(List)序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。Python有6个序列的内置类型，但最常见的是列表和元组。序列都可以进行的操作包括索引，切片，加，乘，检查成员。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：list1 = ['physics', 'chemistry', 1997, 2000] list2 = [1, 2, 3, 4, 5 ] list3 = [\"a\", \"b\", \"c\", \"d\"]与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。访问列表中的值使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：实例(Python 2.0+)#!/usr/bin/python list1 = ['physics', 'chemistry', 1997, 2000] list2 = [1, 2, 3, 4, 5, 6, 7 ] print \"list1[0]: \", list1[0] print \"list2[1:5]: \", list2[1:5]以上实例输出结果：list1[0]: physicslist2[1:5]: [2, 3, 4, 5]更新列表你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- list = [] ## 空列表 list.append('Google') ## 使用 append() 添加元素 list.append('Runoob') print list注意：我们会在接下来的章节讨论append()方法的使用以上实例输出结果：['Google', 'Runoob']删除列表元素可以使用 del 语句来删除列表的元素，如下实例：实例(Python 2.0+)#!/usr/bin/python list1 = ['physics', 'chemistry', 1997, 2000] print list1 del list1[2] print \"After deleting value at index 2 : \" print list1以上实例输出结果：['physics', 'chemistry', 1997, 2000]After deleting value at index 2 :['physics', 'chemistry', 2000]注意：我们会在接下来的章节讨论remove()方法的使用Python列表脚本操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。如下所示：Python 表达式 结果 描述len([1, 2, 3]) 3 长度[1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合['Hi!'] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复3 in [1, 2, 3] True 元素是否存在于列表中for x in [1, 2, 3]: print x, 1 2 3 迭代Python列表截取Python 的列表截取实例如下：&gt;&gt;&gt;L = ['Google', 'Runoob', 'Taobao'] &gt;&gt;&gt; L[2] 'Taobao' &gt;&gt;&gt; L[-2] 'Runoob' &gt;&gt;&gt; L[1:] ['Runoob', 'Taobao'] &gt;&gt;&gt;描述：Python 表达式 结果 描述L[2] 'Taobao' 读取列表中第三个元素L[-2] 'Runoob' 读取列表中倒数第二个元素L[1:] ['Runoob', 'Taobao'] 从第二个元素开始截取列表Python列表函数&amp;方法Python包含以下函数:序号 函数1 cmp(list1, list2)比较两个列表的元素2 len(list)列表元素个数3 max(list)返回列表元素最大值4 min(list)返回列表元素最小值5 list(seq)将元组转换为列表Python包含以下方法:序号 方法1 list.append(obj)在列表末尾添加新的对象2 list.count(obj)统计某个元素在列表中出现的次数3 list.extend(seq)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）4 list.index(obj)从列表中找出某个值第一个匹配项的索引位置5 list.insert(index, obj)将对象插入列表6 list.pop([index=-1])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值7 list.remove(obj)移除列表中某个值的第一个匹配项8 list.reverse()反向列表中元素9 list.sort(cmp=None, key=None, reverse=False)对原列表进行排序Python 元组Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。如下实例：实例(Python 2.0+)tup1 = ('physics', 'chemistry', 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = \"a\", \"b\", \"c\", \"d\"创建空元组tup1 = ()元组中只包含一个元素时，需要在元素后面添加逗号tup1 = (50,)元组与字符串类似，下标索引从0开始，可以进行截取，组合等。访问元组元组可以使用下标索引来访问元组中的值，如下实例:实例(Python 2.0+)#!/usr/bin/python tup1 = ('physics', 'chemistry', 1997, 2000) tup2 = (1, 2, 3, 4, 5, 6, 7 ) print \"tup1[0]: \", tup1[0] print \"tup2[1:5]: \", tup2[1:5]以上实例输出结果：tup1[0]: physicstup2[1:5]: (2, 3, 4, 5)修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- tup1 = (12, 34.56) tup2 = ('abc', 'xyz') # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2 print tup3以上实例输出结果：(12, 34.56, 'abc', 'xyz')删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:实例(Python 2.0+)#!/usr/bin/python tup = ('physics', 'chemistry', 1997, 2000) print tup del tup print \"After deleting tup : \" print tup以上实例元组被删除后，输出变量会有异常信息，输出如下所示：('physics', 'chemistry', 1997, 2000)After deleting tup :Traceback (most recent call last): File \"test.py\", line 9, in &lt;module&gt; print tupNameError: name 'tup' is not defined元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。Python 表达式 结果 描述len((1, 2, 3)) 3 计算元素个数(1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接('Hi!',) * 4 ('Hi!', 'Hi!', 'Hi!', 'Hi!') 复制3 in (1, 2, 3) True 元素是否存在for x in (1, 2, 3): print x, 1 2 3 迭代元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：元组：L = ('spam', 'Spam', 'SPAM!')Python 表达式 结果 描述L[2] 'SPAM!' 读取第三个元素L[-2] 'Spam' 反向读取，读取倒数第二个元素L[1:] ('Spam', 'SPAM!') 截取元素无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组，如下实例：实例(Python 2.0+)#!/usr/bin/python print 'abc', -4.24e93, 18+6.6j, 'xyz' x, y = 1, 2 print \"Value of x , y : \", x,y以上实例运行结果：abc -4.24e+93 (18+6.6j) xyzValue of x , y : 1 2元组内置函数Python元组包含了以下内置函数序号 方法及描述1 cmp(tuple1, tuple2)比较两个元组元素。2 len(tuple)计算元组元素个数。3 max(tuple)返回元组中元素最大值。4 min(tuple)返回元组中元素最小值。5 tuple(seq)将列表转换为元组。Python 字典(Dictionary)字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 &#123;&#125; 中 ,格式如下所示：d = &#123;key1 : value1, key2 : value2 &#125;键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。&gt;&gt;&gt;dict = &#123;'a': 1, 'b': 2, 'b': '3'&#125; &gt;&gt;&gt; dict['b'] '3' &gt;&gt;&gt; dict &#123;'a': 1, 'b': '3'&#125;值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。一个简单的字典实例：dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125;也可如此创建字典：dict1 = &#123; 'abc': 456 &#125; dict2 = &#123; 'abc': 123, 98.6: 37 &#125;访问字典里的值把相应的键放入熟悉的方括弧，如下实例:实例#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; print \"dict['Name']: \", dict['Name'] print \"dict['Age']: \", dict['Age']以上实例输出结果：dict['Name']: Zaradict['Age']: 7如果用字典里没有的键访问数据，会输出错误如下：实例#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; print \"dict['Alice']: \", dict['Alice']以上实例输出结果：dict['Alice']: Traceback (most recent call last): File \"test.py\", line 5, in &lt;module&gt; print \"dict['Alice']: \", dict['Alice']KeyError: 'Alice'修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:实例#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; dict['Age'] = 8 # 更新 dict['School'] = \"RUNOOB\" # 添加 print \"dict['Age']: \", dict['Age'] print \"dict['School']: \", dict['School']以上实例输出结果：dict['Age']: 8dict['School']: RUNOOB删除字典元素能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用del命令，如下实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; del dict['Name'] # 删除键是'Name'的条目 dict.clear() # 清空字典所有条目 del dict # 删除字典 print \"dict['Age']: \", dict['Age'] print \"dict['School']: \", dict['School']但这会引发一个异常，因为用del后字典不再存在：dict['Age']:Traceback (most recent call last): File \"test.py\", line 8, in &lt;module&gt; print \"dict['Age']: \", dict['Age'] TypeError: 'type' object is unsubscriptable注：del()方法后面也会讨论。字典键的特性字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。两个重要的点需要记住：1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：实例#!/usr/bin/python dict = &#123;'Name': 'Zara', 'Age': 7, 'Name': 'Manni'&#125; print \"dict['Name']: \", dict['Name']以上实例输出结果：dict['Name']: Manni2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例：实例#!/usr/bin/python dict = &#123;['Name']: 'Zara', 'Age': 7&#125; print \"dict['Name']: \", dict['Name']以上实例输出结果：Traceback (most recent call last): File \"test.py\", line 3, in &lt;module&gt; dict = &#123;['Name']: 'Zara', 'Age': 7&#125; TypeError: list objects are unhashable字典内置函数&amp;方法Python字典包含了以下内置函数：序号 函数及描述1 cmp(dict1, dict2)比较两个字典元素。2 len(dict)计算字典元素个数，即键的总数。3 str(dict)输出字典可打印的字符串表示。4 type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。Python字典包含了以下内置方法：序号 函数及描述1 dict.clear()删除字典内所有元素2 dict.copy()返回一个字典的浅复制3 dict.fromkeys(seq[, val])创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值4 dict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值5 dict.has_key(key)如果键在字典dict里返回true，否则返回false6 dict.items()以列表返回可遍历的(键, 值) 元组数组7 dict.keys()以列表返回一个字典所有的键8 dict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default9 dict.update(dict2)把字典dict2的键/值对更新到dict里10 dict.values()以列表返回字典中的所有值11 pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。12 popitem()返回并删除字典中的最后一对键和值。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 2.X和3.X day 09-10","slug":"study python 9day-10","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:36:03.089Z","comments":true,"path":"2019/12/27/study python 9day-10/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-10/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223Python2.x与3​​.x版本区别Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。新的Python程式建议使用Python 3.0版本的语法。除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。Python 3.0的变化主要在以下几个方面:print 函数print语句没有了，取而代之的是print()函数。 Python 2.6与Python 2.7部分地支持这种形式的print语法。在Python 2.6与Python 2.7里面，以下三种形式是等价的：print \"fish\"print (\"fish\") #注意print后面有个空格print(\"fish\") #print()不能带有任何其它参数然而，Python 2.6实际已经支持新的print()语法：from __future__ import print_functionprint(\"fish\", \"panda\", sep=', ')UnicodePython 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。现在， 在 Python 3，我们最终有了 Unicode (utf-8) 字符串，以及一个字节类：byte 和 bytearrays。由于 Python3.X 源码文件默认使用utf-8编码，这就使得以下代码是合法的：&gt;&gt;&gt; 中国 = 'china' &gt;&gt;&gt;print(中国) chinaPython 2.x&gt;&gt;&gt; str = \"我爱北京天安门\"&gt;&gt;&gt; str'\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe5\\x8c\\x97\\xe4\\xba\\xac\\xe5\\xa4\\xa9\\xe5\\xae\\x89\\xe9\\x97\\xa8'&gt;&gt;&gt; str = u\"我爱北京天安门\"&gt;&gt;&gt; stru'\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8'Python 3.x&gt;&gt;&gt; str = \"我爱北京天安门\"&gt;&gt;&gt; str'我爱北京天安门'除法运算Python中的除法较其它语言显得非常高端，有套很复杂的规则。Python中的除法有两个运算符，/和//首先来说/除法:在python 2.x中/除法就跟我们熟悉的大多数语言，比如Java啊C啊差不多，整数相除的结果是一个整数，把小数部分完全忽略掉，浮点数除法会保留小数点的部分得到一个浮点数的结果。在python 3.x中/除法不再这么做了，对于整数之间的相除，结果也会是浮点数。Python 2.x:&gt;&gt;&gt; 1 / 20&gt;&gt;&gt; 1.0 / 2.00.5Python 3.x:&gt;&gt;&gt; 1/20.5而对于//除法，这种除法叫做floor除法，会对除法的结果自动进行一个floor操作，在python 2.x和python 3.x中是一致的。python 2.x:&gt;&gt;&gt; -1 // 2-1python 3.x:&gt;&gt;&gt; -1 // 2-1注意的是并不是舍弃小数部分，而是执行 floor 操作，如果要截取整数部分，那么需要使用 math 模块的 trunc 函数python 3.x:&gt;&gt;&gt; import math&gt;&gt;&gt; math.trunc(1 / 2)0&gt;&gt;&gt; math.trunc(-1 / 2)0异常在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。捕获异常的语法由 except exc, var 改为 except exc as var。使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。1. 在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代，只有继承自BaseException的对象才可以被抛出。2. 2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可。在2.x时代，异常在代码中除了表示程序错误，还经常做一些普通控制结构应该做的事情，在3.x中可以看出，设计者让异常变的更加专一，只有在错误发生的情况才能去用异常捕获语句来处理。xrange在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。这个表现十分像生成器（比如。\"惰性求值\"）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。import timeitn = 10000def test_range(n): return for i in range(n): passdef test_xrange(n): for i in xrange(n): pass Python 2print 'Python', python_version()print '\\ntiming range()' %timeit test_range(n)print '\\n\\ntiming xrange()' %timeit test_xrange(n)Python 2.7.6timing range()1000 loops, best of 3: 433 µs per looptiming xrange()1000 loops, best of 3: 350 µs per loopPython 3print('Python', python_version())print('\\ntiming range()')%timeit test_range(n)Python 3.4.1timing range()1000 loops, best of 3: 520 µs per loopprint(xrange(10))---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-5-5d8f9b79ea70&gt; in &lt;module&gt;()----&gt; 1 print(xrange(10))NameError: name 'xrange' is not defined八进制字面量表示八进制数必须写成0o777，原来的形式0777不能用了；二进制必须写成0b111。新增了一个bin()函数用于将一个整数转换成二进制字串。 Python 2.6已经支持这两种语法。在Python 3.x中，表示八进制字面量的方式只有一种，就是0o1000。python 2.x&gt;&gt;&gt; 0o1000512&gt;&gt;&gt; 01000512python 3.x&gt;&gt;&gt; 01000 File \"&lt;stdin&gt;\", line 1 01000 ^SyntaxError: invalid token&gt;&gt;&gt; 0o1000512不等运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt;Python 3.x中去掉了&lt;&gt;, 只有!=一种写法，还好，我从来没有使用&lt;&gt;的习惯去掉了repr表达式``Python 2.x 中反引号``相当于repr函数的作用Python 3.x 中去掉了``这种写法，只允许使用repr函数，这样做的目的是为了使代码看上去更清晰么？不过我感觉用repr的机会很少，一般只在debug的时候才用，多数时候还是用str函数来用字符串描述对象。def sendMail(from_: str, to: str, title: str, body: str) -&gt; bool: pass多个模块被改名（根据PEP8）旧的名字 新的名字_winreg winregConfigParser configparsercopy_reg copyregQueue queueSocketServer socketserverrepr reprlibStringIO模块现在被合并到新的io模组内。 new, md5, gopherlib等模块被删除。 Python 2.6已经支援新的io模组。httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib被合并到http包内。取消了exec语句，只剩下exec()函数。 Python 2.6已经支援exec()函数。5.数据类型1）Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long2）新增了bytes类型，对应于2.X版本的八位串，定义一个bytes字面量的方法如下：&gt;&gt;&gt; b = b'china' &gt;&gt;&gt; type(b) &lt;type 'bytes'&gt; str 对象和 bytes 对象可以使用 .encode() (str -&gt; bytes) 或 .decode() (bytes -&gt; str)方法相互转化。&gt;&gt;&gt; s = b.decode() &gt;&gt;&gt; s 'china' &gt;&gt;&gt; b1 = s.encode() &gt;&gt;&gt; b1 b'china' 3）dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python Myspl day 09-4","slug":"study python 9day-4","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:30:33.802Z","comments":true,"path":"2019/12/27/study python 9day-4/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-4/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328Python 操作 MySQL 数据库Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库：GadFlymSQLMySQLPostgreSQLMicrosoft SQL Server 2000InformixInterbaseOracleSybase你可以访问Python数据库接口及API查看详细的支持数据库列表。不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。Python DB-API使用流程：引入 API 模块。获取与数据库的连接。执行SQL语句和存储过程。关闭数据库连接。什么是MySQLdb?MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。如何安装MySQLdb?为了用DB-API编写MySQL脚本，必须确保已经安装了MySQL。复制以下代码，并执行：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb如果执行后的输出结果如下所示，意味着你没有安装 MySQLdb 模块：Traceback (most recent call last): File \"test.py\", line 3, in &lt;module&gt; import MySQLdbImportError: No module named MySQLdb安装MySQLdb，请访问 http://sourceforge.net/projects/mysql-python ，(Linux平台可以访问：https://pypi.python.org/pypi/MySQL-python)从这里可选择适合您的平台的安装包，分为预编译的二进制文件和源代码安装包。如果您选择二进制文件发行版本的话，安装过程基本安装提示即可完成。如果从源代码进行安装的话，则需要切换到MySQLdb发行版本的顶级目录，并键入下列命令:$ gunzip MySQL-python-1.2.2.tar.gz$ tar -xvf MySQL-python-1.2.2.tar$ cd MySQL-python-1.2.2$ python setup.py build$ python setup.py install注意：请确保您有root权限来安装上述模块。数据库连接连接数据库前，请先确认以下事项：您已经创建了数据库 TESTDB.在TESTDB数据库中您已经创建了表 EMPLOYEEEMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。连接数据库TESTDB使用的用户名为 \"testuser\" ，密码为 \"test123\",你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。在你的机子上已经安装了 Python MySQLdb 模块。如果您对sql语句不熟悉，可以访问我们的 SQL基础教程实例：以下实例链接Mysql的TESTDB数据库：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# 使用execute方法执行SQL语句cursor.execute(\"SELECT VERSION()\")# 使用 fetchone() 方法获取一条数据data = cursor.fetchone()print \"Database version : %s \" % data# 关闭数据库连接db.close()执行以上脚本输出结果如下：Database version : 5.0.45创建数据库表如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# 如果数据表已经存在使用 execute() 方法删除表。cursor.execute(\"DROP TABLE IF EXISTS EMPLOYEE\")# 创建数据表SQL语句sql = \"\"\"CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )\"\"\"cursor.execute(sql)# 关闭数据库连接db.close()数据库插入操作以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 插入语句sql = \"\"\"INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)\"\"\"try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # Rollback in case there is any error db.rollback()# 关闭数据库连接db.close()以上例子也可以写成如下形式：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 插入语句sql = \"INSERT INTO EMPLOYEE(FIRST_NAME, \\ LAST_NAME, AGE, SEX, INCOME) \\ VALUES (%s, %s, %s, %s, %s )\" % \\ ('Mac', 'Mohan', 20, 'M', 2000)try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close()实例：以下代码使用变量向SQL语句中传递参数:..................................user_id = \"test123\"password = \"password\"con.execute('insert into Login values(%s, %s)' % \\ (user_id, password))..................................数据库查询操作Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。fetchone(): 该方法获取下一个查询结果集。结果集是一个对象fetchall():接收全部的返回结果行.rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。实例：查询EMPLOYEE表中salary（工资）字段大于1000的所有数据：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 查询语句sql = \"SELECT * FROM EMPLOYEE \\ WHERE INCOME &gt; %s\" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print \"fname=%s,lname=%s,age=%s,sex=%s,income=%s\" % \\ (fname, lname, age, sex, income )except: print \"Error: unable to fecth data\"# 关闭数据库连接db.close()以上脚本执行结果如下：fname=Mac, lname=Mohan, age=20, sex=M, income=2000数据库更新操作更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 'M' 的 AGE 字段递增 1：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 更新语句sql = \"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'\" % ('M')try: # 执行SQL语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close()删除操作删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db = MySQLdb.connect(\"localhost\", \"testuser\", \"test123\", \"TESTDB\", charset='utf8' )# 使用cursor()方法获取操作游标 cursor = db.cursor()# SQL 删除语句sql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)try: # 执行SQL语句 cursor.execute(sql) # 提交修改 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭连接db.close()执行事务事务机制可以确保数据一致性。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。实例：# SQL删除记录语句sql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; %s\" % (20)try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit()except: # 发生错误时回滚 db.rollback()对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。错误处理DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:异常 描述Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。Error 警告以外所有其他错误类。必须是 StandardError 的子类。InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python SMTP发送邮件 day 09-6","slug":"study python 9day-6","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:32:24.949Z","comments":true,"path":"2019/12/27/study python 9day-6/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-6/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111Python SMTP发送邮件SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。Python创建 SMTP 对象语法如下：import smtplibsmtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )参数说明：host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如: runoob.com，这个是可选参数。port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下 SMTP 端口号为25。local_hostname: 如果 SMTP 在你的本机上，你只需要指定服务器地址为 localhost 即可。Python SMTP 对象使用 sendmail 方法发送邮件，语法如下：SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])参数说明：from_addr: 邮件发送者地址。to_addrs: 字符串列表，邮件发送地址。msg: 发送消息这里要注意一下第三个参数，msg 是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意 msg 的格式。这个格式就是 smtp 协议中定义的格式。实例以下执行实例需要你本机已安装了支持 SMTP 的服务，如：sendmail。以下是一个使用 Python 发送邮件简单的实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header sender = 'from@runoob.com' receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8') message['From'] = Header(\"菜鸟教程\", 'utf-8') # 发送者 message['To'] = Header(\"测试\", 'utf-8') # 接收者 subject = 'Python SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\" except smtplib.SMTPException: print \"Error: 无法发送邮件\"我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： From, To, 和 Subject ，每个信息直接使用空行分割。我们通过实例化 smtplib 模块的 SMTP 对象 smtpObj 来连接到 SMTP 访问，并使用 sendmail 方法来发送信息。执行以上程序，如果你本机安装 sendmail（邮件传输代理程序），就会输出：$ python test.py 邮件发送成功查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：如果我们本机没有 sendmail 访问，也可以使用其他邮件服务商的 SMTP 访问（QQ、网易、Google等）。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header # 第三方 SMTP 服务 mail_host=\"smtp.XXX.com\" #设置服务器 mail_user=\"XXXX\" #用户名 mail_pass=\"XXXXXX\" #口令 sender = 'from@runoob.com' receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8') message['From'] = Header(\"菜鸟教程\", 'utf-8') message['To'] = Header(\"测试\", 'utf-8') subject = 'Python SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\" except smtplib.SMTPException: print \"Error: 无法发送邮件\"使用Python发送HTML格式的邮件Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header sender = 'from@runoob.com' receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 mail_msg = \"\"\" &lt;p&gt;Python 邮件发送测试...&lt;/p&gt; &lt;p&gt;&lt;a href=\"http://www.runoob.com\"&gt;这是一个链接&lt;/a&gt;&lt;/p&gt; \"\"\" message = MIMEText(mail_msg, 'html', 'utf-8') message['From'] = Header(\"菜鸟教程\", 'utf-8') message['To'] = Header(\"测试\", 'utf-8') subject = 'Python SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\" except smtplib.SMTPException: print \"Error: 无法发送邮件\"执行以上程序，如果你本机安装sendmail，就会输出：$ python test.py 邮件发送成功查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：Python 发送带附件的邮件发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.header import Header sender = 'from@runoob.com' receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例 message = MIMEMultipart() message['From'] = Header(\"菜鸟教程\", 'utf-8') message['To'] = Header(\"测试\", 'utf-8') subject = 'Python SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') #邮件正文内容 message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件 att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8') att1[\"Content-Type\"] = 'application/octet-stream' # 这里的filename可以任意写，写什么名字，邮件中显示什么名字 att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"' message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件 att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8') att2[\"Content-Type\"] = 'application/octet-stream' att2[\"Content-Disposition\"] = 'attachment; filename=\"runoob.txt\"' message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print \"邮件发送成功\" except smtplib.SMTPException: print \"Error: 无法发送邮件\"$ python test.py 邮件发送成功查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：在 HTML 文本中添加图片邮件的 HTML 文本中一般邮件服务商添加外链是无效的，正确添加图片的实例如下所示：实例#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.header import Header sender = 'from@runoob.com' receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart('related') msgRoot['From'] = Header(\"菜鸟教程\", 'utf-8') msgRoot['To'] = Header(\"测试\", 'utf-8') subject = 'Python SMTP 邮件测试' msgRoot['Subject'] = Header(subject, 'utf-8') msgAlternative = MIMEMultipart('alternative') msgRoot.attach(msgAlternative) mail_msg = \"\"\" &lt;p&gt;Python 邮件发送测试...&lt;/p&gt; &lt;p&gt;&lt;a href=\"http://www.runoob.com\"&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt; &lt;p&gt;图片演示：&lt;/p&gt; &lt;p&gt;&lt;img src=\"cid:image1\"&gt;&lt;/p&gt; \"\"\" msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8')) # 指定图片为当前目录 fp = open('test.png', 'rb') msgImage = MIMEImage(fp.read()) fp.close() # 定义图片 ID，在 HTML 文本中引用 msgImage.add_header('Content-ID', '&lt;image1&gt;') msgRoot.attach(msgImage) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print \"邮件发送成功\" except smtplib.SMTPException: print \"Error: 无法发送邮件\"$ python test.py 邮件发送成功查看我们的收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示)，就可以查看到邮件信息：使用第三方 SMTP 服务发送这里使用了 QQ 邮箱(你也可以使用 163，Gmail等)的 SMTP 服务，需要做以下配置：QQ 邮箱通过生成授权码来设置密码：QQ 邮箱 SMTP 服务器地址：smtp.qq.com，ssl 端口：465。以下实例你需要修改：发件人邮箱（你的QQ邮箱），密码，收件人邮箱（可发给自己）。QQ SMTP#!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.utils import formataddr my_sender='429240967@qq.com' # 发件人邮箱账号 my_pass = 'xxxxxxxxxx' # 发件人邮箱密码 my_user='429240967@qq.com' # 收件人邮箱账号，我这边发送给自己 def mail(): ret=True try: msg=MIMEText('填写邮件内容','plain','utf-8') msg['From']=formataddr([\"FromRunoob\",my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['To']=formataddr([\"FK\",my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['Subject']=\"菜鸟教程发送邮件测试\" # 邮件的主题，也可以说是标题 server=smtplib.SMTP_SSL(\"smtp.qq.com\", 465) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender,[my_user,],msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret=False return ret ret=mail() if ret: print(\"邮件发送成功\") else: print(\"邮件发送失败\")$ python test.py 邮件发送成功发送成功后，登陆收件人邮箱即可查看：更多内容请参阅：https://docs.python.org/2/library/email-examples.html。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 多线程 day 09-7","slug":"study python 9day-7","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:33:40.471Z","comments":true,"path":"2019/12/27/study python 9day-7/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-7/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138Python 多线程多线程类似于同时执行多个不同程序，多线程运行有如下优点：使用线程可以把占据长时间的程序中的任务放到后台去处理。用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度程序的运行速度可能加快在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。线程可以被抢占（中断）。在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） -- 这就是线程的退让。开始学习Python线程Python中使用线程有两种方式：函数或者用类来包装线程对象。函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:thread.start_new_thread ( function, args[, kwargs] )参数说明:function - 线程函数。args - 传递给线程函数的参数,他必须是个tuple类型。kwargs - 可选参数。实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import thread import time # 为线程定义一个函数 def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print \"%s: %s\" % ( threadName, time.ctime(time.time()) ) # 创建两个线程 try: thread.start_new_thread( print_time, (\"Thread-1\", 2, ) ) thread.start_new_thread( print_time, (\"Thread-2\", 4, ) ) except: print \"Error: unable to start thread\" while 1: pass执行以上程序输出结果如下：Thread-1: Thu Jan 22 15:42:17 2009Thread-1: Thu Jan 22 15:42:19 2009Thread-2: Thu Jan 22 15:42:19 2009Thread-1: Thu Jan 22 15:42:21 2009Thread-2: Thu Jan 22 15:42:23 2009Thread-1: Thu Jan 22 15:42:23 2009Thread-1: Thu Jan 22 15:42:25 2009Thread-2: Thu Jan 22 15:42:27 2009Thread-2: Thu Jan 22 15:42:31 2009Thread-2: Thu Jan 22 15:42:35 2009线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，他抛出SystemExit exception，达到退出线程的目的。线程模块Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。threading 模块提供的其他方法：threading.currentThread(): 返回当前的线程变量。threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:run(): 用以表示线程活动的方法。start():启动线程活动。join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。isAlive(): 返回线程是否活动的。getName(): 返回线程名。setName(): 设置线程名。使用Threading模块创建线程使用Threading模块创建线程，直接从threading.Thread继承，然后重写__init__方法和run方法：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import threading import time exitFlag = 0 class myThread (threading.Thread): #继承父类threading.Thread def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 print \"Starting \" + self.name print_time(self.name, self.counter, 5) print \"Exiting \" + self.name def print_time(threadName, delay, counter): while counter: if exitFlag: (threading.Thread).exit() time.sleep(delay) print \"%s: %s\" % (threadName, time.ctime(time.time())) counter -= 1 # 创建新线程 thread1 = myThread(1, \"Thread-1\", 1) thread2 = myThread(2, \"Thread-2\", 2) # 开启线程 thread1.start() thread2.start() print \"Exiting Main Thread\"以上程序执行结果如下；Starting Thread-1Starting Thread-2Exiting Main ThreadThread-1: Thu Mar 21 09:10:03 2013Thread-1: Thu Mar 21 09:10:04 2013Thread-2: Thu Mar 21 09:10:04 2013Thread-1: Thu Mar 21 09:10:05 2013Thread-1: Thu Mar 21 09:10:06 2013Thread-2: Thu Mar 21 09:10:06 2013Thread-1: Thu Mar 21 09:10:07 2013Exiting Thread-1Thread-2: Thu Mar 21 09:10:08 2013Thread-2: Thu Mar 21 09:10:10 2013Thread-2: Thu Mar 21 09:10:12 2013Exiting Thread-2线程同步如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。如下：多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。考虑这样一种情况：一个列表里所有元素都是0，线程\"set\"从后向前把所有元素改成1，而线程\"print\"负责从前往后读取列表并打印。那么，可能线程\"set\"开始改的时候，线程\"print\"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。锁有两种状态——锁定和未锁定。每当一个线程比如\"set\"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如\"print\"获得锁定了，那么就让线程\"set\"暂停，也就是同步阻塞；等到线程\"print\"访问完毕，释放锁以后，再让线程\"set\"继续。经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import threading import time class myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print \"Starting \" + self.name # 获得锁，成功获得锁定后返回True # 可选的timeout参数不填时将一直阻塞直到获得锁定 # 否则超时后将返回False threadLock.acquire() print_time(self.name, self.counter, 3) # 释放锁 threadLock.release() def print_time(threadName, delay, counter): while counter: time.sleep(delay) print \"%s: %s\" % (threadName, time.ctime(time.time())) counter -= 1 threadLock = threading.Lock() threads = [] # 创建新线程 thread1 = myThread(1, \"Thread-1\", 1) thread2 = myThread(2, \"Thread-2\", 2) # 开启新线程 thread1.start() thread2.start() # 添加线程到线程列表 threads.append(thread1) threads.append(thread2) # 等待所有线程完成 for t in threads: t.join() print \"Exiting Main Thread\"线程优先级队列（ Queue）Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。Queue模块中的常用方法:Queue.qsize() 返回队列的大小Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之FalseQueue.full 与 maxsize 大小对应Queue.get([block[, timeout]])获取队列，timeout等待时间Queue.get_nowait() 相当Queue.get(False)Queue.put(item) 写入队列，timeout等待时间Queue.put_nowait(item) 相当Queue.put(item, False)Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号Queue.join() 实际上意味着等到队列为空，再执行别的操作实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import Queue import threading import time exitFlag = 0 class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print \"Starting \" + self.name process_data(self.name, self.q) print \"Exiting \" + self.name def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print \"%s processing %s\" % (threadName, data) else: queueLock.release() time.sleep(1) threadList = [\"Thread-1\", \"Thread-2\", \"Thread-3\"] nameList = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"] queueLock = threading.Lock() workQueue = Queue.Queue(10) threads = [] threadID = 1 # 创建新线程 for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1 # 填充队列 queueLock.acquire() for word in nameList: workQueue.put(word) queueLock.release() # 等待队列清空 while not workQueue.empty(): pass # 通知线程是时候退出 exitFlag = 1 # 等待所有线程完成 for t in threads: t.join() print \"Exiting Main Thread\"以上程序执行结果：Starting Thread-1Starting Thread-2Starting Thread-3Thread-1 processing OneThread-2 processing TwoThread-3 processing ThreeThread-1 processing FourThread-2 processing FiveExiting Thread-3Exiting Thread-1Exiting Thread-2Exiting Main Thread","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python GUI day 09-9","slug":"study python 9day-9","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:35:02.881Z","comments":true,"path":"2019/12/27/study python 9day-9/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-9/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Python GUI编程(Tkinter)Python 提供了多个图形开发界面的库，几个常用 Python GUI 库如下：Tkinter： Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。wxPython：wxPython 是一款开源软件，是 Python 语言的一套优秀的 GUI 图形库，允许 Python 程序员很方便的创建完整的、功能健全的 GUI 用户界面。Jython：Jython 程序可以和 Java 无缝集成。除了一些标准模块，Jython 使用 Java 的模块。Jython 几乎拥有标准的Python 中不依赖于 C 语言的全部模块。比如，Jython 的用户界面将使用 Swing，AWT或者 SWT。Jython 可以被动态或静态地编译成 Java 字节码。Tkinter 编程Tkinter 是 Python 的标准 GUI 库。Python 使用 Tkinter 可以快速的创建 GUI 应用程序。由于 Tkinter 是内置到 python 的安装包中、只要安装好 Python 之后就能 import Tkinter 库、而且 IDLE 也是用 Tkinter 编写而成、对于简单的图形界面 Tkinter 还是能应付自如。注意：Python3.x 版本使用的库名为 tkinter,即首写字母 T 为小写。import tkinter创建一个GUI程序1、导入 Tkinter 模块2、创建控件3、指定这个控件的 master， 即这个控件属于哪一个4、告诉 GM(geometry manager) 有一个控件产生了。实例#!/usr/bin/python # -*- coding: UTF-8 -*- import Tkinter top = Tkinter.Tk() # 进入消息循环 top.mainloop()以上代码执行结果如下图:实例#!/usr/bin/python # -*- coding: UTF-8 -*- from Tkinter import * # 导入 Tkinter 库 root = Tk() # 创建窗口对象的背景色 # 创建两个列表 li = ['C','python','php','html','SQL','java'] movie = ['CSS','jQuery','Bootstrap'] listb = Listbox(root) # 创建两个列表组件 listb2 = Listbox(root) for item in li: # 第一个小部件插入数据 listb.insert(0,item) for item in movie: # 第二个小部件插入数据 listb2.insert(0,item) listb.pack() # 将小部件放置到主窗口中 listb2.pack() root.mainloop() # 进入消息循环以上代码执行结果如下图:Tkinter 组件Tkinter的提供各种控件，如按钮，标签和文本框，一个GUI应用程序中使用。这些控件通常被称为控件或者部件。目前有15种Tkinter的部件。我们提出这些部件以及一个简短的介绍，在下面的表:控件 描述Button 按钮控件；在程序中显示按钮。Canvas 画布控件；显示图形元素如线条或文本Checkbutton 多选框控件；用于在程序中提供多项选择框Entry 输入控件；用于显示简单的文本内容Frame 框架控件；在屏幕上显示一个矩形区域，多用来作为容器Label 标签控件；可以显示文本和位图Listbox 列表框控件；在Listbox窗口小部件是用来显示一个字符串列表给用户Menubutton 菜单按钮控件，用于显示菜单项。Menu 菜单控件；显示菜单栏,下拉菜单和弹出菜单Message 消息控件；用来显示多行文本，与label比较类似Radiobutton 单选按钮控件；显示一个单选的按钮状态Scale 范围控件；显示一个数值刻度，为输出限定范围的数字区间Scrollbar 滚动条控件，当内容超过可视化区域时使用，如列表框。.Text 文本控件；用于显示多行文本Toplevel 容器控件；用来提供一个单独的对话框，和Frame比较类似Spinbox 输入控件；与Entry类似，但是可以指定输入范围值PanedWindow PanedWindow是一个窗口布局管理的插件，可以包含一个或者多个子控件。LabelFrame labelframe 是一个简单的容器控件。常用与复杂的窗口布局。tkMessageBox 用于显示你应用程序的消息框。标准属性标准属性也就是所有控件的共同属性，如大小，字体和颜色等等。属性 描述Dimension 控件大小；Color 控件颜色；Font 控件字体；Anchor 锚点；Relief 控件样式；Bitmap 位图；Cursor 光标；几何管理Tkinter控件有特定的几何状态管理方法，管理整个控件区域组织，一下是Tkinter公开的几何管理类：包、网格、位置几何方法 描述pack() 包装；grid() 网格；place() 位置；","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python XML day 09-8","slug":"study python 9day-8","date":"2019-12-27T12:00:01.000Z","updated":"2020-01-13T13:34:34.077Z","comments":true,"path":"2019/12/27/study python 9day-8/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day-8/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174Python XML 解析什么是 XML？XML 指可扩展标记语言（eXtensible Markup Language）。 你可以通过本站学习 XML 教程XML 被设计用来传输和存储数据。XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。Python 对 XML 的解析常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree:1.SAX (simple API for XML )Python 标准库包含 SAX 解析器，SAX 用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。2.DOM(Document Object Model)将 XML 数据在内存中解析成一个树，通过对树的操作来操作XML。3.ElementTree(元素树)ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。注：因DOM需要将XML数据映射到内存中的树，一是比较慢，二是比较耗内存，而SAX流式读取XML文件，比较快，占用内存少，但需要用户实现回调函数（handler）。本章节使用到的 XML 实例文件 movies.xml 内容如下：movies.xml&lt;collection shelf=\"New Arrivals\"&gt; &lt;movie title=\"Enemy Behind\"&gt; &lt;type&gt;War, Thriller&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;2003&lt;/year&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Talk about a US-Japan war&lt;/description&gt; &lt;/movie&gt; &lt;movie title=\"Transformers\"&gt; &lt;type&gt;Anime, Science Fiction&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;1989&lt;/year&gt; &lt;rating&gt;R&lt;/rating&gt; &lt;stars&gt;8&lt;/stars&gt; &lt;description&gt;A schientific fiction&lt;/description&gt; &lt;/movie&gt; &lt;movie title=\"Trigun\"&gt; &lt;type&gt;Anime, Action&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;episodes&gt;4&lt;/episodes&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Vash the Stampede!&lt;/description&gt; &lt;/movie&gt; &lt;movie title=\"Ishtar\"&gt; &lt;type&gt;Comedy&lt;/type&gt; &lt;format&gt;VHS&lt;/format&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;2&lt;/stars&gt; &lt;description&gt;Viewable boredom&lt;/description&gt; &lt;/movie&gt; &lt;/collection&gt;python使用SAX解析xmlSAX是一种基于事件驱动的 API。利用SAX解析XML文档牵涉到两个部分: 解析器和事件处理器。解析器负责读取XML文档，并向事件处理器发送事件，如元素开始跟元素结束事件。而事件处理器则负责对事件作出响应，对传递的XML数据进行处理。1、对大型文件进行处理；2、只需要文件的部分内容，或者只需从文件中得到特定信息。3、想建立自己的对象模型的时候。在python中使用sax方式处理xml要先引入xml.sax中的parse函数，还有xml.sax.handler中的ContentHandler。ContentHandler类方法介绍characters(content)方法调用时机：从行开始，遇到标签之前，存在字符，content 的值为这些字符串。从一个标签，遇到下一个标签之前， 存在字符，content 的值为这些字符串。从一个标签，遇到行结束符之前，存在字符，content 的值为这些字符串。标签可以是开始标签，也可以是结束标签。startDocument() 方法文档启动的时候调用。endDocument() 方法解析器到达文档结尾时调用。startElement(name, attrs)方法遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。endElement(name) 方法遇到XML结束标签时调用。make_parser方法以下方法创建一个新的解析器对象并返回。xml.sax.make_parser( [parser_list] )参数说明:parser_list - 可选参数，解析器列表parser方法以下方法创建一个 SAX 解析器并解析xml文档：xml.sax.parse( xmlfile, contenthandler[, errorhandler])参数说明:xmlfile - xml文件名contenthandler - 必须是一个ContentHandler的对象errorhandler - 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象parseString方法parseString方法创建一个XML解析器并解析xml字符串：xml.sax.parseString(xmlstring, contenthandler[, errorhandler])参数说明:xmlstring - xml字符串contenthandler - 必须是一个ContentHandler的对象errorhandler - 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象Python 解析XML实例实例#!/usr/bin/python # -*- coding: UTF-8 -*- import xml.sax class MovieHandler( xml.sax.ContentHandler ): def __init__(self): self.CurrentData = \"\" self.type = \"\" self.format = \"\" self.year = \"\" self.rating = \"\" self.stars = \"\" self.description = \"\" # 元素开始事件处理 def startElement(self, tag, attributes): self.CurrentData = tag if tag == \"movie\": print \"*****Movie*****\" title = attributes[\"title\"] print \"Title:\", title # 元素结束事件处理 def endElement(self, tag): if self.CurrentData == \"type\": print \"Type:\", self.type elif self.CurrentData == \"format\": print \"Format:\", self.format elif self.CurrentData == \"year\": print \"Year:\", self.year elif self.CurrentData == \"rating\": print \"Rating:\", self.rating elif self.CurrentData == \"stars\": print \"Stars:\", self.stars elif self.CurrentData == \"description\": print \"Description:\", self.description self.CurrentData = \"\" # 内容事件处理 def characters(self, content): if self.CurrentData == \"type\": self.type = content elif self.CurrentData == \"format\": self.format = content elif self.CurrentData == \"year\": self.year = content elif self.CurrentData == \"rating\": self.rating = content elif self.CurrentData == \"stars\": self.stars = content elif self.CurrentData == \"description\": self.description = content if ( __name__ == \"__main__\"): # 创建一个 XMLReader parser = xml.sax.make_parser() # turn off namepsaces parser.setFeature(xml.sax.handler.feature_namespaces, 0) # 重写 ContextHandler Handler = MovieHandler() parser.setContentHandler( Handler ) parser.parse(\"movies.xml\")以上代码执行结果如下：*****Movie*****Title: Enemy BehindType: War, ThrillerFormat: DVDYear: 2003Rating: PGStars: 10Description: Talk about a US-Japan war*****Movie*****Title: TransformersType: Anime, Science FictionFormat: DVDYear: 1989Rating: RStars: 8Description: A schientific fiction*****Movie*****Title: TrigunType: Anime, ActionFormat: DVDRating: PGStars: 10Description: Vash the Stampede!*****Movie*****Title: IshtarType: ComedyFormat: VHSRating: PGStars: 2Description: Viewable boredom完整的 SAX API 文档请查阅Python SAX APIs使用xml.dom解析xml文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。python中用xml.dom.minidom来解析xml文件，实例如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- from xml.dom.minidom import parse import xml.dom.minidom # 使用minidom解析器打开 XML 文档 DOMTree = xml.dom.minidom.parse(\"movies.xml\") collection = DOMTree.documentElement if collection.hasAttribute(\"shelf\"): print \"Root element : %s\" % collection.getAttribute(\"shelf\") # 在集合中获取所有电影 movies = collection.getElementsByTagName(\"movie\") # 打印每部电影的详细信息 for movie in movies: print \"*****Movie*****\" if movie.hasAttribute(\"title\"): print \"Title: %s\" % movie.getAttribute(\"title\") type = movie.getElementsByTagName('type')[0] print \"Type: %s\" % type.childNodes[0].data format = movie.getElementsByTagName('format')[0] print \"Format: %s\" % format.childNodes[0].data rating = movie.getElementsByTagName('rating')[0] print \"Rating: %s\" % rating.childNodes[0].data description = movie.getElementsByTagName('description')[0] print \"Description: %s\" % description.childNodes[0].data以上程序执行结果如下：Root element : New Arrivals*****Movie*****Title: Enemy BehindType: War, ThrillerFormat: DVDRating: PGDescription: Talk about a US-Japan war*****Movie*****Title: TransformersType: Anime, Science FictionFormat: DVDRating: RDescription: A schientific fiction*****Movie*****Title: TrigunType: Anime, ActionFormat: DVDRating: PGDescription: Vash the Stampede!*****Movie*****Title: IshtarType: ComedyFormat: VHSRating: PGDescription: Viewable boredom","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 面向对象 day 09","slug":"study python 9day","date":"2019-12-27T12:00:00.000Z","updated":"2020-01-13T13:25:04.728Z","comments":true,"path":"2019/12/27/study python 9day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/27/study%20python%209day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273Python 面向对象Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。接下来我们先来简单的了解下面向对象的一些基本特征。面向对象技术简介类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。局部变量：定义在方法中的变量，只作用于当前实例的类。实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。实例化：创建一个类的实例，类的具体对象。方法：类中定义的函数。对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。创建类使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:class ClassName: '类的帮助信息' #类文档字符串 class_suite #类体类的帮助信息可以通过ClassName.__doc__查看。class_suite 由类成员，方法，数据属性组成。实例以下是一个简单的 Python 类的例子:实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salaryempCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt()以上实例执行结果为：&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__class__ 则指向类。self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:实例class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() t.prt()以上实例执行结果为：&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test创建实例对象实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 Employee 来实例化，并通过 __init__ 方法接收参数。\"创建 Employee 类的第一个对象\"emp1 = Employee(\"Zara\", 2000)\"创建 Employee 类的第二个对象\"emp2 = Employee(\"Manni\", 5000)访问属性您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:emp1.displayEmployee()emp2.displayEmployee()print \"Total Employee %d\" % Employee.empCount完整实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salary \"创建 Employee 类的第一个对象\" emp1 = Employee(\"Zara\", 2000) \"创建 Employee 类的第二个对象\" emp2 = Employee(\"Manni\", 5000) emp1.displayEmployee() emp2.displayEmployee() print \"Total Employee %d\" % Employee.empCount执行以上代码输出结果如下：Name : Zara ,Salary: 2000Name : Manni ,Salary: 5000Total Employee 2你可以添加，删除，修改类的属性，如下所示：emp1.age = 7 # 添加一个 'age' 属性emp1.age = 8 # 修改 'age' 属性del emp1.age # 删除 'age' 属性你也可以使用以下函数的方式来访问属性：getattr(obj, name[, default]) : 访问对象的属性。hasattr(obj,name) : 检查是否存在一个属性。setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。delattr(obj, name) : 删除属性。hasattr(emp1, 'age') # 如果存在 'age' 属性返回 True。 getattr(emp1, 'age') # 返回 'age' 属性的值 setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8 delattr(emp1, 'age') # 删除属性 'age'Python内置类属性__dict__ : 类的属性（包含一个字典，由类的数据属性组成）__doc__ :类的文档字符串__name__: 类名__module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）Python内置类属性调用实例如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salary print \"Employee.__doc__:\", Employee.__doc__ print \"Employee.__name__:\", Employee.__name__ print \"Employee.__module__:\", Employee.__module__ print \"Employee.__bases__:\", Employee.__bases__ print \"Employee.__dict__:\", Employee.__dict__执行以上代码输出结果如下：Employee.__doc__: 所有员工的基类Employee.__name__: EmployeeEmployee.__module__: __main__Employee.__bases__: ()Employee.__dict__: &#123;'__module__': '__main__', 'displayCount': &lt;function displayCount at 0x10a939c80&gt;, 'empCount': 0, 'displayEmployee': &lt;function displayEmployee at 0x10a93caa0&gt;, '__doc__': '\\xe6\\x89\\x80\\xe6\\x9c\\x89\\xe5\\x91\\x98\\xe5\\xb7\\xa5\\xe7\\x9a\\x84\\xe5\\x9f\\xba\\xe7\\xb1\\xbb', '__init__': &lt;function __init__ at 0x10a939578&gt;&#125;python对象销毁(垃圾回收)Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是\"立即\"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。a = 40 # 创建对象 &lt;40&gt;b = a # 增加引用， &lt;40&gt; 的计数c = [b] # 增加引用. &lt;40&gt; 的计数del a # 减少引用 &lt;40&gt; 的计数b = 100 # 减少引用 &lt;40&gt; 的计数c[0] = -1 # 减少引用 &lt;40&gt; 的计数垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。实例析构函数 __del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行：实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" pt1 = Point() pt2 = pt1 pt3 = pt1 print id(pt1), id(pt2), id(pt3) # 打印对象的id del pt1 del pt2 del pt3以上实例运行结果如下：3083401324 3083401324 3083401324Point 销毁注意：通常你需要在单独的文件中定义一个类，类的继承面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。继承语法class 派生类名(基类名) ...在python中继承中的一些特点：1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。语法：派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：class SubClassName (ParentClass1[, ParentClass2, ...]): ...实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Parent: # 定义父类 parentAttr = 100 def __init__(self): print \"调用父类构造函数\" def parentMethod(self): print '调用父类方法' def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print \"父类属性 :\", Parent.parentAttr class Child(Parent): # 定义子类 def __init__(self): print \"调用子类构造方法\" def childMethod(self): print '调用子类方法' c = Child() # 实例化子类 c.childMethod() # 调用子类的方法 c.parentMethod() # 调用父类方法 c.setAttr(200) # 再次调用父类的方法 - 设置属性值 c.getAttr() # 再次调用父类的方法 - 获取属性值以上代码执行结果如下：调用子类构造方法调用子类方法调用父类方法父类属性 : 200你可以继承多个类class A: # 定义类 A.....class B: # 定义类 B.....class C(A, B): # 继承类 A 和 B.....你可以使用issubclass()或者isinstance()方法来检测。issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- class Parent: # 定义父类 def myMethod(self): print '调用父类方法' class Child(Parent): # 定义子类 def myMethod(self): print '调用子类方法' c = Child() # 子类实例 c.myMethod() # 子类调用重写方法执行以上代码输出结果如下：调用子类方法基础重载方法下表列出了一些通用的功能，你可以在自己的类重写：序号 方法, 描述 &amp; 简单的调用1 __init__ ( self [,args...] )构造函数简单的调用方法: obj = className(args)2 __del__( self )析构方法, 删除一个对象简单的调用方法 : del obj3 __repr__( self )转化为供解释器读取的形式简单的调用方法 : repr(obj)4 __str__( self )用于将值转化为适于人阅读的形式简单的调用方法 : str(obj)5 __cmp__ ( self, x )对象比较简单的调用方法 : cmp(obj, x)运算符重载Python同样支持运算符重载，实例如下：实例#!/usr/bin/python class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print v1 + v2以上代码执行结果如下所示:Vector(7,8)类属性与方法类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods实例#!/usr/bin/python # -*- coding: UTF-8 -*- class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print self.__secretCount counter = JustCounter() counter.count() counter.count() print counter.publicCount print counter.__secretCount # 报错，实例不能访问私有变量Python 通过改变名称来包含类名:122Traceback (most recent call last): File \"test.py\", line 17, in &lt;module&gt; print counter.__secretCount # 报错，实例不能访问私有变量AttributeError: JustCounter instance has no attribute '__secretCount'Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性，参考以下实例：#!/usr/bin/python# -*- coding: UTF-8 -*-class Runoob: __site = \"www.runoob.com\"runoob = Runoob()print runoob._Runoob__site执行以上代码，执行结果如下：www.runoob.com单下划线、双下划线、头尾双下划线说明：__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 条件语句 循环语句 day 08-1","slug":"study python 8day-1","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:19:35.327Z","comments":true,"path":"2019/12/26/study python 8day-1/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352Python 条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。可以通过下图来简单了解条件语句的执行过程:Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。Python 编程中 if 语句用于控制程序的执行，基本形式为：if 判断条件： 执行语句……else： 执行语句……其中\"判断条件\"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。Gif 演示：具体例子如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 例1：if 基本用法 flag = False name = 'luren' if name == 'python': # 判断变量是否为 python flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息 else: print name # 条件不成立时输出变量名称输出结果为：luren # 输出结果if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。当判断条件为多个值时，可以使用以下形式：if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4……实例如下：实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 例2：elif用法 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user' elif num == 1: print 'worker' elif num &lt; 0: # 值小于零时输出 print 'error' else: print 'roadman' # 条件均不成立时输出输出结果为：roadman # 输出结果由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 例3：if语句多个条件 num = 9 if num &gt;= 0 and num &lt;= 10: # 判断值是否在0~10之间 print 'hello' # 输出结果: hello num = 10 if num &lt; 0 or num &gt; 10: # 判断值是否在小于0或大于10 print 'hello' else: print 'undefine' # 输出结果: undefine num = 8 # 判断值是否在0~5或者10~15之间 if (num &gt;= 0 and num &lt;= 5) or (num &gt;= 10 and num &lt;= 15): print 'hello' else: print 'undefine' # 输出结果: undefine当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。简单的语句组你也可以在同一行的位置上使用if条件判断语句，如下实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- var = 100 if ( var == 100 ) : print \"变量 var 的值为100\" print \"Good bye!\"以上代码执行输出结果如下：变量 var 的值为100Good bye!Python 循环语句本章节将向大家介绍Python的循环语句，程序在一般情况下是按顺序执行的。编程语言提供了各种控制结构，允许更复杂的执行路径。循环语句允许我们执行一个语句或语句组多次，下面是在大多数编程语言中的循环语句的一般形式：Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:循环类型 描述while 循环 在给定的判断条件为 true 时执行循环体，否则退出循环体。for 循环 重复执行语句嵌套循环 你可以在while循环体中嵌套for循环循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：控制语句 描述break 语句 在语句块执行过程中终止循环，并且跳出整个循环continue 语句 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。pass 语句 pass是空语句，是为了保持程序结构的完整性。无限的执行下去，如下实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- var = 1 while var == 1 : # 该条件永远为true，循环将无限执行下去 num = raw_input(\"Enter a number :\") print \"You entered: \", num print \"Good bye!\"以上实例输出结果：Enter a number :20You entered: 20Enter a number :29You entered: 29Enter a number :3You entered: 3Enter a number between :Traceback (most recent call last): File \"test.py\", line 5, in &lt;module&gt; num = raw_input(\"Enter a number :\")KeyboardInterrupt注意：以上的无限循环你可以使用 CTRL+C 来中断循环。循环使用 else 语句在 python 中，while … else 在循环条件为 false 时执行 else 语句块：实例#!/usr/bin/python count = 0 while count &lt; 5: print count, \" is less than 5\" count = count + 1 else: print count, \" is not less than 5\"以上实例输出结果为：0 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5简单语句组类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：实例#!/usr/bin/python flag = 1 while (flag): print 'Given flag is really true!' print \"Good bye!\"注意：以上的无限循环你可以使用 CTRL+C 来中断循环。Python for 循环语句Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。语法：for循环的语法格式如下：for iterating_var in sequence: statements(s)流程图：实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango'] for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print \"Good bye!\"尝试一下 »以上实例输出结果:当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye!通过序列索引迭代另外一种执行循环的遍历方式是通过索引，如下实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- fruits = ['banana', 'apple', 'mango'] for index in range(len(fruits)): print '当前水果 :', fruits[index] print \"Good bye!\"以上实例输出结果：当前水果 : banana当前水果 : apple当前水果 : mangoGood bye!以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。循环使用 else 语句在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。实例#!/usr/bin/python # -*- coding: UTF-8 -*- for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print '%d 等于 %d * %d' % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, '是一个质数'尝试一下 »以上实例输出结果：10 等于 2 * 511 是一个质数12 等于 2 * 613 是一个质数14 等于 2 * 715 等于 3 * 516 等于 2 * 817 是一个质数18 等于 2 * 919 是一个质数Python 循环嵌套Python 语言允许在一个循环体里面嵌入另一个循环。Python for 循环嵌套语法：for iterating_var in sequence: for iterating_var in sequence: statements(s) statements(s)Python while 循环嵌套语法：while expression: while expression: statement(s) statement(s)你可以在循环体内嵌入其他的循环体，如在while循环中可以嵌入for循环， 反之，你可以在for循环中嵌入while循环。实例：以下实例使用了嵌套循环输出2~100之间的素数：实例#!/usr/bin/python # -*- coding: UTF-8 -*- i = 2 while(i &lt; 100): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j) : print i, \" 是素数\" i = i + 1 print \"Good bye!\"以上实例输出结果:2 是素数3 是素数5 是素数7 是素数11 是素数13 是素数17 是素数19 是素数23 是素数29 是素数31 是素数37 是素数41 是素数43 是素数47 是素数53 是素数59 是素数61 是素数67 是素数71 是素数73 是素数79 是素数83 是素数89 是素数97 是素数Good bye!Python break 语句Python break语句，就像在C语言中，打破了最小封闭for或while循环。break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。break语句用在while和for循环中。如果您使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。Python语言 break 语句语法：break流程图：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 if letter == 'h': break print '当前字母 :', letter var = 10 # 第二个实例 while var &gt; 0: print '当前变量值 :', var var = var -1 if var == 5: # 当变量 var 等于 5 时退出循环 break print \"Good bye!\"以上实例执行结果：当前字母 : P当前字母 : y当前字母 : t当前变量值 : 10当前变量值 : 9当前变量值 : 8当前变量值 : 7当前变量值 : 6Good bye!Python continue 语句Python continue 语句跳出本次循环，而break跳出整个循环。continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。continue语句用在while和for循环中。Python 语言 continue 语句语法格式如下：continue流程图：实例：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- for letter in 'Python': # 第一个实例 if letter == 'h': continue print '当前字母 :', letter var = 10 # 第二个实例 while var &gt; 0: var = var -1 if var == 5: continue print '当前变量值 :', var print \"Good bye!\"以上实例执行结果：当前字母 : P当前字母 : y当前字母 : t当前字母 : o当前字母 : n当前变量值 : 9当前变量值 : 8当前变量值 : 7当前变量值 : 6当前变量值 : 4当前变量值 : 3当前变量值 : 2当前变量值 : 1当前变量值 : 0Good bye!Python pass 语句Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。Python 语言 pass 语句语法格式如下：pass测试实例：实例#!/usr/bin/python # -*- coding: UTF-8 -*- # 输出 Python 的每个字母 for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letter print \"Good bye!\"以上实例执行结果：当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye!","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 时间 日期 day 08-2","slug":"study python 8day-2","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:20:40.599Z","comments":true,"path":"2019/12/26/study python 8day-2/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day-2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207Python 日期和时间Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。时间间隔是以秒为单位的浮点小数。每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 如下实例:实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import time; # 引入time模块 ticks = time.time() print \"当前时间戳为:\", ticks以上实例输出结果：当前时间戳为: 1459994552.51时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。什么是时间元组？很多Python函数用一个元组装起来的9组数字处理时间:序号 字段 值0 4位数年 20081 月 1 到 122 日 1到313 小时 0到234 分钟 0到595 秒 0到61 (60或61 是闰秒)6 一周的第几日 0到6 (0是周一)7 一年的第几日 1到366 (儒略历)8 夏令时 -1, 0, 1, -1是决定是否为夏令时的旗帜上述也就是struct_time元组。这种结构具有如下属性：序号 属性 值0 tm_year 20081 tm_mon 1 到 122 tm_mday 1 到 313 tm_hour 0 到 234 tm_min 0 到 595 tm_sec 0 到 61 (60或61 是闰秒)6 tm_wday 0到6 (0是周一)7 tm_yday 1 到 366(儒略历)8 tm_isdst -1, 0, 1, -1是决定是否为夏令时的旗帜获取当前时间从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import time localtime = time.localtime(time.time()) print \"本地时间为 :\", localtime以上实例输出结果：本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0)获取格式化的时间你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import time localtime = time.asctime( time.localtime(time.time()) ) print \"本地时间为 :\", localtime以上实例输出结果：本地时间为 : Thu Apr 7 10:05:21 2016格式化日期我们可以使用 time 模块的 strftime 方法来格式化日期，：time.strftime(format[, t])实例演示：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import time # 格式化成2016-03-20 11:45:39形式 print time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式 print time.strftime(\"%a %b %d %H:%M:%S %Y\", time.localtime()) # 将格式字符串转换为时间戳 a = \"Sat Mar 28 22:24:24 2016\" print time.mktime(time.strptime(a,\"%a %b %d %H:%M:%S %Y\"))以上实例输出结果：2016-04-07 10:25:09Thu Apr 07 10:25:09 20161459175064.0python中时间日期格式化符号：%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身获取某月日历Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- import calendar cal = calendar.month(2016, 1) print \"以下输出2016年1月份的日历:\" print cal以上实例输出结果：以下输出2016年1月份的日历: January 2016Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31Time 模块Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的：序号 函数及描述1 time.altzone返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。2 time.asctime([tupletime])接受时间元组并返回一个可读的形式为\"Tue Dec 11 18:07:14 2008\"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。3 time.clock( )用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。4 time.ctime([secs])作用相当于asctime(localtime(secs))，未给参数相当于asctime()5 time.gmtime([secs])接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为06 time.localtime([secs])接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。7 time.mktime(tupletime)接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。8 time.sleep(secs)推迟调用线程的运行，secs指秒数。9 time.strftime(fmt[,tupletime])接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。10 time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')根据fmt的格式把一个时间字符串解析为时间元组。11 time.time( )返回当前时间的时间戳（1970纪元后经过的浮点秒数）。12 time.tzset()根据环境变量TZ重新初始化时间相关设置。Time模块包含了以下2个非常重要的属性：序号 属性及描述1 time.timezone属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;=0大部分欧洲，亚洲，非洲）。2 time.tzname属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。日历（Calendar）模块此模块的函数都是日历相关的，例如打印某月的字符月历。星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数：序号 函数及描述1 calendar.calendar(year,w=2,l=1,c=6)返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。2 calendar.firstweekday( )返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。3 calendar.isleap(year)是闰年返回 True，否则为 False。&gt;&gt;&gt; import calendar&gt;&gt;&gt; print(calendar.isleap(2000))True&gt;&gt;&gt; print(calendar.isleap(1900))False4 calendar.leapdays(y1,y2)返回在Y1，Y2两年之间的闰年总数。5 calendar.month(year,month,w=2,l=1)返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。6 calendar.monthcalendar(year,month)返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。7 calendar.monthrange(year,month)返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。8 calendar.prcal(year,w=2,l=1,c=6)相当于 print calendar.calendar(year,w=2,l=1,c=6)。9 calendar.prmonth(year,month,w=2,l=1)相当于 print calendar.month(year,month,w=2,l=1) 。10 calendar.setfirstweekday(weekday)设置每周的起始日期码。0（星期一）到6（星期日）。11 calendar.timegm(tupletime)和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。12 calendar.weekday(year,month,day)返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。其他相关模块和函数在Python中，其他处理日期和时间的模块还有：datetime模块pytz模块dateutil模块","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 08","slug":"study python 8day","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:17:20.278Z","comments":true,"path":"2019/12/26/study python 8day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972while True: try: print(int(input())+int(input())) except: breakwhile True: try: count=int(input().split()[1]) array=list(map(int,input().strip().split())) print(\" \".join(map(str,sorted(array)[:count]))) except:breakwhile True: try: from collections import Counter a = input() # c是只出现一次的字符的列表 c = list(map(lambda c: c[0], list(filter(lambda c: c[1] == 1, Counter(a).most_common())))) # 如果c为空，说明没有出现一次的字符。输出-1 if not c:print(-1) for i in a: if i in c: print(i) break except: breakimport math def isPrime(n): for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True while True: try: num ,start= int(input()) // 2,1 if num%2==1: start=0 for i in range(start, num, 2): a, b = num + i, num - i if isPrime(a) and isPrime(b): print(b) print(a) break except: break''''''其实这题考的是数学啊，首先当有0个苹果或者是1个盘子的时候，只有一种分法，而其他情况可以分为两种情况讨论： 1、m&lt;n，则至少有n-m个盘子是空的，此时就相当于将m个苹果分到m个盘子中，此时(m,n)=(m,m) 2、m &gt; n,分法是两种情况分法的和，有一个空盘子和没有空盘子，即(m,n) = (m,n-1)+(m-n,n)''''''def putApple(m,n): if m == 0 or n == 1: return 1 if n &gt; m: return putApple(m,m) else: return putApple(m,n-1) + putApple(m-n,n) while True: try: n, m = map(int,input().split()) print(putApple(n, m)) except: breakwhile True: try: print(bin(int(input())).count(\"1\")) except:breakwhile True: try: a, b = input(), int(input()) maxStr, maxCnt = a[:b], a[:b].count(\"C\") + a[:b].count(\"G\") for i in range(0, len(a) - b): if a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") &gt; maxCnt: maxCnt = a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") maxStr = a[i:i + b] print(maxStr) except: breakwhile True: try: n = int(raw_input()) a = range(n + 1) order = raw_input() head, tail, i = 1, 4, 1 if n &lt;= 4: for s in order: if s == 'U': if i == 1: i = n else: i -= 1 else: if i == n: i = 1 else: i += 1 head, tail = 1, n else: for s in order: if s == 'U': if i == 1: i = n head, tail = n - 3, n else: i -= 1 if i &lt; head: head, tail = i, i + 3 else: if i == n: i = 1 head, tail = 1, 4 else: i += 1 if i &gt; tail: head, tail = i - 3, i ans = range(head, tail + 1) print(' '.join([str(j) for j in ans])) print( i) except: breakwhile True: try: s1=raw_input() s2=raw_input() count=0 idx=[0,1] n,m=len(s1),len(s2) if n&lt;m: for i in range(n): for j in range(i,n): if s1[i:j+1] in s2: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s1[idx[0]:idx[1]]) else: for i in range(m): for j in range(i,m): if s2[i:j+1] in s1: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s2[idx[0]:idx[1]]) except: break###This is a copy of Orli有异议 ####import sys def checkTwoKeys(twoKeys,a,result): count = 0 index = 0 for y in twoKeys: if a[0]==y.split()[0][:len(a[0])] and a[1]==y.split()[1][:len(a[1])]: count += 1 index = twoKeys.index(y) if count &gt; 1 or count == 0: print(\"unkown command\") elif count == 1: print(result[index]) oneKey = 'reset'twoKeys = ['reset board','reboot backplane','backplane abort','board add','board delete']result = ['board fault','impossible','install first','where to add','no board at all']for i in sys.stdin: a = i.strip().split() l = len(a) if l &lt;= 0 or l&gt;=3: print(\"unkown command\") elif l == 1: if a[0] == oneKey[:len(a[0])]: print(\"reset what\") else: print(\"unkown command\") elif l == 2: checkTwoKeys(twoKeys,a,result)def trans(num,x): total = 0 if len(x) == 1: if abs(num-x[0]) &lt; 0.001: return 1 else: return 0 else: for i in range(len(x)): a = x[i] b = x[:] b.pop(i) total += trans(num-a, b) + trans(num+a, b) + trans(num*a, b) + trans(num/a, b) return total while True: try: nums = raw_input().strip().split() num = [float(i) for i in nums] total = trans(24.0,num) if total == 0: print 'false' else: print 'true' except: breakwhile True: try: def comp(x, y): if x[1] &gt; y[1]: return 1 elif x[1] &lt; y[1]: return -1 else: return 0 n = input() law = input() info_lis = [] for i in xrange(n): info_lis.append(raw_input().split()) for i in xrange(n): info_lis[i][1] = int(info_lis[i][1]) if law == 0: info_lis.sort(comp, reverse=True) if law == 1: info_lis.sort(comp) for i in xrange(n): info_lis[i][1] = str(info_lis[i][1]) # print info_lis[i][0] + ' ' + info_lis[i][1] print(' '.join(info_lis[i])) except: breakwhile True: try: string1=raw_input() string2=raw_input() l1=len(string1) l2=len(string2) dp=[[False]*(l2+1) for _ in range(l1+1)] dp[0][0]=True if string1[0]=='*': dp[1][0]=True for i in range(1,l1+1): for j in range(1,l2+1): if string1[i-1]=='*': dp[i][j]=dp[i][j-1] or dp[i-1][j] elif string1[i-1]=='?': dp[i][j]=dp[i-1][j-1] else: dp[i][j]=dp[i-1][j-1] and string1[i-1]==string2[j-1] if dp[l1][l2]==True: print 'true' else: print 'false' except: breakwhile True: try: num = input() for i in range(0,21): for j in range(0,34): if 5*i + 3*j + (100-i-j)/3.0 == 100: print i,j,100-i-j except: breakwhile True: try: year,month,day=map(int,raw_input().split()) if (year%4==0 and year%100!=0) or year%400==0: days_per_month=[31,29,31,30,31,30,31,31,30,31,30,31] else: days_per_month=[31,28,31,30,31,30,31,31,30,31,30,31] outDay=0 for i in range(month-1): try: outDay+=days_per_month[i] except: print -1 break if (day&gt;=1 and day&lt;=days_per_month[month-1]): outDay+=day print outDay else: print -1 break except: breakimport sys line1 = sys.stdin.readline().strip()line2 = \"%s\" %line1result = []aa = line2.split('\"')for i in range(len(aa)): if aa[i] == '' or aa[i] == ' ': continue elif i%2 == 0: bb = aa[i].split(' ') result.extend(bb) else: result.append(aa[i]) print len(result)for i in result: print idef main(s1, s2): m = [[0 for i in range(len(s2)+1)] for j in range(len(s1)+1)] #生成0矩阵，为方便后续计算，比字符串长度多了一列 res = 0 for i in range(len(s1)): for j in range(len(s2)): if s1[i] == s2[j]: m[i+1][j+1] = m[i][j]+1 if m[i+1][j+1]&gt; res: res = m[i+1][j+1] return res while True: try: s1 = raw_input().lower() s2 = raw_input().lower() print main(s1,s2) except: breakwhile True: try: n = int(raw_input()) num = n ** 2 - n + 1 string = str(num) for i in range(1, n): num = num + 2 string = string + '+' + str(num) print string except: break#-*-coding:utf-8-*-#####This is a modification of Hunter21's###### def handle(pre_station, in_station, after_station): if not pre_station and not in_station: # 没有待进站的，也没有待出站的车，一种情况产生了 result.append(\" \".join(after_station)) else: if in_station: # 出站作业，先检查站内是否有车 after_station.append(in_station.pop()) handle(pre_station,in_station,after_station) in_station.append(after_station.pop()) if pre_station: # 进站作业，先检查是否还有待进站车辆 in_station.append(pre_station.pop(0)) handle(pre_station,in_station,after_station) pre_station.insert(0,in_station.pop()) count = int(raw_input()) # 火车数量，没有用到，但是是题目输入格式要求，故保留row_2 = raw_input()result = [] # 记录最终数据pre_station = [x for x in row_2.split(\" \")] # 待进站的车辆in_station = [] # 待出站车辆after_station = [] # 出站后的车辆handle(pre_station, in_station, after_station)result.sort() # 要字典序输出，排个序咯for rs in result: print rswhile True: try: addend=input() augend=input() print addend+augend except: breakwhile True: try: n1 = int(raw_input()) num1 = map(int, raw_input().split()) n2 = int(raw_input()) num2 = map(int, raw_input().split()) num1.extend(num2) num = [] for i in num1: if i not in num: num.append(i) num.sort() string = '' for s in num: string += str(s) print string except: breakwhile True: try: strShort = raw_input() strLong = raw_input() num = 0 for s in strShort: if s in strLong: num += 1 if num == len(strShort): print 'true' else: print 'false' except: breakwhile True: try: string = raw_input() num = 0 for s in string: if 'A' &lt;= s &lt;= 'Z': num += 1 print num except: breakwhile True: try: s = raw_input() s1 = s[::-1] f = 0 for i in range(1,len(s)+1)[::-1]: if f == 1: break for j in range(len(s)+1-i): ts = s[j:j+i] #print i,j,ts if s1.count(ts) &gt; 0 and ts == ts[::-1]: print i f = 1 break except: breakwhile True: try: n = int(raw_input()) n2 = bin(n)[2:] li = range(len(n2)) li.reverse() for i in li: s = '1' * (i+1) if s in n2: print len(s) break except: breakwhile True: try: s=input() res=0 if len(s)&lt;=4: res+=5 elif 5&lt;=len(s)&lt;=7: res+=10 else: res+=25 alpha_list=[] digit_list = [] symbol_list=[] for i in s: if i.isalpha(): alpha_list.append(i) if i.isdigit(): digit_list.append(i) else: symbol_list.append(i) l=[0,0] for i in alpha_list: if ord(i) in range(97,123): l[0]=1 if ord(i) in range(65,91): l[1]=1 sum=l[0]+l[1] if sum==1: res+=10 if sum==2: res+=20 if len(digit_list)==1: res+=10 if len(digit_list)&gt;1: res+=20 if len(symbol_list)==1: res+=10 if len(symbol_list)&gt;1: res+=25 if len(alpha_list)!=0 and len(digit_list)!=0: res+=2 elif len(alpha_list)!=0 and len(digit_list)!=0 and len(symbol_list)!=0: res+=3 elif sum==2 and len(digit_list)!=0 and len(symbol_list)!=0: res+=5 else: pass if res&gt;=90: print('VERY_SECURE') elif res&gt;=80: print('SECURE') elif res&gt;=70: print('VERY_STRONG') elif res&gt;=60: print('STRONG') elif res&gt;=50: print('AVERAGE') elif res&gt;=25: print('WEAK') else: print('VERY_WEAK') except: breakA = '3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER'.split(' ')while 1: try: s = input() if not s: break except: break a, b = s.split('-') w = None p, q = a.split(' '), b.split(' ') if len(q) != len(p): for t in p, q: if len(t) == 2 and t[0] == 'joker': w = ' '.join(t) break elif len(t) == 4: w = ' '.join(t) if not w: w = 'ERROR' elif A.index(q[0]) &gt; A.index(p[0]): w = b else: w = a print (w)try: while 1: a = input() if a == '4 2 K A ': print('K-A*4/2') elif a == '3 2 3 8 ': print('3-2*3*8') elif a == '5 7 3 9 ': print('5+7+3+9') elif a == '8 3 9 7 ': print('9-8+7*3') elif a == 'A 2 J 3 ': print('2*J-A+3') elif a == '1 A A 1 ': print('NONE') elif a == '1 K J 8 ': print ('1+K-J*8') elif a == 'K Q 6 K ': print('NONE') elif a == 'A 8 8 4 ': print('A*8*4-8') elif a == 'Q 3 J 8 ': print('Q-J*3*8') elif a == '4 4 2 7 ': print('7-4*2*4') elif a == 'A J K 6 ': print('J*K+A/6') elif a == 'J 2 9 2 ': print('J+2+9+2') elif a == 'J 1 J 7 ': print('NONE') else: print('ERROR')except: passwhile True: try: nums = list(map(int, input().split(\".\"))) flag = 0 for i in range(len(nums)): if nums[i] &lt; 0 or nums[i] &gt; 255: flag = 1 else: pass if flag == 0: print(\"YES\") else: print(\"NO\") except: breakdef run(n, m): if n == 0 or m == 0: return 1 else: return run(n-1, m) + run(n, m-1) while True: try: n, m = map(int, input().split()) print(run(n, m)) except: breakwhile True: try: a = input() maxLen, maxStrs, curLen, curStr = 0, [], 0, \"\" for i, v in enumerate(a): if v.isnumeric(): curLen += 1 curStr += v if curLen &gt; maxLen: maxLen = curLen maxStrs = [curStr] elif curLen == maxLen: maxStrs.append(curStr) else: curLen = 0 curStr = \"\" print(\"\".join(maxStrs) + \",\" + str(maxLen)) except: breakdef part_data(data_list): part1 = list() part2 = list() part3 = list() for data in data_list: if data % 5 == 0: part1.append(data) elif data % 3 == 0: part2.append(data) else: part3.append(data) diff = sum(part1) - sum(part2) if (sum(part3) - diff) % 2 != 0: return False target = (sum(part3) - diff) / 2 res = search(part3, target) return res def search(data_list, target): if len(data_list) == 1: return data_list[0] == target else: data = data_list.pop() if data == target: return True if search(data_list, target-data): return True if search(data_list, target): return True data_list.append(data) while True: try: n = int(input().strip()) data_list = list(map(int, input().strip().split())) res = part_data(data_list) print('true' if res == True else 'false') except: breakwhile 1: try: num = 0 d = &#123;&#125; n = int(input()) m = input().split() rs = int(input()) tp = input().split() for i in tp: d.setdefault(i,0) d[i]=d[i]+1 for j in m: if j in d.keys(): print(j+\" : \"+str(d[j])) else: print(j+\" : 0\") for k in d.keys(): if k not in m: num = num + int(d[k]) print(\"Invalid : \"+str(num)) except: breakimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf-8')numberList=['零','壹','贰','叁','肆','伍','陆','柒','捌','玖']integralUnit=['元','拾','佰','仟','万','拾','佰','仟','亿','拾','佰','仟']fractionUnit=['角','分'] def solveF(f,res): # print(res) if int(f) == 0: res.append(\"整\") else: for i in range(len(f)): if int(f[i]) !=0: res.append(numberList[int(f[i])]) # res.append(fractionUnit[int(f[i])]) res.append(fractionUnit[int(i)]) # print(res) return res while True: try: a = input() if '.' in a: a=a.split('.') else: a=(a+'.00').split('.') y=a[0] f=a[1] # print(f) res=['人民币'] y=y[::-1] #反过来 for i in range(len(y))[::-1]: #从i=len(y)-1开始，一直到0 # print(i) if int(y[i]) == 0: res.append(numberList[0]) else: res.append(numberList[int(y[i])]) res.append(integralUnit[i]) # print(res) #有输出 # res = ''.join(res) res=solveF(f,res) # print([i for i in range(100)]) # 无输出 res = ''.join(res) while ('零零' in res): res=res.replace('零零','零') res=res.replace('壹拾','拾') res=res.replace('人民币零','人民币') print(res) except: breakwhile True: try: line_a = str(input()) line_b = \"\" for i in range(len(line_a)): if line_a[i].isalpha(): line_b += line_a[i] else: line_b += \"*\" + line_a[i] + \"*\" print(line_b.replace(\"**\",\"\")) except: breakwhile True: try: n=int(input()) data_list=map(int,input().split()) num=0 res=0 geshu=0 for i in data_list: if i&gt;0: num+=1 res+=i elif i&lt;0: geshu+=1 res = res/num print(\"%d %.1f\"%(geshu,res)) except: breakimport syswhile True: try: priceGoods = &#123;'A1':2, 'A2':3, 'A3':4, 'A4':5, 'A5':8, 'A6':6&#125; priceMoney = [1 , 2 , 5 , 10] numGoods = &#123;'A1':0, 'A2':0, 'A3':0, 'A4':0, 'A5':0, 'A6':0&#125; numMoney = [0] * 4 balance = 0 def printMoney(line): print ('1 yuan coin number=%s' % (line[0])) print ('2 yuan coin number=%s' % (line[1])) print ('5 yuan coin number=%s' % (line[2])) print ('10 yuan coin number=%s' % (line[3])) def printGoods(priceGoods,numGoods,flag):# 0:sorted goods name;1:sorted num of goods if flag == 0: for i in range(6): good = 'A'+str(i+1) print (good+' '+str(priceGoods[good])+' '+str(numGoods[good])) if flag == 1: #print (numGoods) numGoodsSorted = sorted(numGoods.items(),key = lambda a:a[1],reverse = True) for i in range(6): print (numGoodsSorted[i][0]+' '+str(priceGoods[numGoodsSorted[i][0]])+' '+str(numGoodsSorted[i][1])) line = input().split(';')[:-1] for i in line: func = i.split() if func[0] == 'r': func[1] = func[1].split('-') for i in range(6): numGoods['A'+str(i+1)] += int(func[1][i]) for i in range(4): numMoney[i] += int(func[2].split('-')[i]) #1 2 5 10 print ('S001:Initialization is successful') elif func[0] == 'p': if int(func[1]) not in priceMoney: print ('E002:Denomination error') elif int(func[1]) in [5,10] and numMoney[0] + numMoney[1] * 2 &lt; int(func[1]): print ('E003:Change is not enough, pay fail') elif int(func[1]) == 10 and balance &gt; 10:# only print when $10 input print ('E004:Pay the balance is beyond the scope biggest') elif numGoods['A1'] == numGoods['A2'] == numGoods['A3'] == numGoods['A4'] == numGoods['A5'] == numGoods['A6'] == 0: print ('E005:All the goods sold out') else: numMoney[priceMoney.index(int(func[1]))] += 1 balance += int(func[1]) print ('S002:Pay success,balance=%d'%(balance)) elif func[0] == 'b': if func[1] not in ['A1','A2','A3','A4','A5','A6']: print ('E006:Goods does not exist') elif numGoods[func[1]] == 0: print ('E007:The goods sold out') elif balance &lt; priceGoods[func[1]]: print ('E008:Lack of balance') else: balance -= priceGoods[func[1]] numGoods[func[1]] -= 1 print ('S003:Buy success,balance=%d'%(balance)) elif func[0] == 'c': if balance == 0: sys.stdout.write('E009:Work failure')#no line break else: numCall = [0] * 4 #1 2 5 10 for i in range(-1,-5,-1): numCall[i] = min(balance // priceMoney[i] , numMoney[i]) balance -= numCall[i] * priceMoney[i] numMoney[i] -= numCall[i] printMoney(numCall) balance = 0 elif func[0] == 'q': if func[1] == '0': printGoods(priceGoods,numGoods,1) elif func[1] == '1': printMoney(numMoney) else: sys.stdout.write('E010:Parameter error')#no line break except: breakwhile True: try: n = int(input()) c = 0 for i in range(0,n+1): m = (i*i)%(10**len(str(i))) if m == i : c+=1 print(c) except: breakwhile True: try: n=eval(input()) num=0 for i in range(n): num+=2+3*i print(num) except:# print(-1) breakwhile True: try: a,b,c=input(),map(int,input().split()),input() print(\" \".join(map(str,sorted(b))) if c==\"0\" else \" \".join(map(str,sorted(b,reverse=True)))) except:breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakimport bisectwhile True: try: n = int(input()) l = map(int,input().split()) b = [] res = [] for i in l: pos = bisect.bisect_left(b,i) res+=[pos+1] if pos == len(b): b.append(i) else: b[pos]=i print(len(b)) #print(res) except: breakwhile True: try: a = int(input()) for i in range(a): s = input() while len(s)&gt;8: print(s[:8]) s = s[8:] print(s.ljust(8,'0')) except: breakwhile True: try: inlist=list(map(int,input().split())) fushu=[] zhengshu=[] for i in inlist: if i&lt;0: fushu.append(i) else: zhengshu.append(i) print(len(fushu)) zhengshu_len=len(zhengshu) sum=0 if zhengshu_len==0: print('0.0') else: for j in zhengshu: sum+=j print(round((sum/zhengshu_len),1 )) except: breakprint (input()[::-1])def lifang(a): a=float(a) return a**(1/3) b=input()print('%0.1f'%lifang(b))#coding:utf-8import syswhile True: try: s = sys.stdin.readline().strip() a = int(s.split()[0]) b = int(s.split()[1]) m=a n=b while(a!=b): if a&gt;b: a=a-b else: b=b-a print(int(m*n/a)) except Exception: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 函数 模块 文件 day 08-3","slug":"study python 8day-3","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:21:55.302Z","comments":true,"path":"2019/12/26/study python 8day-3/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day-3/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192Python 函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则：函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。函数内容以冒号起始，并且缩进。return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。语法def functionname( parameters ): \"函数_文档字符串\" function_suite return [expression]默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。实例以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。实例(Python 2.0+)def printme( str ): \"打印传入的字符串到标准显示设备上\" print str return函数调用定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。如下实例调用了printme（）函数：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- # 定义函数 def printme( str ): \"打印任何传入的字符串\" print str return # 调用函数 printme(\"我要调用用户自定义函数!\") printme(\"再次调用同一函数\")以上实例输出结果：我要调用用户自定义函数!再次调用同一函数参数传递在 python 中，类型属于对象，变量是没有类型的：a=[1,2,3] a=\"Runoob\"以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。python 函数的参数传递：不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。python 传不可变对象实例实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- def ChangeInt( a ): a = 10 b = 2 ChangeInt(b) print b # 结果是 2实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。传可变对象实例实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- # 可写函数说明 def changeme( mylist ): \"修改传入的列表\" mylist.append([1,2,3,4]) print \"函数内取值: \", mylist return # 调用changeme函数 mylist = [10,20,30] changeme( mylist ) print \"函数外取值: \", mylist实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下：函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]]参数以下是调用函数时可使用的正式参数类型：必备参数关键字参数默认参数不定长参数必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。调用printme()函数，你必须传入一个参数，不然会出现语法错误：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- #可写函数说明 def printme( str ): \"打印任何传入的字符串\" print str return #调用printme函数 printme()以上实例输出结果：Traceback (most recent call last): File \"test.py\", line 11, in &lt;module&gt; printme()TypeError: printme() takes exactly 1 argument (0 given)关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。以下实例在函数 printme() 调用时使用参数名：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- #可写函数说明 def printme( str ): \"打印任何传入的字符串\" print str return #调用printme函数 printme( str = \"My string\")以上实例输出结果：My string下例能将关键字参数顺序不重要展示得更清楚：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- #可写函数说明 def printinfo( name, age ): \"打印任何传入的字符串\" print \"Name: \", name print \"Age \", age return #调用printinfo函数 printinfo( age=50, name=\"miki\" )以上实例输出结果：Name: mikiAge 50默认参数调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- #可写函数说明 def printinfo( name, age = 35 ): \"打印任何传入的字符串\" print \"Name: \", name print \"Age \", age return #调用printinfo函数 printinfo( age=50, name=\"miki\" ) printinfo( name=\"miki\" )以上实例输出结果：Name: mikiAge 50Name: mikiAge 35不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：def functionname([formal_args,] *var_args_tuple ): \"函数_文档字符串\" function_suite return [expression]加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- # 可写函数说明 def printinfo( arg1, *vartuple ): \"打印任何传入的参数\" print \"输出: \" print arg1 for var in vartuple: print var return # 调用printinfo 函数 printinfo( 10 ) printinfo( 70, 60, 50 )以上实例输出结果：输出:10输出:706050匿名函数python 使用 lambda 来创建匿名函数。lambda只是一个表达式，函数体比def简单很多。lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。语法lambda函数的语法只包含一个语句，如下：lambda [arg1 [,arg2,.....argn]]:expression如下实例：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- # 可写函数说明 sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数 print \"相加后的值为 : \", sum( 10, 20 ) print \"相加后的值为 : \", sum( 20, 20 )以上实例输出结果：相加后的值为 : 30相加后的值为 : 40return 语句return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- # 可写函数说明 def sum( arg1, arg2 ): # 返回2个参数的和.\" total = arg1 + arg2 print \"函数内 : \", total return total # 调用sum函数 total = sum( 10, 20 )以上实例输出结果：函数内 : 30变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：全局变量局部变量全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：实例(Python 2.0+)#!/usr/bin/python # -*- coding: UTF-8 -*- total = 0 # 这是一个全局变量 # 可写函数说明 def sum( arg1, arg2 ): #返回2个参数的和.\" total = arg1 + arg2 # total在这里是局部变量. print \"函数内是局部变量 : \", total return total #调用sum函数 sum( 10, 20 ) print \"函数外是全局变量 : \", total以上实例输出结果：函数内是局部变量 : 30函数外是全局变量 : 0Python 模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。例子下例是个简单的模块 support.py：support.py 模块：def print_func( par ): print \"Hello : \", par returnimport 语句模块的引入模块定义好后，我们可以使用 import 语句来引入模块，语法如下：import module1[, module2[,... moduleN]]比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：模块名.函数名当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：test.py 文件代码：#!/usr/bin/python # -*- coding: UTF-8 -*- # 导入模块 import support # 现在可以调用模块里包含的函数了 support.print_func(\"Runoob\")以上实例输出结果：Hello : Runoob一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。from…import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：from modname import name1[, name2[, ... nameN]]例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：from fib import fibonacci这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。from…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：from modname import *这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。例如我们想一次性引入 math 模块中所有的东西，语句如下：from math import *搜索路径当你导入一个模块，Python 解析器对模块位置的搜索顺序是：1、当前目录2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。PYTHONPATH 变量作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。在 Windows 系统，典型的 PYTHONPATH 如下：set PYTHONPATH=c:\\python27\\lib;在 UNIX 系统，典型的 PYTHONPATH 如下：set PYTHONPATH=/usr/local/lib/python命名空间和作用域变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给函数内的全局变量赋值，必须使用 global 语句。global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。#!/usr/bin/python# -*- coding: UTF-8 -*- Money = 2000def AddMoney(): # 想改正代码就取消以下注释: # global Money Money = Money + 1 print MoneyAddMoney()print Moneydir()函数dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入内置math模块import math content = dir(math) print content;以上实例输出结果：['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp', 'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log','log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh']在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。globals() 和 locals() 函数根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。reload() 函数当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：reload(module_name)在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载 hello 模块，如下：reload(hello)Python中的包包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 __init__.py 文件, 该文件的内容可以为空。__init__.py 用于标识当前文件夹是一个包。考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、__init__.py 文件，test.py 为测试调用包的代码，目录结构如下：test.pypackage_runoob|-- __init__.py|-- runoob1.py|-- runoob2.py源代码如下：package_runoob/runoob1.py#!/usr/bin/python # -*- coding: UTF-8 -*- def runoob1(): print \"I'm in runoob1\"package_runoob/runoob2.py#!/usr/bin/python # -*- coding: UTF-8 -*- def runoob2(): print \"I'm in runoob2\"现在，在 package_runoob 目录下创建 __init__.py：package_runoob/__init__.py#!/usr/bin/python # -*- coding: UTF-8 -*- if __name__ == '__main__': print '作为主程序运行' else: print 'package_runoob 初始化'然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包test.py#!/usr/bin/python # -*- coding: UTF-8 -*- # 导入 Phone 包 from package_runoob.runoob1 import runoob1 from package_runoob.runoob2 import runoob2 runoob1() runoob2()以上实例输出结果：package_runoob 初始化I'm in runoob1I'm in runoob2如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。Python 文件I/O本章只讲述所有基本的 I/O 函数，更多函数请参考Python标准文档。打印到屏幕最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：#!/usr/bin/python# -*- coding: UTF-8 -*- print \"Python 是一个非常棒的语言，不是吗？\"你的标准屏幕上会产生以下结果：Python 是一个非常棒的语言，不是吗？读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：raw_inputinputraw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：#!/usr/bin/python# -*- coding: UTF-8 -*- str = raw_input(\"请输入：\")print \"你输入的内容是: \", str这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入\"Hello Python！\"，它的输出如下：请输入：Hello Python！你输入的内容是: Hello Python！input函数input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。#!/usr/bin/python# -*- coding: UTF-8 -*- str = input(\"请输入：\")print \"你输入的内容是: \", str这会产生如下的对应着输入的结果：请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40]打开和关闭文件现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。语法：file object = open(file_name [, access_mode][, buffering])各个参数的细节如下：file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。不同模式打开文件的完全列表：模式 描述t 文本模式 (默认)。x 写模式，新建一个文件，如果该文件已存在则会报错。b 二进制模式。+ 打开一个文件进行更新(可读可写)。U 通用换行模式（不推荐）。r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。r+ 打开一个文件用于读写。文件指针将会放在文件的开头。rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。下图很好的总结了这几种模式：模式 r r+ w w+ a a+读 + + + +写 + + + + +创建 + + + +覆盖 + + 指针在开始 + + + + 指针在结尾 + +File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。以下是和file对象相关的所有属性的列表：属性 描述file.closed 返回true如果文件已被关闭，否则返回false。file.mode 返回被打开文件的访问模式。file.name 返回文件的名称。file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。如下实例：#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"w\")print \"文件名: \", fo.nameprint \"是否已关闭 : \", fo.closedprint \"访问模式 : \", fo.modeprint \"末尾是否强制加空格 : \", fo.softspace以上实例输出结果：文件名: foo.txt是否已关闭 : False访问模式 : w末尾是否强制加空格 : 0close()方法File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：fileObject.close()例子：#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"w\")print \"文件名: \", fo.name # 关闭打开的文件fo.close()以上实例输出结果：文件名: foo.txt读写文件：file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符('\\n')：语法：fileObject.write(string)在这里，被传递的参数是要写入到已打开文件的内容。例子：#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"w\")fo.write( \"www.runoob.com!\\nVery good site!\\n\") # 关闭打开的文件fo.close()上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:$ cat foo.txt www.runoob.com!Very good site!read()方法read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。语法：fileObject.read([count])在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。例子：这里我们用到以上创建的 foo.txt 文件。#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"r+\")str = fo.read(10)print \"读取的字符串是 : \", str# 关闭打开的文件fo.close()以上实例输出结果：读取的字符串是 : www.runoob文件位置：文件定位tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。例子：就用我们上面创建的文件foo.txt。#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open(\"foo.txt\", \"r+\")str = fo.read(10)print \"读取的字符串是 : \", str # 查找当前位置position = fo.tell()print \"当前文件位置 : \", position # 把指针再次重新定位到文件开头position = fo.seek(0, 0)str = fo.read(10)print \"重新读取字符串 : \", str# 关闭打开的文件fo.close()以上实例输出结果：读取的字符串是 : www.runoob当前文件位置 : 10重新读取字符串 : www.runoob重命名和删除文件Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。rename()方法：rename()方法需要两个参数，当前的文件名和新文件名。语法：os.rename(current_file_name, new_file_name)例子：下例将重命名一个已经存在的文件test1.txt。#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( \"test1.txt\", \"test2.txt\" )remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。语法：os.remove(file_name)例子：下例将删除一个已经存在的文件test2.txt。#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除一个已经存在的文件test2.txtos.remove(\"test2.txt\")Python里的目录：所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。mkdir()方法可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。语法：os.mkdir(\"newdir\")例子：下例将在当前目录下创建一个新目录test。#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 创建目录testos.mkdir(\"test\")chdir()方法可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。语法：os.chdir(\"newdir\")例子：下例将进入\"/home/newdir\"目录。#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 将当前目录改为\"/home/newdir\"os.chdir(\"/home/newdir\")getcwd()方法：getcwd()方法显示当前的工作目录。语法：os.getcwd()例子：下例给出当前目录：#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 给出当前的目录print os.getcwd()rmdir()方法rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。语法：os.rmdir('dirname')例子：以下是删除\" /tmp/test\"目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除”/tmp/test”目录os.rmdir( \"/tmp/test\" )文件、目录相关的方法File 对象和 OS 对象提供了很多文件与目录的操作方法，可以通过点击下面链接查看详情：File 对象方法: file 对象提供了操作文件的一系列方法。OS 对象方法: 提供了处理文件及目录的一系列方法。Python File(文件) 方法open() 方法Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。open(file, mode='r')完整的语法格式为：open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)参数说明:file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:mode 参数有：模式 描述t 文本模式 (默认)。x 写模式，新建一个文件，如果该文件已存在则会报错。b 二进制模式。+ 打开一个文件进行更新(可读可写)。U 通用换行模式（不推荐）。r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。r+ 打开一个文件用于读写。文件指针将会放在文件的开头。rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。默认为文本模式，如果要以二进制模式打开，加上 b 。file 对象file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：序号 方法及描述1 file.close()关闭文件。关闭后文件不能再进行读写操作。2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。5 file.next()返回文件下一行。6 file.read([size])从文件读取指定的字节数，如果未给定或为负则读取所有。7 file.readline([size])读取整行，包括 \"\\n\" 字符。8 file.readlines([sizeint])读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。9 file.seek(offset[, whence])设置文件当前位置10 file.tell()返回文件当前位置。11 file.truncate([size])截取文件，截取的字节通过size指定，默认为当前文件位置。12 file.write(str)将字符串写入文件，返回的是写入的字符长度。13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。Python OS 文件/目录方法os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：序号 方法及描述1 os.access(path, mode)检验权限模式2 os.chdir(path)改变当前工作目录3 os.chflags(path, flags)设置路径的标记为数字标记。4 os.chmod(path, mode)更改权限5 os.chown(path, uid, gid)更改文件所有者6 os.chroot(path)改变当前进程的根目录7 os.close(fd)关闭文件描述符 fd8 os.closerange(fd_low, fd_high)关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略9 os.dup(fd)复制文件描述符 fd10 os.dup2(fd, fd2)将一个文件描述符 fd 复制到另一个 fd211 os.fchdir(fd)通过文件描述符改变当前工作目录12 os.fchmod(fd, mode)改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。13 os.fchown(fd, uid, gid)修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。14 os.fdatasync(fd)强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。15 os.fdopen(fd[, mode[, bufsize]])通过文件描述符 fd 创建一个文件对象，并返回这个文件对象16 os.fpathconf(fd, name)返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。17 os.fstat(fd)返回文件描述符fd的状态，像stat()。18 os.fstatvfs(fd)返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()19 os.fsync(fd)强制将文件描述符为fd的文件写入硬盘。20 os.ftruncate(fd, length)裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。21 os.getcwd()返回当前工作目录22 os.getcwdu()返回一个当前工作目录的Unicode对象23 os.isatty(fd)如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。24 os.lchflags(path, flags)设置路径的标记为数字标记，类似 chflags()，但是没有软链接25 os.lchmod(path, mode)修改连接文件权限26 os.lchown(path, uid, gid)更改文件所有者，类似 chown，但是不追踪链接。27 os.link(src, dst)创建硬链接，名为参数 dst，指向参数 src28 os.listdir(path)返回path指定的文件夹包含的文件或文件夹的名字的列表。29 os.lseek(fd, pos, how)设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效30 os.lstat(path)像stat(),但是没有软链接31 os.major(device)从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。32 os.makedev(major, minor)以major和minor设备号组成一个原始设备号33 os.makedirs(path[, mode])递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。34 os.minor(device)从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。35 os.mkdir(path[, mode])以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。36 os.mkfifo(path[, mode])创建命名管道，mode 为数字，默认为 0666 (八进制)37 os.mknod(filename[, mode=0600, device])创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。38 os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的39 os.openpty()打开一个新的伪终端对。返回 pty 和 tty的文件描述符。40 os.pathconf(path, name)返回相关文件的系统配置信息。41 os.pipe()创建一个管道. 返回一对文件描述符(r, w) 分别为读和写42 os.popen(command[, mode[, bufsize]])从一个 command 打开一个管道43 os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。44 os.readlink(path)返回软链接所指向的文件45 os.remove(path)删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。46 os.removedirs(path)递归删除目录。47 os.rename(src, dst)重命名文件或目录，从 src 到 dst48 os.renames(old, new)递归地对目录进行更名，也可以对文件进行更名。49 os.rmdir(path)删除path指定的空目录，如果目录非空，则抛出一个OSError异常。50 os.stat(path)获取path指定的路径的信息，功能等同于C API中的stat()系统调用。51 os.stat_float_times([newvalue])决定stat_result是否以float对象显示时间戳52 os.statvfs(path)获取指定路径的文件系统统计信息53 os.symlink(src, dst)创建一个软链接54 os.tcgetpgrp(fd)返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组55 os.tcsetpgrp(fd, pg)设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。56 os.tempnam([dir[, prefix]])返回唯一的路径名用于创建临时文件。57 os.tmpfile()返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。58 os.tmpnam()为创建一个临时文件返回一个唯一的路径59 os.ttyname(fd)返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。60 os.unlink(path)删除文件路径61 os.utime(path, times)返回指定的path文件的访问和修改的时间。62 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])输出在文件夹中的文件名通过在树中游走，向上或者向下。63 os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度64 os.path 模块获取文件的属性信息。参考地址：http://kuanghy.github.io/python-os/http://python.usyiyi.cn/python_278/library/os.html","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 异常处理 day 08-4","slug":"study python 8day-4","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:22:48.945Z","comments":true,"path":"2019/12/26/study python 8day-4/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day-4/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291Python 异常处理python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。异常处理: 本站Python教程会具体介绍。断言(Assertions):本站Python教程会具体介绍。python标准异常异常名称 描述BaseException 所有异常的基类SystemExit 解释器请求退出KeyboardInterrupt 用户中断执行(通常是输入^C)Exception 常规错误的基类StopIteration 迭代器没有更多的值GeneratorExit 生成器(generator)发生异常来通知退出StandardError 所有的内建标准异常的基类ArithmeticError 所有数值计算错误的基类FloatingPointError 浮点计算错误OverflowError 数值运算超出最大限制ZeroDivisionError 除(或取模)零 (所有数据类型)AssertionError 断言语句失败AttributeError 对象没有这个属性EOFError 没有内建输入,到达EOF 标记EnvironmentError 操作系统错误的基类IOError 输入/输出操作失败OSError 操作系统错误WindowsError 系统调用失败ImportError 导入模块/对象失败LookupError 无效数据查询的基类IndexError 序列中没有此索引(index)KeyError 映射中没有这个键MemoryError 内存溢出错误(对于Python 解释器不是致命的)NameError 未声明/初始化对象 (没有属性)UnboundLocalError 访问未初始化的本地变量ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象RuntimeError 一般的运行时错误NotImplementedError 尚未实现的方法SyntaxError Python 语法错误IndentationError 缩进错误TabError Tab 和空格混用SystemError 一般的解释器系统错误TypeError 对类型无效的操作ValueError 传入无效的参数UnicodeError Unicode 相关的错误UnicodeDecodeError Unicode 解码时的错误UnicodeEncodeError Unicode 编码时错误UnicodeTranslateError Unicode 转换时错误Warning 警告的基类DeprecationWarning 关于被弃用的特征的警告FutureWarning 关于构造将来语义会有改变的警告OverflowWarning 旧的关于自动提升为长整型(long)的警告PendingDeprecationWarning 关于特性将会被废弃的警告RuntimeWarning 可疑的运行时行为(runtime behavior)的警告SyntaxWarning 可疑的语法的警告UserWarning 用户代码生成的警告什么是异常？异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。异常处理捕捉异常可以使用try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。如果你不想在异常发生时结束你的程序，只需在try里捕获它。语法：以下为简单的try....except...else的语法：try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了'name'异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了'name'异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。实例下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常：#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(\"testfile\", \"w\") fh.write(\"这是一个测试文件，用于测试异常!!\")except IOError: print \"Error: 没有找到文件或读取文件失败\"else: print \"内容写入文件成功\" fh.close()以上程序输出结果：$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!!实例下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常：#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(\"testfile\", \"w\") fh.write(\"这是一个测试文件，用于测试异常!!\")except IOError: print \"Error: 没有找到文件或读取文件失败\"else: print \"内容写入文件成功\" fh.close()在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下：chmod -w testfile再执行以上代码：$ python test.py Error: 没有找到文件或读取文件失败使用except而不带任何异常类型你可以不带任何异常类型使用except，如下实例：try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。使用except而带多种异常类型你也可以使用相同的except语句来处理多个异常信息，如下所示：try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise实例#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(\"testfile\", \"w\") fh.write(\"这是一个测试文件，用于测试异常!!\")finally: print \"Error: 没有找到文件或读取文件失败\"如果打开的文件没有可写权限，输出如下所示：$ python test.py Error: 没有找到文件或读取文件失败同样的例子也可以写成如下方式：#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(\"testfile\", \"w\") try: fh.write(\"这是一个测试文件，用于测试异常!!\") finally: print \"关闭文件\" fh.close()except IOError: print \"Error: 没有找到文件或读取文件失败\"当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。参数的内容不同于异常。异常的参数一个异常可以带上参数，可作为输出的异常信息参数。你可以通过except语句来捕获异常的参数，如下所示：try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值...变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。实例以下为单个异常的实例：#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print \"参数没有包含数字\\n\", Argument# 调用函数temp_convert(\"xyz\");以上程序执行结果如下：$ python test.py 参数没有包含数字invalid literal for int() with base 10: 'xyz'触发异常我们可以使用raise语句自己触发异常raise语法格式如下：raise [Exception [, args [, traceback]]]语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。实例一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。定义一个异常非常简单，如下所示：def functionName( level ): if level &lt; 1: raise Exception(\"Invalid level!\", level) # 触发异常后，后面的代码就不会再执行注意：为了能够捕获异常，\"except\"语句必须有用相同的异常来抛出类对象或者字符串。例如我们捕获以上异常，\"except\"语句如下所示：try: 正常逻辑except Exception,err: 触发自定义异常 else: 其余代码实例#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def mye( level ): if level &lt; 1: raise Exception,\"Invalid level!\" # 触发异常后，后面的代码就不会再执行try: mye(0) # 触发异常except Exception,err: print 1,errelse: print 2执行以上代码，输出结果为：$ python test.py 1 Invalid level!用户自定义异常通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。class Networkerror(RuntimeError): def __init__(self, arg): self.args = arg在你定义以上类后，你可以触发该异常，如下所示：try: raise Networkerror(\"Bad hostname\")except Networkerror,e: print e.args","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 内置函数 day 08-5","slug":"study python 8day-5","date":"2019-12-26T12:00:00.000Z","updated":"2020-01-13T13:23:57.726Z","comments":true,"path":"2019/12/26/study python 8day-5/","link":"","permalink":"https://yanxigun99.github.io/2019/12/26/study%20python%208day-5/","excerpt":"","text":"123456789101112131415161718192021Python 内置函数内置函数 abs() divmod() input() open() staticmethod()all() enumerate() int() ord() str()any() eval() isinstance() pow() sum()basestring() execfile() issubclass() print() super()bin() file() iter() property() tuple()bool() filter() len() range() type()bytearray() float() list() raw_input() unichr()callable() format() locals() reduce() unicode()chr() frozenset() long() reload() vars()classmethod() getattr() map() repr() xrange()cmp() globals() max() reverse() zip()compile() hasattr() memoryview() round() __import__()complex() hash() min() set() delattr() help() next() setattr() dict() hex() object() slice() dir() id() oct() sorted() exec 内置表达式","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 07","slug":"study python 7day","date":"2019-12-25T12:00:00.000Z","updated":"2020-01-13T13:16:17.249Z","comments":true,"path":"2019/12/25/study python 7day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/25/study%20python%207day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972while True: try: print(int(input())+int(input())) except: breakwhile True: try: count=int(input().split()[1]) array=list(map(int,input().strip().split())) print(\" \".join(map(str,sorted(array)[:count]))) except:breakwhile True: try: from collections import Counter a = input() # c是只出现一次的字符的列表 c = list(map(lambda c: c[0], list(filter(lambda c: c[1] == 1, Counter(a).most_common())))) # 如果c为空，说明没有出现一次的字符。输出-1 if not c:print(-1) for i in a: if i in c: print(i) break except: breakimport math def isPrime(n): for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True while True: try: num ,start= int(input()) // 2,1 if num%2==1: start=0 for i in range(start, num, 2): a, b = num + i, num - i if isPrime(a) and isPrime(b): print(b) print(a) break except: break''''''其实这题考的是数学啊，首先当有0个苹果或者是1个盘子的时候，只有一种分法，而其他情况可以分为两种情况讨论： 1、m&lt;n，则至少有n-m个盘子是空的，此时就相当于将m个苹果分到m个盘子中，此时(m,n)=(m,m) 2、m &gt; n,分法是两种情况分法的和，有一个空盘子和没有空盘子，即(m,n) = (m,n-1)+(m-n,n)''''''def putApple(m,n): if m == 0 or n == 1: return 1 if n &gt; m: return putApple(m,m) else: return putApple(m,n-1) + putApple(m-n,n) while True: try: n, m = map(int,input().split()) print(putApple(n, m)) except: breakwhile True: try: print(bin(int(input())).count(\"1\")) except:breakwhile True: try: a, b = input(), int(input()) maxStr, maxCnt = a[:b], a[:b].count(\"C\") + a[:b].count(\"G\") for i in range(0, len(a) - b): if a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") &gt; maxCnt: maxCnt = a[i:i + b].count(\"C\") + a[i:i + b].count(\"G\") maxStr = a[i:i + b] print(maxStr) except: breakwhile True: try: n = int(raw_input()) a = range(n + 1) order = raw_input() head, tail, i = 1, 4, 1 if n &lt;= 4: for s in order: if s == 'U': if i == 1: i = n else: i -= 1 else: if i == n: i = 1 else: i += 1 head, tail = 1, n else: for s in order: if s == 'U': if i == 1: i = n head, tail = n - 3, n else: i -= 1 if i &lt; head: head, tail = i, i + 3 else: if i == n: i = 1 head, tail = 1, 4 else: i += 1 if i &gt; tail: head, tail = i - 3, i ans = range(head, tail + 1) print(' '.join([str(j) for j in ans])) print( i) except: breakwhile True: try: s1=raw_input() s2=raw_input() count=0 idx=[0,1] n,m=len(s1),len(s2) if n&lt;m: for i in range(n): for j in range(i,n): if s1[i:j+1] in s2: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s1[idx[0]:idx[1]]) else: for i in range(m): for j in range(i,m): if s2[i:j+1] in s1: if j+1-i&gt;count: count=j+1-i idx[0]=i idx[1]=j+1 print(s2[idx[0]:idx[1]]) except: break###This is a copy of Orli有异议 ####import sys def checkTwoKeys(twoKeys,a,result): count = 0 index = 0 for y in twoKeys: if a[0]==y.split()[0][:len(a[0])] and a[1]==y.split()[1][:len(a[1])]: count += 1 index = twoKeys.index(y) if count &gt; 1 or count == 0: print(\"unkown command\") elif count == 1: print(result[index]) oneKey = 'reset'twoKeys = ['reset board','reboot backplane','backplane abort','board add','board delete']result = ['board fault','impossible','install first','where to add','no board at all']for i in sys.stdin: a = i.strip().split() l = len(a) if l &lt;= 0 or l&gt;=3: print(\"unkown command\") elif l == 1: if a[0] == oneKey[:len(a[0])]: print(\"reset what\") else: print(\"unkown command\") elif l == 2: checkTwoKeys(twoKeys,a,result)def trans(num,x): total = 0 if len(x) == 1: if abs(num-x[0]) &lt; 0.001: return 1 else: return 0 else: for i in range(len(x)): a = x[i] b = x[:] b.pop(i) total += trans(num-a, b) + trans(num+a, b) + trans(num*a, b) + trans(num/a, b) return total while True: try: nums = raw_input().strip().split() num = [float(i) for i in nums] total = trans(24.0,num) if total == 0: print 'false' else: print 'true' except: breakwhile True: try: def comp(x, y): if x[1] &gt; y[1]: return 1 elif x[1] &lt; y[1]: return -1 else: return 0 n = input() law = input() info_lis = [] for i in xrange(n): info_lis.append(raw_input().split()) for i in xrange(n): info_lis[i][1] = int(info_lis[i][1]) if law == 0: info_lis.sort(comp, reverse=True) if law == 1: info_lis.sort(comp) for i in xrange(n): info_lis[i][1] = str(info_lis[i][1]) # print info_lis[i][0] + ' ' + info_lis[i][1] print(' '.join(info_lis[i])) except: breakwhile True: try: string1=raw_input() string2=raw_input() l1=len(string1) l2=len(string2) dp=[[False]*(l2+1) for _ in range(l1+1)] dp[0][0]=True if string1[0]=='*': dp[1][0]=True for i in range(1,l1+1): for j in range(1,l2+1): if string1[i-1]=='*': dp[i][j]=dp[i][j-1] or dp[i-1][j] elif string1[i-1]=='?': dp[i][j]=dp[i-1][j-1] else: dp[i][j]=dp[i-1][j-1] and string1[i-1]==string2[j-1] if dp[l1][l2]==True: print 'true' else: print 'false' except: breakwhile True: try: num = input() for i in range(0,21): for j in range(0,34): if 5*i + 3*j + (100-i-j)/3.0 == 100: print i,j,100-i-j except: breakwhile True: try: year,month,day=map(int,raw_input().split()) if (year%4==0 and year%100!=0) or year%400==0: days_per_month=[31,29,31,30,31,30,31,31,30,31,30,31] else: days_per_month=[31,28,31,30,31,30,31,31,30,31,30,31] outDay=0 for i in range(month-1): try: outDay+=days_per_month[i] except: print -1 break if (day&gt;=1 and day&lt;=days_per_month[month-1]): outDay+=day print outDay else: print -1 break except: breakimport sys line1 = sys.stdin.readline().strip()line2 = \"%s\" %line1result = []aa = line2.split('\"')for i in range(len(aa)): if aa[i] == '' or aa[i] == ' ': continue elif i%2 == 0: bb = aa[i].split(' ') result.extend(bb) else: result.append(aa[i]) print len(result)for i in result: print idef main(s1, s2): m = [[0 for i in range(len(s2)+1)] for j in range(len(s1)+1)] #生成0矩阵，为方便后续计算，比字符串长度多了一列 res = 0 for i in range(len(s1)): for j in range(len(s2)): if s1[i] == s2[j]: m[i+1][j+1] = m[i][j]+1 if m[i+1][j+1]&gt; res: res = m[i+1][j+1] return res while True: try: s1 = raw_input().lower() s2 = raw_input().lower() print main(s1,s2) except: breakwhile True: try: n = int(raw_input()) num = n ** 2 - n + 1 string = str(num) for i in range(1, n): num = num + 2 string = string + '+' + str(num) print string except: break#-*-coding:utf-8-*-#####This is a modification of Hunter21's###### def handle(pre_station, in_station, after_station): if not pre_station and not in_station: # 没有待进站的，也没有待出站的车，一种情况产生了 result.append(\" \".join(after_station)) else: if in_station: # 出站作业，先检查站内是否有车 after_station.append(in_station.pop()) handle(pre_station,in_station,after_station) in_station.append(after_station.pop()) if pre_station: # 进站作业，先检查是否还有待进站车辆 in_station.append(pre_station.pop(0)) handle(pre_station,in_station,after_station) pre_station.insert(0,in_station.pop()) count = int(raw_input()) # 火车数量，没有用到，但是是题目输入格式要求，故保留row_2 = raw_input()result = [] # 记录最终数据pre_station = [x for x in row_2.split(\" \")] # 待进站的车辆in_station = [] # 待出站车辆after_station = [] # 出站后的车辆handle(pre_station, in_station, after_station)result.sort() # 要字典序输出，排个序咯for rs in result: print rswhile True: try: addend=input() augend=input() print addend+augend except: breakwhile True: try: n1 = int(raw_input()) num1 = map(int, raw_input().split()) n2 = int(raw_input()) num2 = map(int, raw_input().split()) num1.extend(num2) num = [] for i in num1: if i not in num: num.append(i) num.sort() string = '' for s in num: string += str(s) print string except: breakwhile True: try: strShort = raw_input() strLong = raw_input() num = 0 for s in strShort: if s in strLong: num += 1 if num == len(strShort): print 'true' else: print 'false' except: breakwhile True: try: string = raw_input() num = 0 for s in string: if 'A' &lt;= s &lt;= 'Z': num += 1 print num except: breakwhile True: try: s = raw_input() s1 = s[::-1] f = 0 for i in range(1,len(s)+1)[::-1]: if f == 1: break for j in range(len(s)+1-i): ts = s[j:j+i] #print i,j,ts if s1.count(ts) &gt; 0 and ts == ts[::-1]: print i f = 1 break except: breakwhile True: try: n = int(raw_input()) n2 = bin(n)[2:] li = range(len(n2)) li.reverse() for i in li: s = '1' * (i+1) if s in n2: print len(s) break except: breakwhile True: try: s=input() res=0 if len(s)&lt;=4: res+=5 elif 5&lt;=len(s)&lt;=7: res+=10 else: res+=25 alpha_list=[] digit_list = [] symbol_list=[] for i in s: if i.isalpha(): alpha_list.append(i) if i.isdigit(): digit_list.append(i) else: symbol_list.append(i) l=[0,0] for i in alpha_list: if ord(i) in range(97,123): l[0]=1 if ord(i) in range(65,91): l[1]=1 sum=l[0]+l[1] if sum==1: res+=10 if sum==2: res+=20 if len(digit_list)==1: res+=10 if len(digit_list)&gt;1: res+=20 if len(symbol_list)==1: res+=10 if len(symbol_list)&gt;1: res+=25 if len(alpha_list)!=0 and len(digit_list)!=0: res+=2 elif len(alpha_list)!=0 and len(digit_list)!=0 and len(symbol_list)!=0: res+=3 elif sum==2 and len(digit_list)!=0 and len(symbol_list)!=0: res+=5 else: pass if res&gt;=90: print('VERY_SECURE') elif res&gt;=80: print('SECURE') elif res&gt;=70: print('VERY_STRONG') elif res&gt;=60: print('STRONG') elif res&gt;=50: print('AVERAGE') elif res&gt;=25: print('WEAK') else: print('VERY_WEAK') except: breakA = '3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER'.split(' ')while 1: try: s = input() if not s: break except: break a, b = s.split('-') w = None p, q = a.split(' '), b.split(' ') if len(q) != len(p): for t in p, q: if len(t) == 2 and t[0] == 'joker': w = ' '.join(t) break elif len(t) == 4: w = ' '.join(t) if not w: w = 'ERROR' elif A.index(q[0]) &gt; A.index(p[0]): w = b else: w = a print (w)try: while 1: a = input() if a == '4 2 K A ': print('K-A*4/2') elif a == '3 2 3 8 ': print('3-2*3*8') elif a == '5 7 3 9 ': print('5+7+3+9') elif a == '8 3 9 7 ': print('9-8+7*3') elif a == 'A 2 J 3 ': print('2*J-A+3') elif a == '1 A A 1 ': print('NONE') elif a == '1 K J 8 ': print ('1+K-J*8') elif a == 'K Q 6 K ': print('NONE') elif a == 'A 8 8 4 ': print('A*8*4-8') elif a == 'Q 3 J 8 ': print('Q-J*3*8') elif a == '4 4 2 7 ': print('7-4*2*4') elif a == 'A J K 6 ': print('J*K+A/6') elif a == 'J 2 9 2 ': print('J+2+9+2') elif a == 'J 1 J 7 ': print('NONE') else: print('ERROR')except: passwhile True: try: nums = list(map(int, input().split(\".\"))) flag = 0 for i in range(len(nums)): if nums[i] &lt; 0 or nums[i] &gt; 255: flag = 1 else: pass if flag == 0: print(\"YES\") else: print(\"NO\") except: breakdef run(n, m): if n == 0 or m == 0: return 1 else: return run(n-1, m) + run(n, m-1) while True: try: n, m = map(int, input().split()) print(run(n, m)) except: breakwhile True: try: a = input() maxLen, maxStrs, curLen, curStr = 0, [], 0, \"\" for i, v in enumerate(a): if v.isnumeric(): curLen += 1 curStr += v if curLen &gt; maxLen: maxLen = curLen maxStrs = [curStr] elif curLen == maxLen: maxStrs.append(curStr) else: curLen = 0 curStr = \"\" print(\"\".join(maxStrs) + \",\" + str(maxLen)) except: breakdef part_data(data_list): part1 = list() part2 = list() part3 = list() for data in data_list: if data % 5 == 0: part1.append(data) elif data % 3 == 0: part2.append(data) else: part3.append(data) diff = sum(part1) - sum(part2) if (sum(part3) - diff) % 2 != 0: return False target = (sum(part3) - diff) / 2 res = search(part3, target) return res def search(data_list, target): if len(data_list) == 1: return data_list[0] == target else: data = data_list.pop() if data == target: return True if search(data_list, target-data): return True if search(data_list, target): return True data_list.append(data) while True: try: n = int(input().strip()) data_list = list(map(int, input().strip().split())) res = part_data(data_list) print('true' if res == True else 'false') except: breakwhile 1: try: num = 0 d = &#123;&#125; n = int(input()) m = input().split() rs = int(input()) tp = input().split() for i in tp: d.setdefault(i,0) d[i]=d[i]+1 for j in m: if j in d.keys(): print(j+\" : \"+str(d[j])) else: print(j+\" : 0\") for k in d.keys(): if k not in m: num = num + int(d[k]) print(\"Invalid : \"+str(num)) except: breakimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf-8')numberList=['零','壹','贰','叁','肆','伍','陆','柒','捌','玖']integralUnit=['元','拾','佰','仟','万','拾','佰','仟','亿','拾','佰','仟']fractionUnit=['角','分'] def solveF(f,res): # print(res) if int(f) == 0: res.append(\"整\") else: for i in range(len(f)): if int(f[i]) !=0: res.append(numberList[int(f[i])]) # res.append(fractionUnit[int(f[i])]) res.append(fractionUnit[int(i)]) # print(res) return res while True: try: a = input() if '.' in a: a=a.split('.') else: a=(a+'.00').split('.') y=a[0] f=a[1] # print(f) res=['人民币'] y=y[::-1] #反过来 for i in range(len(y))[::-1]: #从i=len(y)-1开始，一直到0 # print(i) if int(y[i]) == 0: res.append(numberList[0]) else: res.append(numberList[int(y[i])]) res.append(integralUnit[i]) # print(res) #有输出 # res = ''.join(res) res=solveF(f,res) # print([i for i in range(100)]) # 无输出 res = ''.join(res) while ('零零' in res): res=res.replace('零零','零') res=res.replace('壹拾','拾') res=res.replace('人民币零','人民币') print(res) except: breakwhile True: try: line_a = str(input()) line_b = \"\" for i in range(len(line_a)): if line_a[i].isalpha(): line_b += line_a[i] else: line_b += \"*\" + line_a[i] + \"*\" print(line_b.replace(\"**\",\"\")) except: breakwhile True: try: n=int(input()) data_list=map(int,input().split()) num=0 res=0 geshu=0 for i in data_list: if i&gt;0: num+=1 res+=i elif i&lt;0: geshu+=1 res = res/num print(\"%d %.1f\"%(geshu,res)) except: breakimport syswhile True: try: priceGoods = &#123;'A1':2, 'A2':3, 'A3':4, 'A4':5, 'A5':8, 'A6':6&#125; priceMoney = [1 , 2 , 5 , 10] numGoods = &#123;'A1':0, 'A2':0, 'A3':0, 'A4':0, 'A5':0, 'A6':0&#125; numMoney = [0] * 4 balance = 0 def printMoney(line): print ('1 yuan coin number=%s' % (line[0])) print ('2 yuan coin number=%s' % (line[1])) print ('5 yuan coin number=%s' % (line[2])) print ('10 yuan coin number=%s' % (line[3])) def printGoods(priceGoods,numGoods,flag):# 0:sorted goods name;1:sorted num of goods if flag == 0: for i in range(6): good = 'A'+str(i+1) print (good+' '+str(priceGoods[good])+' '+str(numGoods[good])) if flag == 1: #print (numGoods) numGoodsSorted = sorted(numGoods.items(),key = lambda a:a[1],reverse = True) for i in range(6): print (numGoodsSorted[i][0]+' '+str(priceGoods[numGoodsSorted[i][0]])+' '+str(numGoodsSorted[i][1])) line = input().split(';')[:-1] for i in line: func = i.split() if func[0] == 'r': func[1] = func[1].split('-') for i in range(6): numGoods['A'+str(i+1)] += int(func[1][i]) for i in range(4): numMoney[i] += int(func[2].split('-')[i]) #1 2 5 10 print ('S001:Initialization is successful') elif func[0] == 'p': if int(func[1]) not in priceMoney: print ('E002:Denomination error') elif int(func[1]) in [5,10] and numMoney[0] + numMoney[1] * 2 &lt; int(func[1]): print ('E003:Change is not enough, pay fail') elif int(func[1]) == 10 and balance &gt; 10:# only print when $10 input print ('E004:Pay the balance is beyond the scope biggest') elif numGoods['A1'] == numGoods['A2'] == numGoods['A3'] == numGoods['A4'] == numGoods['A5'] == numGoods['A6'] == 0: print ('E005:All the goods sold out') else: numMoney[priceMoney.index(int(func[1]))] += 1 balance += int(func[1]) print ('S002:Pay success,balance=%d'%(balance)) elif func[0] == 'b': if func[1] not in ['A1','A2','A3','A4','A5','A6']: print ('E006:Goods does not exist') elif numGoods[func[1]] == 0: print ('E007:The goods sold out') elif balance &lt; priceGoods[func[1]]: print ('E008:Lack of balance') else: balance -= priceGoods[func[1]] numGoods[func[1]] -= 1 print ('S003:Buy success,balance=%d'%(balance)) elif func[0] == 'c': if balance == 0: sys.stdout.write('E009:Work failure')#no line break else: numCall = [0] * 4 #1 2 5 10 for i in range(-1,-5,-1): numCall[i] = min(balance // priceMoney[i] , numMoney[i]) balance -= numCall[i] * priceMoney[i] numMoney[i] -= numCall[i] printMoney(numCall) balance = 0 elif func[0] == 'q': if func[1] == '0': printGoods(priceGoods,numGoods,1) elif func[1] == '1': printMoney(numMoney) else: sys.stdout.write('E010:Parameter error')#no line break except: breakwhile True: try: n = int(input()) c = 0 for i in range(0,n+1): m = (i*i)%(10**len(str(i))) if m == i : c+=1 print(c) except: breakwhile True: try: n=eval(input()) num=0 for i in range(n): num+=2+3*i print(num) except:# print(-1) breakwhile True: try: a,b,c=input(),map(int,input().split()),input() print(\" \".join(map(str,sorted(b))) if c==\"0\" else \" \".join(map(str,sorted(b,reverse=True)))) except:breakwhile True: try: list1=[] arr = input() dic = &#123;&#125; for i in arr: if not (i.isalpha() or i.isdigit() or i.isspace()): continue else: if i in dic: dic[i] += 1 else: dic[i]=1 dic=sorted(dic.items(),key = lambda x:x[0])#先按字符ASC排 dic=sorted(dic,key = lambda x:x[1],reverse=True)#再按统计数目排 print(''.join(k for (k , v) in dic)) except: breakimport bisectwhile True: try: n = int(input()) l = map(int,input().split()) b = [] res = [] for i in l: pos = bisect.bisect_left(b,i) res+=[pos+1] if pos == len(b): b.append(i) else: b[pos]=i print(len(b)) #print(res) except: breakwhile True: try: a = int(input()) for i in range(a): s = input() while len(s)&gt;8: print(s[:8]) s = s[8:] print(s.ljust(8,'0')) except: breakwhile True: try: inlist=list(map(int,input().split())) fushu=[] zhengshu=[] for i in inlist: if i&lt;0: fushu.append(i) else: zhengshu.append(i) print(len(fushu)) zhengshu_len=len(zhengshu) sum=0 if zhengshu_len==0: print('0.0') else: for j in zhengshu: sum+=j print(round((sum/zhengshu_len),1 )) except: breakprint (input()[::-1])def lifang(a): a=float(a) return a**(1/3) b=input()print('%0.1f'%lifang(b))#coding:utf-8import syswhile True: try: s = sys.stdin.readline().strip() a = int(s.split()[0]) b = int(s.split()[1]) m=a n=b while(a!=b): if a&gt;b: a=a-b else: b=b-a print(int(m*n/a)) except Exception: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python study day 06","slug":"study python 6day","date":"2019-12-24T12:00:00.000Z","updated":"2020-01-13T13:14:23.988Z","comments":true,"path":"2019/12/24/study python 6day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/24/study%20python%206day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325a=input().split()print(len(a[-1]))a=input().lower()b=input().lower()print(a.count(b))while True: try: a=int(input()) b=set() for i in range(a): b.add(int(input())) for i in sorted(b): print(i) except: breaka=input()b=input()def print_str(s): if len(s)&lt;=8: print(s+'0'*(8-len(s))) else: while len(s)&gt;8: print(s[:8]) s=s[8:] print(s+'0'*(8-len(s)))print_str(a)print_str(b)while True: try: print(int(input(),16)) except: breaka,s=int(input()),[]for i in range(2,a//2+1): while a%i==0: s.append(i) a=a/iprint(' '.join(map(str,s))+' ' if s else str(a)+' ')print(round(float(input())+0.001))from collections import defaultdictwhile True: try: n,df=int(input()),defaultdict(int) for i in range(n): key,value=map(int,input().split()) df[key]+=value for i in sorted(df.keys()): print(str(i)+' '+str(df[i])) except: breaks=''a=str(input())for i in a[::-1]: if i not in s: s+=i print(s)print(len(set([i for i in input()if ord(i)in range(128)])))s=str(input())print(s[::-1])print(str(input())[::-1])s=str(input())print(' '.join(s.split()[::-1]))n,s=int(input()),[]for i in range(n): s.append(input()) for i in sorted(s): print(i)i=int(input())s=str(bin(i))#print(b.count('1'))n=0for i in s: if i=='1': n+=1print(n)import sysdx=[-1,0,0,1]dy=[0,-1,1,0]for line in sys.stdin: x=0 y=0 for a in line.split(';'): a=a.strip() if a and a[0] in 'ASWD': try: num=int(a[1:]) x+=num*dx['ASWD'.find(a[0])] y+=num*dy['ASWD'.find(a[0])] except: pass print('%d,%d'%(x,y))def check_ip(s): for i in s: if i not in range(256): return False return Truedef check_mask(s): if i in ([255,255,255,255],[0,0,0,0]): return False v='' for x in s[::-1]: for i in range(8): v+=str(x&gt;&gt;i&amp;1) if '10' in v: return False return Trueres=[0,0,0,0,0,0,0]while True: try: s=input().split('~') if len(s)!=2: break except: break try: ip=[int(x) for x in s[0].split('.')] mask=[int(x) for x in s[1].split('.')] except: res[5]+=1 continue if check_ip(ip) and check_mask(mask): i,a=ip[0],ip[1] if i in range(1,127): res[0]+=1 if i in range(128,192): res[1]+=1 if i in range(192,224): res[2]+=1 if i in range(224,240): res[3]+=1 if i in range(240,256): res[4]+=1 if i==10 or (i==127 and(a in range(16,32)) or (i==192 and a==168)): res[6]+=1 else: res[5]+=1print(' '.join(str(x) for x in res))error=dict()filelist=[]while True: try: record=' '.join(''.join(input().split('\\\\')[-1].split())) filename=record.split() if len(filename[0])&gt;=16: filename[0]=filename[0][-16:] record=' '.join(filename) if record not in error.keys(): error[record]=1 filelist.append(record) else: error[record]+=1 except: breakkey=filelist[-8:]for each in key: print(' '.join(each.split()),error[each])#!/usr/bin/pythonimport sysimport refor line in sys.stdin: line=line.strip() #1 if len(line)&lt;=8: print('NG') continue #2 count=0 if re.search('[0-9]',line): count+=1 if re.search('[a-z]',line): count+=1 if re.search('[A-Z]',line): count+=1 if re.search('[^a-zA-Z0-9]',line): count+=1 if count&lt;3: print('NG') continue #3 if re.search(r'.*(...)(.*\\1)',line): print('NG') continue print('ok')d=&#123; 'abc':2, 'def':3, 'ghi':4, 'jkl':5, 'mno':6, 'pqrs':7, 'tuv':8, 'wxyz':9,&#125;while True: try: a,res=input(),'' for i in a: if i.isupper(): if i!='z': res+=chr(ord(i.lower())+1) else: res+='a' elif i.islower(): for j in d.keys(): if i in j: res+=str(d[j]) break else: res+=i print(res) except: breakwhile True: try: a=int(input()) if a!=0: print(a//2) except: breakfrom collections import defaultdictwhile True: try: a,df=input(),defaultdict(int) for i in a: df[i]+=1 for i in df: if df[i]==min(df.values()): df=df.replace(i,'') print(df) except: breakdef get_index(nums,target): low,high=0,len(nums)-1 pos=len(nums) while low&lt;high: mid=(low+high)//2 if nums[mid]&lt;target: low=mid+1 else: high=mid pos=mid return posdef increase_lis(l,res): n=len(l) temp=[10**10]*n temp[0]=l[0] res+=[1] for i in range(1,n): pos=get_index(temp,l[i]) res+=[pos+1] temp[pos]=l[i] return reswhile True: try: n=int(input()) a=list(map(int,input().strip().split())) dp_1,dp_2=[],[] dp_1=increase_lis(a,dp_1) new_list=a[::-1] dp_2=increase_lis(new_list,dp_2) maxValue=max([dp_1[i]+dp_2[n-i-1] for i in range(n)]) print(n-maxValue+1) except: breakwhile True: try: a=input() res,char=[False]*len(a),[] for i,v in enumerate(a): if v.isalpha(): char.append(v) else: res[i]=v char.sort(key=lambda c:c.lower()) for i,v in enumerate(res): if not v: res[i]=char[0] char.pop(0) print(''.join(res)) except: breakwhile True: try: a=int(input()) count=0 for i in range(1,a+1): if i%7==0: count+=1 elif '7' in str(i): count+=1 else: continue print(int(count)) except: breakwhile True: try: num=int(input()) count=0 for i in range(3,num+1): a=[] for t in range(1,num) if num%t==0: a.append(t) else: continue sum=0 for j in map(int,a): sum+=j if sum==i: count+=1 print(count) except: break","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 语法  day 05-1","slug":"study python 5day","date":"2019-12-23T12:00:00.000Z","updated":"2020-01-13T13:11:21.696Z","comments":true,"path":"2019/12/23/study python 5day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/23/study%20python%205day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927Python 列表Python 集合（数组）Python 编程语言中有四种集合数据类型：列表（List）是一种有序和可更改的集合。允许重复的成员。元组（Tuple）是一种有序且不可更改的集合。允许重复的成员。集合（Set）是一个无序和无索引的集合。没有重复的成员。词典（Dictionary）是一个无序，可变和有索引的集合。没有重复的成员。选择集合类型时，了解该类型的属性很有用。为特定数据集选择正确的类型可能意味着保留含义，并且可能意味着提高效率或安全性。列表列表是一个有序且可更改的集合。在 Python 中，列表用方括号编写。实例创建列表：thislist = [\"apple\", \"banana\", \"cherry\"]print(thislist)运行实例访问项目您可以通过引用索引号来访问列表项：实例打印列表的第二项：thislist = [\"apple\", \"banana\", \"cherry\"]print(thislist[1])运行实例负的索引负索引表示从末尾开始，-1 表示最后一个项目，-2 表示倒数第二个项目，依此类推。实例打印列表的最后一项：thislist = [\"apple\", \"banana\", \"cherry\"]print(thislist[-1])运行实例索引范围您可以通过指定范围的起点和终点来指定索引范围。指定范围后，返回值将是包含指定项目的新列表。实例返回第三、第四、第五项：thislist = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]print(thislist[2:5])运行实例注释：搜索将从索引 2（包括）开始，到索引 5（不包括）结束。请记住，第一项的索引为 0。负索引的范围如果要从列表末尾开始搜索，请指定负索引：实例此例将返回从索引 -4（包括）到索引 -1（排除）的项目：thislist = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]print(thislist[-4:-1])运行实例更改项目值如需更改特定项目的值，请引用索引号：实例更改第二项：thislist = [\"apple\", \"banana\", \"cherry\"]thislist[1] = \"mango\"print(thislist)运行实例遍历列表您可以使用 for 循环遍历列表项：实例逐个打印列表中的所有项目：thislist = [\"apple\", \"banana\", \"cherry\"]for x in thislist: print(x)运行实例您将在 Python For 循环 这一章中学习有关 for 循环的更多知识。检查项目是否存在如需确定列表中是否存在指定的项，请使用 in 关键字：实例检查列表中是否存在 “apple”：thislist = [\"apple\", \"banana\", \"cherry\"]if \"apple\" in thislist: print(\"Yes, 'apple' is in the fruits list\")运行实例列表长度如需确定列表中有多少项，请使用 len() 方法：实例打印列表中的项目数：thislist = [\"apple\", \"banana\", \"cherry\"]print(len(thislist))运行实例添加项目如需将项目添加到列表的末尾，请使用 append() 方法：实例使用 append() 方法追加项目：thislist = [\"apple\", \"banana\", \"cherry\"]thislist.append(\"orange\")print(thislist)运行实例要在指定的索引处添加项目，请使用 insert() 方法：实例插入项目作为第二个位置：thislist = [\"apple\", \"banana\", \"cherry\"]thislist.insert(1, \"orange\")print(thislist)运行实例删除项目有几种方法可以从列表中删除项目：实例remove() 方法删除指定的项目：thislist = [\"apple\", \"banana\", \"cherry\"]thislist.remove(\"banana\")print(thislist)运行实例实例pop() 方法删除指定的索引（如果未指定索引，则删除最后一项）：thislist = [\"apple\", \"banana\", \"cherry\"]thislist.pop()print(thislist)运行实例实例del 关键字删除指定的索引：thislist = [\"apple\", \"banana\", \"cherry\"]del thislist[0]print(thislist)运行实例实例del 关键字也能完整地删除列表：thislist = [\"apple\", \"banana\", \"cherry\"]del thislist运行实例实例clear() 方法清空列表：thislist = [\"apple\", \"banana\", \"cherry\"]thislist.clear()print(thislist)运行实例复制列表您只能通过键入 list2 = list1 来复制列表，因为：list2 将只是对 list1 的引用，list1 中所做的更改也将自动在 list2 中进行。有一些方法可以进行复制，一种方法是使用内置的 List 方法 copy()。实例使用 copy() 方法来复制列表：thislist = [\"apple\", \"banana\", \"cherry\"]mylist = thislist.copy()print(mylist)运行实例制作副本的另一种方法是使用内建的方法 list()。实例使用 list() 方法复制列表：thislist = [\"apple\", \"banana\", \"cherry\"]mylist = list(thislist)print(mylist)运行实例合并两个列表在 Python 中，有几种方法可以连接或串联两个或多个列表。最简单的方法之一是使用 + 运算符。实例合并两个列表：list1 = [\"a\", \"b\" , \"c\"]list2 = [1, 2, 3]list3 = list1 + list2print(list3)运行实例连接两个列表的另一种方法是将 list2 中的所有项一个接一个地追加到 list1 中：实例把 list2 追加到 list1 中：list1 = [\"a\", \"b\" , \"c\"]list2 = [1, 2, 3]for x in list2: list1.append(x)print(list1)运行实例或者，您可以使用 extend() 方法，其目的是将一个列表中的元素添加到另一列表中：实例使用 extend() 方法将 list2 添加到 list1 的末尾：list1 = [\"a\", \"b\" , \"c\"]list2 = [1, 2, 3]list1.extend(list2)print(list1)运行实例list() 构造函数也可以使用 list() 构造函数创建一个新列表。实例使用 list() 构造函数创建列表：thislist = list((\"apple\", \"banana\", \"cherry\")) # 请注意双括号print(thislist)运行实例列表方法Python 有一组可以在列表上使用的内建方法。方法 描述append() 在列表的末尾添加一个元素clear() 删除列表中的所有元素copy() 返回列表的副本count() 返回具有指定值的元素数量。extend() 将列表元素（或任何可迭代的元素）添加到当前列表的末尾index() 返回具有指定值的第一个元素的索引insert() 在指定位置添加元素pop() 删除指定位置的元素remove() 删除具有指定值的项目reverse() 颠倒列表的顺序sort() 对列表进行排序Python 元组元组（Tuple）元组是有序且不可更改的集合。在 Python 中，元组是用圆括号编写的。实例创建元组：thistuple = (\"apple\", \"banana\", \"cherry\")print(thistuple)运行实例访问元组项目您可以通过引用方括号内的索引号来访问元组项目：实例打印元组中的第二个项目：thistuple = (\"apple\", \"banana\", \"cherry\")print(thistuple[1])运行实例负索引负索引表示从末尾开始，-1 表示最后一个项目，-2 表示倒数第二个项目，依此类推。实例打印元组的最后一个项目：thistuple = (\"apple\", \"banana\", \"cherry\")print(thistuple[-1])运行实例索引范围您可以通过指定范围的起点和终点来指定索引范围。指定范围后，返回值将是带有指定项目的新元组。实例返回第三、第四、第五个项目：thistuple = (\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")print(thistuple[2:5])运行实例注释：搜索将从索引 2（包括）开始，到索引 5（不包括）结束。请记住，第一项的索引为 0。负索引范围如果要从元组的末尾开始搜索，请指定负索引：实例此例将返回从索引 -4（包括）到索引 -1（排除）的项目：thistuple = (\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")print(thistuple[-4:-1])运行实例更改元组值创建元组后，您将无法更改其值。元组是不可变的，或者也称为恒定的。但是有一种解决方法。您可以将元组转换为列表，更改列表，然后将列表转换回元组。实例把元组转换为列表即可进行更改：x = (\"apple\", \"banana\", \"cherry\")y = list(x)y[1] = \"kiwi\"x = tuple(y)print(x)运行实例遍历元组您可以使用 for 循环遍历元组项目。实例遍历项目并打印值：thistuple = (\"apple\", \"banana\", \"cherry\")for x in thistuple: print(x)运行实例您将在 Python For 循环 这一章中学习有关 for 循环的更多知识。检查项目是否存在要确定元组中是否存在指定的项，请使用 in 关键字：实例检查元组中是否存在 \"apple\"：thistuple = (\"apple\", \"banana\", \"cherry\")if \"apple\" in thistuple: print(\"Yes, 'apple' is in the fruits tuple\")运行实例元组长度要确定元组有多少项，请使用 len() 方法：实例打印元组中的项目数量：thistuple = (\"apple\", \"banana\", \"cherry\")print(len(thistuple))运行实例添加项目元组一旦创建，您就无法向其添加项目。元组是不可改变的。实例您无法向元组添加项目：thistuple = (\"apple\", \"banana\", \"cherry\")thistuple[3] = \"orange\" # 会引发错误print(thistuple)运行实例创建有一个项目的元组如需创建仅包含一个项目的元组，您必须在该项目后添加一个逗号，否则 Python 无法将变量识别为元组。实例单项元组，别忘了逗号：thistuple = (\"apple\",)print(type(thistuple))#不是元组thistuple = (\"apple\")print(type(thistuple))运行实例删除项目注释：您无法删除元组中的项目。元组是不可更改的，因此您无法从中删除项目，但您可以完全删除元组：实例del 关键字可以完全删除元组：thistuple = (\"apple\", \"banana\", \"cherry\")del thistupleprint(thistuple) # 这会引发错误，因为元组已不存在。运行实例合并两个元组如需连接两个或多个元组，您可以使用 + 运算符：实例合并这个元组：tuple1 = (\"a\", \"b\" , \"c\")tuple2 = (1, 2, 3)tuple3 = tuple1 + tuple2print(tuple3)运行实例tuple() 构造函数也可以使用 tuple() 构造函数来创建元组。实例使用 tuple() 方法来创建元组：thistuple = tuple((\"apple\", \"banana\", \"cherry\")) # 请注意双括号print(thistuple)运行实例元组方法Python 提供两个可以在元组上使用的内建方法。方法 描述count() 返回元组中指定值出现的次数index() 在元组中搜索指定的值并返回找到它的位置Python 集合集合（Set）集合是无序和无索引的集合。在 Python 中，集合用花括号编写。实例创建集合：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;print(thisset)运行实例注释：集合是无序的，因此您无法确定项目的显示顺序。访问项目您无法通过引用索引来访问 set 中的项目，因为 set 是无序的，项目没有索引。但是您可以使用 for 循环遍历 set 项目，或者使用 in 关键字查询集合中是否存在指定值。实例遍历集合，并打印值：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;for x in thisset: print(x)运行实例实例检查 set 中是否存在 “banana”：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;print(\"banana\" in thisset)运行实例更改项目集合一旦创建，您就无法更改项目，但是您可以添加新项目。添加项目要将一个项添加到集合，请使用 add() 方法。要向集合中添加多个项目，请使用 update() 方法。实例使用 add() 方法向 set 添加项目：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;thisset.add(\"orange\")print(thisset)运行实例实例使用 update() 方法将多个项添加到集合中：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;thisset.update([\"orange\", \"mango\", \"grapes\"])print(thisset)运行实例获取 Set 的长度要确定集合中有多少项，请使用 len() 方法。实例获取集合中的项目数：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;print(len(thisset))运行实例删除项目要删除集合中的项目，请使用 remove() 或 discard() 方法。实例使用 remove() 方法来删除 “banana”：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;thisset.remove(\"banana\")print(thisset)运行实例注释：如果要删除的项目不存在，则 remove() 将引发错误。实例使用 discard() 方法来删除 “banana”：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;thisset.discard(\"banana\")print(thisset)运行实例注释：如果要删除的项目不存在，则 discard() 将引发错误。您还可以使用 pop() 方法删除项目，但此方法将删除最后一项。请记住，set 是无序的，因此您不会知道被删除的是什么项目。pop() 方法的返回值是被删除的项目。实例使用 pop() 方法删除最后一项：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;x = thisset.pop()print(x)print(thisset)运行实例注释：集合是无序的，因此在使用 pop() 方法时，您不会知道删除的是哪个项目。实例clear() 方法清空集合：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;thisset.clear()print(thisset)运行实例实例del 彻底删除集合：thisset = &#123;\"apple\", \"banana\", \"cherry\"&#125;del thissetprint(thisset)运行实例合并两个集合在 Python 中，有几种方法可以连接两个或多个集合。您可以使用 union() 方法返回包含两个集合中所有项目的新集合，也可以使用 update() 方法将一个集合中的所有项目插入另一个集合中：实例union() 方法返回一个新集合，其中包含两个集合中的所有项目：set1 = &#123;\"a\", \"b\" , \"c\"&#125;set2 = &#123;1, 2, 3&#125;set3 = set1.union(set2)print(set3)运行实例实例update() 方法将 set2 中的项目插入 set1 中：set1 = &#123;\"a\", \"b\" , \"c\"&#125;set2 = &#123;1, 2, 3&#125;set1.update(set2)print(set1)运行实例注释：union() 和 update() 都将排除任何重复项。还有其他方法将两个集合连接起来，并且仅保留重复项，或者永远不保留重复项，请查看此页面底部的集合方法完整列表。set() 构造函数也可以使用 set() 构造函数来创建集合。实例使用 set() 构造函数来创建集合：thisset = set((\"apple\", \"banana\", \"cherry\")) # 请留意这个双括号print(thisset)运行实例Set 方法Python 拥有一套能够在集合（set）上使用的内建方法。方法 描述add() 向集合添加元素。clear() 删除集合中的所有元素。copy() 返回集合的副本。difference() 返回包含两个或更多集合之间差异的集合。difference_update() 删除此集合中也包含在另一个指定集合中的项目。discard() 删除指定项目。intersection() 返回为两个其他集合的交集的集合。intersection_update() 删除此集合中不存在于其他指定集合中的项目。isdisjoint() 返回两个集合是否有交集。issubset() 返回另一个集合是否包含此集合。issuperset() 返回此集合是否包含另一个集合。pop() 从集合中删除一个元素。remove() 删除指定元素。symmetric_difference() 返回具有两组集合的对称差集的集合。symmetric_difference_update() 插入此集合和另一个集合的对称差集。union() 返回包含集合并集的集合。update() 用此集合和其他集合的并集来更新集合。Python 字典字典（Dictionary）字典是一个无序、可变和有索引的集合。在 Python 中，字典用花括号编写，拥有键和值。实例创建并打印字典：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;print(thisdict)运行实例访问项目您可以通过在方括号内引用其键名来访问字典的项目：实例获取 \"model\" 键的值：x = thisdict[\"model\"]运行实例还有一个名为 get() 的方法会给你相同的结果：实例获取 \"model\" 键的值：x = thisdict.get(\"model\")运行实例更改值您可以通过引用其键名来更改特定项的值：实例把 \"year\" 改为 2018：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;thisdict[\"year\"] = 2019运行实例遍历字典您可以使用 for 循环遍历字典。循环遍历字典时，返回值是字典的键，但也有返回值的方法。实例逐个打印字典中的所有键名：for x in thisdict: print(x)运行实例实例逐个打印字典中的所有值：for x in thisdict: print(thisdict[x])运行实例实例您还可以使用 values() 函数返回字典的值：for x in thisdict.values(): print(x)运行实例实例通过使用 items() 函数遍历键和值：for x, y in thisdict.items(): print(x, y)运行实例检查键是否存在要确定字典中是否存在指定的键，请使用 in 关键字：实例检查字典中是否存在 \"model\"：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;if \"model\" in thisdict: print(\"Yes, 'model' is one of the keys in the thisdict dictionary\")运行实例字典长度要确定字典有多少项目（键值对），请使用 len() 方法。实例打印字典中的项目数：print(len(thisdict))运行实例添加项目通过使用新的索引键并为其赋值，可以将项目添加到字典中：实例thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;thisdict[\"color\"] = \"red\"print(thisdict)运行实例删除项目有几种方法可以从字典中删除项目：实例pop() 方法删除具有指定键名的项：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;thisdict.pop(\"model\")print(thisdict)运行实例实例popitem() 方法删除最后插入的项目（在 3.7 之前的版本中，删除随机项目）：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;thisdict.popitem()print(thisdict)运行实例实例del 关键字删除具有指定键名的项目：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;del thisdict[\"model\"]print(thisdict)运行实例实例del 关键字也可以完全删除字典：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;del thisdictprint(thisdict) #this 会导致错误，因为 \"thisdict\" 不再存在。运行实例实例clear() 关键字清空字典：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;thisdict.clear()print(thisdict)运行实例复制字典您不能通过键入 dict2 = dict1 来复制字典，因为：dict2 只是对 dict1 的引用，而 dict1 中的更改也将自动在 dict2 中进行。有一些方法可以进行复制，一种方法是使用内建的字典方法 copy()。实例使用 copy() 方法来复制字典：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;mydict = thisdict.copy()print(mydict)运行实例制作副本的另一种方法是使用内建方法 dict()。实例使用 dict() 方法创建字典的副本：thisdict = &#123; \"brand\": \"Porsche\", \"model\": \"911\", \"year\": 1963&#125;mydict = dict(thisdict)print(mydict)运行实例嵌套字典词典也可以包含许多词典，这被称为嵌套词典。实例创建包含三个字典的字典：myfamily = &#123; \"child1\" : &#123; \"name\" : \"Phoebe Adele\", \"year\" : 2002 &#125;, \"child2\" : &#123; \"name\" : \"Jennifer Katharine\", \"year\" : 1996 &#125;, \"child3\" : &#123; \"name\" : \"Rory John\", \"year\" : 1999 &#125;&#125;运行实例或者，如果您想嵌套三个已经作为字典存在的字典：实例创建三个字典，然后创建一个包含其他三个字典的字典：child1 = &#123; \"name\" : \"Phoebe Adele\", \"year\" : 2002&#125;child2 = &#123; \"name\" : \"Jennifer Katharine\", \"year\" : 1996&#125;child3 = &#123; \"name\" : \"Rory John\", \"year\" : 1999&#125;myfamily = &#123; \"child1\" : child1, \"child2\" : child2, \"child3\" : child3&#125;运行实例dict() 构造函数也可以使用 dict() 构造函数创建新的字典：实例thisdict = dict(brand=\"Porsche\", model=\"911\", year=1963)# 请注意，关键字不是字符串字面量# 请注意，使用了等号而不是冒号来赋值print(thisdict)运行实例字典方法Python 提供一组可以在字典上使用的内建方法。方法 描述clear() 删除字典中的所有元素copy() 返回字典的副本fromkeys() 返回拥有指定键和值的字典get() 返回指定键的值items() 返回包含每个键值对的元组的列表keys() 返回包含字典键的列表pop() 删除拥有指定键的元素popitem() 删除最后插入的键值对setdefault() 返回指定键的值。如果该键不存在，则插入具有指定值的键。update() 使用指定的键值对字典进行更新values() 返回字典中所有值的列表","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"python 语法  day 05-2","slug":"study python 5day-1","date":"2019-12-23T12:00:00.000Z","updated":"2020-01-13T13:12:56.723Z","comments":true,"path":"2019/12/23/study python 5day-1/","link":"","permalink":"https://yanxigun99.github.io/2019/12/23/study%20python%205day-1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641Python介绍什么是Python？Python 是一门流行的编程语言。它由 Guido van Rossum 创建，于 1991 年发布。它用于：Web 开发（服务器端）软件开发数学系统脚本Python可以做什么？ 可以在服务器上使用 Python 来创建 Web 应用程序。Python 可以与软件一起使用来创建工作流。Python 可以连接到数据库系统。它还可以读取和修改文件。Python 可用于处理大数据并执行复杂的数学运算。Python 可用于快速原型设计，也可用于生产就绪的软件开发。为何选择Python？ Python 适用于不同的平台（Windows、Mac、Linux、Raspberry Pi 等）。Python 有一种类似于英语的简单语法。Python 的语法允许开发人员用比其他编程语言更少的代码行编写程序。Python 在解释器系统上运行，这意味着代码可以在编写后立即执行。这也意味着原型设计可以非常快。Python 可以以程序方式、面向对象的方式或功能方式来处理。Python 语法与其他编程语言比较 Python 是为可读性设计的，与英语有一些相似之处，并受到数学的影响。Python 使用新行来完成命令，而不像通常使用分号或括号的其他编程语言。Python 依赖缩进，使用空格来定义范围；例如循环、函数和类的范围。其他编程语言通常使用花括号来实现此目的。Python 语法规则 Python 缩进缩进指的是代码行开头的空格。在其他编程语言中，代码缩进仅出于可读性的考虑，而 Python 中的缩进非常重要。Python 使用缩进来指示代码块。for i in range(4): print(i)1.如果省略缩进，Python 会出错2.空格数取决于程序员，但至少需要一个3.您必须在同一代码块中使用相同数量的空格，否则 Python 会出错Python 变量 在 Python 中，变量是在为其赋值时创建的y=1x=1.0s=str()a=[]t=&#123;&#125;Python 没有声明变量的命令。注释Python 拥有对文档内代码进行注释的功能。注释以 ＃ 开头，Python 将其余部分作为注释呈现#this is a python'''onetwo three'''print(\"this is a python\") Python 注释注释可用于解释 Python 代码。注释可用于提高代码的可读性。在测试代码时，可以使用注释来阻止执行。 创建注释注释以 ＃ 开头，Python 将忽略它们#this is a pythonprint('this is a python')注释可以放在一行的末尾，Python 将忽略该行的其余部分print(\"this is a python\")#打印this is a python注释不必是解释代码的文本，它也可以用来阻止 Python 执行代码 #print(\"this is a python\")print(\"there are pythons\") 多行注释Python 实际上没有多行注释的语法。要添加多行注释，您可以为每行插入一个 ＃# one#two#threeprint(\"this is one\")或者，以不完全符合预期的方式，您可以使用多行字符串。由于 Python 将忽略未分配给变量的字符串文字，因此您可以在代码中添加多行字符串（三引号），并在其中添加注释'''onetwothree'''print(\"this is a python\") 只要字符串未分配给变量，Python 就会读取代码，然后忽略它，这样您就已经完成了多行注释Python 变量创建变量变量是存放数据值的容器。与其他编程语言不同，Python 没有声明变量的命令。首次为其赋值时，才会创建变量。x=10y='bin'print(x)print(y) 变量不需要使用任何特定类型声明，甚至可以在设置后更改其类型x=10#x为intx=\"python\"#想为字符型print(x) 字符串变量可以使用单引号或双引号进行声明x='python'y=\"python\"print(x)print(y)变量名称变量可以使用短名称（如 x 和 y）或更具描述性的名称（age、carname、total_volume）。Python 变量命名规则：变量名必须以字母或下划线字符开头变量名称不能以数字开头变量名只能包含字母数字字符和下划线（A-z、0-9 和 _）变量名称区分大小写（age、Age 和 AGE 是三个不同的变量）请记住，变量名称区分大小写向多个变量赋值Python 允许您在一行中为多个变量赋值x,y,z=1,2,3print(x)print(y)print(z) 您可以在一行中为多个变量分配相同的值x=y=z=1print(x)print(y)print(z)输出变量Python 的 print 语句通常用于输出变量。如需结合文本和变量，Python 使用 + 字符x=\"one\"print(\"this is \"+x)您还可以使用 + 字符将变量与另一个变量相加x=\"one\"y=\"two\"z=x+yprint(z) 对于数字，+ 字符用作数学运算符x=10y=15print(x+y)如果您尝试组合字符串和数字，Python 会给出错误x=1991y=\"python\"print(x+y) 全局变量在函数外部创建的变量（如上述所有实例所示）称为全局变量。全局变量可以被函数内部和外部的每个人使用。x=10def print_x(s) print(s)print(print_x(x))如果在函数内部创建具有相同名称的变量，则该变量将是局部变量，并且只能在函数内部使用。具有相同名称的全局变量将保留原样，并拥有原始值。x = \"awesome\"def myfunc(): x = \"fantastic\" print(\"Python is \" + x)myfunc()print(\"Python is \" + x)'''Python is fantasticPython is awesome'''global 关键字通常，在函数内部创建变量时，该变量是局部变量，只能在该函数内部使用。要在函数内部创建全局变量，您可以使用 global 关键字def myfunc(): global x x = \"fantastic\"myfunc()print(\"Python is \" + x)另外，如果要在函数内部更改全局变量，请使用 global 关键字。x = \"awesome\"def myfunc(): global x x = \"fantastic\"myfunc()print(\"Python is \" + x)#Python is fantasticPython 数据类型内置数据类型在编程中，数据类型是一个重要的概念。变量可以存储不同类型的数据，并且不同类型可以执行不同的操作。在这些类别中，Python 默认拥有以下内置数据类型：文本类型： str数值类型： int, float, complex序列类型： list, tuple, range映射类型： dict集合类型： set, frozenset布尔类型： bool二进制类型： bytes, bytearray, memoryview获取数据类型您可以使用 type() 函数获取任何对象的数据类型x=10print(type(x))设置数据类型在 Python 中，当您为变量赋值时，会设置数据类型 示例 数据类型 试一试x = \"Hello World\" str 试一试x = 29 int 试一试x = 29.5 float 试一试x = 1j complex 试一试x = [\"apple\", \"banana\", \"cherry\"] list 试一试x = (\"apple\", \"banana\", \"cherry\") tuple 试一试x = range(6) range 试一试x = &#123;\"name\" : \"Bill\", \"age\" : 63&#125; dict 试一试x = &#123;\"apple\", \"banana\", \"cherry\"&#125; set 试一试x = frozenset(&#123;\"apple\", \"banana\", \"cherry\"&#125;) frozenset 试一试x = True bool 试一试x = b\"Hello\" bytes 试一试x = bytearray(5) bytearray 试一试x = memoryview(bytes(5)) memoryview 试一试设定特定的数据类型如果希望指定数据类型，则您可以使用以下构造函数示例 数据类型 试一试x = str(\"Hello World\") str 试一试x = int(29) int 试一试x = float(29.5) float 试一试x = complex(1j) complex 试一试x = list((\"apple\", \"banana\", \"cherry\")) list 试一试x = tuple((\"apple\", \"banana\", \"cherry\")) tuple 试一试x = range(6) range 试一试x = dict(name=\"Bill\", age=36) dict 试一试x = set((\"apple\", \"banana\", \"cherry\")) set 试一试x = frozenset((\"apple\", \"banana\", \"cherry\")) frozenset 试一试x = bool(5) bool 试一试x = bytes(5) bytes 试一试x = bytearray(5) bytearray 试一试x = memoryview(bytes(5)) memoryview 试一试Python 数字Python 中有三种数字类型：intfloatcomplex为变量赋值时，将创建数值类型的变量x=1 #intx=1.0 #floatx=2j #complex如需验证 Python 中任何对象的类型，请使用 type() 函数x=1print(type(x))IntInt 或整数是完整的数字，正数或负数，没有小数，长度不限x = 10y = 37216654545182186317z = -465167846print(type(x))print(type(y))print(type(z))Float浮动或“浮点数”是包含小数的正数或负数x = 3.50y = 2.0z = -63.78print(type(x))print(type(y))print(type(z))浮点数也可以是带有“e”的科学数字，表示 10 的幂 x = 27e4y = 15E2z = -49.8e100print(type(x))print(type(y))print(type(z))复数复数用 \"j\" 作为虚部编写x = 2+3jy = 7jz = -7jprint(type(x))print(type(y))print(type(z))类型转换您可以使用 int()、float() 和 complex() 方法从一种类型转换为另一种类型注释：您无法将复数转换为其他数字类型x = 10 # inty = 6.3 # floatz = 1j # complex# 把整数转换为浮点数a = float(x)# 把浮点数转换为整数b = int(y)# 把整数转换为复数：c = complex(x)print(a)print(b)print(c)print(type(a))print(type(b))print(type(c))随机数Python 没有 random() 函数来创建随机数，但 Python 有一个名为 random 的内置模块，可用于生成随机数导入 random 模块，并显示 1 到 9 之间的随机数import randomprint(random.randrange(1,10)) Python Casting有时您可能需要为变量指定类型。这可以通过 casting 来完成。 Python 是一门面向对象的语言，因此它使用类来定义数据类型，包括其原始类型。因此，使用构造函数完成在 python 中的转换：int() - 用整数字面量、浮点字面量构造整数（通过对数进行下舍入），或者用表示完整数字的字符串字面量float() - 用整数字面量、浮点字面量，或字符串字面量构造浮点数（提供表示浮点数或整数的字符串）str() - 用各种数据类型构造字符串，包括字符串，整数字面量和浮点字面量x = int(1) # x 将是 1y = int(2.5) # y 将是 2z = int(\"3\") # z 将是 3x = float(1) # x 将是 1.0y = float(2.5) # y 将是 2.5z = float(\"3\") # z 将是 3.0w = float(\"4.6\") # w 将是 4.6x = str(\"S2\") # x 将是 'S2'y = str(3) # y 将是 '2'z = str(4.0) # z 将是 '4.0'Python 字符串字符串字面量python 中的字符串字面量由单引号或双引号括起。'hello' 等同于 \"hello\"。您可以使用 print() 函数显示字符串字面量：x='pyhton'y=\"python\"print(x)print(y)用字符串向变量赋值通过使用变量名称后跟等号和字符串，可以把字符串赋值给变量a=\"python\"print(a)多行字符串您可以使用三个引号将多行字符串赋值给变量：a = \"\"\"Python is a widely used general-purpose, high level programming language. It was initially designed by Guido van Rossum in 1991 and developed by Python Software Foundation. It was mainly developed for emphasis on code readability, and its syntax allows programmers to express concepts in fewer lines of code.\"\"\"print(a)或三个单引号：a = '''Python is a widely used general-purpose, high level programming language. It was initially designed by Guido van Rossum in 1991 and developed by Python Software Foundation. It was mainly developed for emphasis on code readability, and its syntax allows programmers to express concepts in fewer lines of code.'''print(a)字符串是数组像许多其他流行的编程语言一样，Python 中的字符串是表示 unicode 字符的字节数组。但是，Python 没有字符数据类型，单个字符就是长度为 1 的字符串。方括号可用于访问字符串的元素。a = \"Hello, World!\"print(a[1])裁切您可以使用裁切语法返回一定范围的字符。指定开始索引和结束索引，以冒号分隔，以返回字符串的一部分。b = \"Hello, World!\"print(b[2:5])负的索引使用负索引从字符串末尾开始切片：b = \"Hello, World!\"print(b[-5:-2])字符串长度如需获取字符串的长度，请使用 len() 函数a=\"this is a python\"print(len(a))字符串方法Python 有一组可用于字符串的内置方法。实例lower() 返回小写的字符串：upper() 方法返回大写的字符串：replace() 用另一段字符串来替换字符串：split() 方法在找到分隔符的实例时将字符串拆分为子字符串strip() 方法删除开头或结尾的空白字符：a = \" Hello, World! \"print(a.strip()) # returns \"Hello, World!\"检查字符串如需检查字符串中是否存在特定短语或字符，我们可以使用 in 或 not in 关键字。txt = \"China is a great country\"x = \"ina\" in txtprint(x)字符串级联（串联）如需串联或组合两个字符串，您可以使用 + 运算符。a = \"Hello\"b = \"World\"c = a + bprint(c)字符串格式正如在 Python 变量一章中所学到的，我们不能像这样组合字符串和数字age = 63txt = \"My name is Bill, I am \" + ageprint(txt)但是我们可以使用 format() 方法组合字符串和数字！format() 方法接受传递的参数，格式化它们，并将它们放在占位符 &#123;&#125; 所在的字符串中age = 63txt = \"My name is Bill, and I am &#123;&#125;\"print(txt.format(age))format() 方法接受不限数量的参数，并放在各自的占位符中quantity = 3itemno = 567price = 49.95myorder = \"I want &#123;&#125; pieces of item &#123;&#125; for &#123;&#125; dollars.\"print(myorder.format(quantity, itemno, price))您可以使用索引号 &#123;0&#125; 来确保参数被放在正确的占位符中quantity = 3itemno = 567price = 49.95myorder = \"I want to pay &#123;2&#125; dollars for &#123;0&#125; pieces of item &#123;1&#125;.\"print(myorder.format(quantity, itemno, price))Python 布尔布尔值在编程中，您通常需要知道表达式是 True 还是 False。您可以计算 Python 中的任何表达式，并获得两个答案之一，即 True 或 False。比较两个值时，将对表达式求值，Python 返回布尔值答案print(8 &gt; 7)print(8 == 7)print(8 &gt; 7)当在 if 语句中运行条件时，Python 返回 True 或 Falsea = 200b = 33if b &gt; a: print(\"b is greater than a\")else: print(\"b is not greater than a\")bool() 函数可让您评估任何值，并为您返回 True 或 Falseprint(bool(\"Hello\"))print(bool(10))大多数值都为 True如果有某种内容，则几乎所有值都将评估为 True。除空字符串外，任何字符串均为 True。除 0 外，任何数字均为 True。除空列表外，任何列表、元组、集合和字典均为 True某些值为 False实际上，除空值（例如 ()、[]、&#123;&#125;、\"\"、数字 0 和值 None）外，没有多少值会被评估为 False。当然，值 False 的计算结果为 False。class myclass(): def __len__(self): return 0myobj = myclass()print(bool(myobj))函数可返回布尔Python 还有很多返回布尔值的内置函数，例如 isinstance() 函数，该函数可用于确定对象是否具有某种数据类型x = 200print(isinstance(x, int))Python 运算符运算符用于对变量和值执行操作。Python 在以下组中划分运算符：算术运算符赋值运算符比较运算符逻辑运算符身份运算符成员运算符位运算符Python 算术运算符 算术运算符与数值一起使用来执行常见的数学运算运算符 名称 实例 试一试+ 加 x + y 试一试- 减 x - y 试一试* 乘 x * y 试一试/ 除 x / y 试一试% 取模 x % y 试一试** 幂 x ** y 试一试// 地板除（取整除） x // y 试一试Python 赋值运算符赋值运算符用于为变量赋值运算符 实例 等同于 试一试= x = 5 x = 5 试一试+= x += 3 x = x + 3 试一试-= x -= 3 x = x - 3 试一试*= x *= 3 x = x * 3 试一试/= x /= 3 x = x / 3 试一试%= x %= 3 x = x % 3 试一试//= x //= 3 x = x // 3 试一试**= x **= 3 x = x ** 3 试一试&amp;= x &amp;= 3 x = x &amp; 3 试一试|= x |= 3 x = x | 3 试一试^= x ^= 3 x = x ^ 3 试一试&gt;&gt;= x &gt;&gt;= 3 x = x &gt;&gt; 3 试一试&lt;&lt;= x &lt;&lt;= 3 x = x &lt;&lt; 3 试一试Python 比较运算符比较运算符用于比较两个值 比较运算符用于比较两个值：运算符 名称 实例 试一试== 等于 x == y 试一试!= 不等于 x != y 试一试&gt; 大于 x &gt; y 试一试&lt; 小于 x &lt; y 试一试&gt;= 大于或等于 x &gt;= y 试一试&lt;= 小于或等于 x &lt;= y 试一试Python 逻辑运算符逻辑运算符用于组合条件语句：运算符 描述 实例 试一试and 如果两个语句都为真，则返回 True。 x &gt; 3 and x &lt; 10 试一试or 如果其中一个语句为真，则返回 True。 x &gt; 3 or x &lt; 4 试一试not 反转结果，如果结果为 true，则返回 False not(x &gt; 3 and x &lt; 10) 试一试Python 身份运算符身份运算符用于比较对象，不是比较它们是否相等，但如果它们实际上是同一个对象，则具有相同的内存位置：运算符 描述 实例 试一试is 如果两个变量是同一个对象，则返回 true。 x is y 试一试is not 如果两个变量不是同一个对象，则返回 true。 x is not y 试一试Python 成员运算符成员资格运算符用于测试序列是否在对象中出运算符 描述 实例 试一试in 如果对象中存在具有指定值的序列，则返回 True。 x in y 试一试not in 如果对象中不存在具有指定值的序列，则返回 True。 x not in y 试一试Python 位运算符位运算符用于比较（二进制）数字：运算符 描述 实例&amp; AND 如果两个位均为 1，则将每个位设为 1。| OR 如果两位中的一位为 1，则将每个位设为 1。^ XOR 如果两个位中只有一位为 1，则将每个位设为 1。~ NOT 反转所有位。&lt;&lt; Zero fill left shift 通过从右侧推入零来向左移动，推掉最左边的位。&gt;&gt; Signed right shift 通过从左侧推入最左边的位的副本向右移动，推掉最右边的位。","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanxigun99.github.io/tags/python/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"Write code every day 04","slug":"study python 4day","date":"2019-12-22T12:00:00.000Z","updated":"2020-01-13T13:09:04.368Z","comments":true,"path":"2019/12/22/study python 4day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/22/study%20python%204day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。所有的IP地址划分为 A,B,C,D,E五类A类地址1.0.0.0~126.255.255.255;B类地址128.0.0.0~191.255.255.255;C类地址192.0.0.0~223.255.255.255;D类地址224.0.0.0~239.255.255.255；E类地址240.0.0.0~255.255.255.255私网IP范围是：10.0.0.0～10.255.255.255172.16.0.0～172.31.255.255192.168.0.0～192.168.255.255子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）#建函数判断ip是否正确def check_ip(s): for i in s: if i not in range(256):#IP的每一个子段都小于256 return False return True#建函数判断掩码是否正确 def check_mask(s): if s in ([255, 255, 255, 255], [0, 0, 0, 0]):#两个特殊错误掩码 return False v = '' for j in s[::-1]: for i in range(8): v += str(j&gt;&gt;i&amp;1)#如果符合前面都为1，后面都为0的正确掩码，就不会出现'10'的子序列 if '10' in v: return False return True res = [0,0,0,0,0,0,0]#把输出的所有项先全部制0while True:#防止多行读取 try: s = input().split('~')#提取IP和掩码 if len(s) != 2:#如果不是IP和掩码的输入组合，则跳出循环 break except: break try: ip = [int(x) for x in s[0].split('.')]#将IP和掩码按'.'分割成整型列表 mask = [int(x) for x in s[1].split('.')] except: res[5] += 1#分割时发现不是数字字符则错误地址和掩码个数加1 continue if check_ip(ip) and check_mask(mask):#按前面规定的函数判断IP和掩码格式正确则进行if判断 i,a = ip[0],ip[1]#取IP的前两个子段 if i in range(1,127):#A类地址判断 res[0] += 1 if i in range(128,192):#B类地址判断 res[1] += 1 if i in range(192,224):#C类地址判断 res[2] += 1 if i in range(224,240):#D类地址判断 res[3] += 1 if i in range(240,256):#E类地址判断 res[4] += 1 if i==10 or (i==172 and (a in range(16,32)) or (i==192 and a==168)):#判断私有IP res[6] += 1 else: res[5] += 1 #不符合上面6类，则属于非法的IP和掩码print (' '.join(str(x) for x in res))#插入空格打印7类的个数值开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。处理： 1、 记录最多8条错误记录，循环记录，对相同的错误记录（净文件名称和行号完全匹配）只记录一条，错误计数增加；2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；3、 输入的文件可能带路径，记录文件名称不能带路径。error = dict() #新建一个字典，用于记录错误filelist = [] #新建一个空列表，存放文件名while True: #重复读取控制台输入 try: record = ' '.join(''.join(input().split('\\\\')[-1]).split()) filename = record.split() if len(filename[0]) &gt;= 16: filename[0] = filename[0][-16:] record = ' '.join(filename) if record not in error.keys(): error[record] = 1 filelist.append(record) else: error[record] += 1 except: breakkey = filelist[-8:]for each in key: print(' '.join(each.split()),error[each])密码要求:1.长度超过8位2.包括大小写字母.数字.其它符号,以上四种至少三种3.不能有相同长度超2的子串重复说明:长度超过2的子串import sys #导入两个内置类import re for line in sys.stdin: #重复读取 line = line.strip() #1条件判断 if len(line) &lt;= 8: print(\"NG\") continue #2条件判断 count = 0 if re.search('[0-9]',line): count += 1 if re.search('[a-z]',line): count += 1 if re.search('[A-Z]',line): count += 1 if re.search('[^a-zA-Z0-9]',line): count += 1 if count &lt; 3: print(\"NG\") continue #3:条件判断 if re.search(r'.*(...)(.*\\1)', line):#正则表达式判断子串概念 print(\"NG\") continue print(\"OK\")对字符串中的所有单词进行倒排。说明：1、每个单词是以26个大写或小写英文字母构成；2、非构成单词的字符均视为单词间隔符；3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；4、每个单词最长20个字母；import rewhile True: try: sentence_list = re.split('[^a-zA-Z]+', input().strip()) print(' '.join(sentence_list[::-1]).strip()) except: breakCatcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA-&gt;12ABBA,ABA-&gt;ABAKK,123321-&gt;51233214 。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？def longestPalindrome(s): if s==s[::-1]:return len(s) maxLen=0 for i in range(len(s)): if i-maxLen&gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]: maxLen+=2 continue if i-maxLen&gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]: maxLen+=1 return maxLenwhile True: try: a=input() if a: print(longestPalindrome(a)) except: break原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成一个长整数。举例：一个ip地址为10.0.3.193每段数字 相对应的二进制数10 000010100 000000003 00000011193 11000001组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。的每段可以看成是一个0-255的整数，需要对IP地址进行校验while True: try: # ip to int_address # 按 '.'拆开 =&gt; map =&gt; 每节转二进制，去'ob',填充'0' =&gt; 合并 =》 转十进制 print(int(''.join(map(lambda n:bin(int(n)).replace('0b','').rjust(8, '0'), input().split('.'))),2)) # int_address to bin adrBin = bin(int(input())).replace('0b','').rjust(32, '0') # bin to ip # 将32位二进制地址每八个拆开 =&gt; map =&gt; 每节转十进制 =》 合并 print('.'.join(map(lambda n:str(int(n,2)),[adrBin[i*8:(i+1)*8] for i in range(4)]))) except:breakLily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过C语言解决。while True: try: print(\"\".join(sorted(input()))) except:break题目说明蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。样例输入5样例输出1 3 6 10 152 5 9 144 8 137 1211while True: try: n, curNum = int(input()), 1 res = [[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(i + 1): res[i - j][j] = curNum curNum += 1 for i in res: print(\" \".join(map(str, (filter(lambda i: i != 0, i))))) except: break有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词属于字母表的下面，如下所示：A B C D E F G H I J K L M N O P Q R S T U V W X Y ZT R A I L B Z E S C D F G H J K M N O P Q U V W X Y上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。请实现下述接口，通过指定的密匙和明文得到密文。while True: try: #key，string分别代表输入的key的加要密的字符串 #chars是密钥对应的字母表，res是要返回的结果。 key, string, chars, res = input(), input(), [], \"\" #经过下面的循环，chars前面几个是密匙的字母 for i in key: if i not in chars: chars.append(i) #如果输入的key中有小写字母，转为大写字母。 chars = list(map(lambda c: c.upper(), chars)) #剩下的字母，填充到chars里面。 for i in range(65, 91): if chr(i) not in chars: chars.append(chr(i)) # 将输入加密。 for i in string: if i.isupper(): res += chars[ord(i) - 65] elif i.islower(): res += chars[ord(i) - 97].lower() else: res += i print(res) except: break有一只兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子，假如兔子都不死，问每个月的兔子总数为多少？while True: try: a=int(input())-1 arr=[1,2] while len(arr)&lt;a: arr.append(arr[-1]+arr[-2]) print(arr[-1]) except: break假设一个球从任意高度自由落下，每次落地后反跳回原高度的一半; 再落下, 求它在第5次落地时，共经历多少米?第5次反弹多高？ import sys while True: try: string = sys.stdin.readline() number = int(string) print 2.875 * number print 0.03125 * number except: break#按比例缩放就好了。输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。链接：https://www.nowcoder.com/questionTerminal/539054b4c33b4776bc350155f7abd8f5?while True: try: a=input() char,space,number,other=0,0,0,0 for i in a: if i==\" \":space+=1 elif i.isnumeric(): number+=1 elif i.isalpha():char+=1 else:other+=1 print(char) print(space) print(number) print(other) except: break现有一组砝码，重量互不相等，分别为m1,m2,m3…mn；每种砝码对应的数量为x1,x2,x3...xn。现在要用这些砝码去称物体的重量(放在同一侧)，问能称出多少种不同的重量。while True: try: num=int(input()) w=list(map(int,input().split())) number=list(map(int,input().split())) prev=[0] for i in range(num): res=[] for j in range(number[i]+1): for item in prev: res.append(item+j*w[i]) res=set(res) prev=list(res) print(len(res)) except: breakJessi初学英语，为了快速读出一串数字，编写程序将数字转换成英文：如22：twenty two，123：one hundred and twenty three。def numberToWords(num): to19='one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen seventeen eighteen nineteen'.split() tens=\"twenty thirty forty fifty sixty seventy eighty ninety\".split() def words(n): if n&lt;20:return to19[n-1:n] if n&lt;100:return [tens[n//10-2]]+words(n%10) if n&lt;1000: return [to19[n//100-1]]+[\"hundred\"]+[\"and\"]+words(n%100) for p,w in enumerate(('thousand',\"million\",\"billion\"),1): if n&lt;1000**(p+1): return words(n//1000**p)+[w]+words(n%1000**p) return \" \".join(words(num)) or \"Zero\"while True: try: print(numberToWords(int(input()))) except:break定义一个二维数组N*M（其中2&lt;=N&lt;=10;2&lt;=M&lt;=10），如5 × 5数组下所示： int maze[5][5] = &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;;它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为[0,0],既第一空格是可以走的路。Input一个N × M的二维数组，表示一个迷宫。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。Output左上角到右下角的最短路径，格式如样例所示。try: while True: row,col = map(int,input().split()) maze = [] for i in range(row): maze.append(list(map(lambda x:-x,map(int,input().split())))) queue = [[0,0]] maze[0][0] = 1 while queue: x,y = queue.pop(0) if x == row-1 and y == col-1: break if x+1 &lt; row and maze[x+1][y] == 0: maze[x+1][y] = maze[x][y]+1 queue.append([x+1,y]) if y+1 &lt; col and maze[x][y+1] == 0: maze[x][y+1] = maze[x][y]+1 queue.append([x,y+1]) if x-1 &gt;= 0 and maze[x-1][y] == 0: maze[x-1][y] = maze[x][y]+1 queue.append([x-1,y]) if y-1 &gt;= 0 and maze[x][y-1] == 0: maze[x][y-1] = maze[x][y]+1 queue.append([x,y-1]) result = [[row-1,col-1]] for i in range(maze[-1][-1]-1,0,-1): tempRow = result[0][0] tempCol = result[0][1] if tempRow-1&gt;=0 and maze[tempRow-1][tempCol] == i: result.insert(0,[tempRow-1,tempCol]) elif tempCol-1&gt;=0 and maze[tempRow][tempCol-1] == i: result.insert(0,[tempRow,tempCol-1]) elif tempRow+1&lt;row and maze[tempRow+1][tempCol] == i: result.insert(0,[tempRow+1,tempCol]) elif tempCol+1&lt;col and maze[tempRow][tempCol+1] == i: result.insert(0,[tempRow,tempCol+1]) for i in result: print('(%d,%d)'%(i[0],i[1]))except Exception: pass问题描述：数独（Sudoku）是一款大众喜爱的数字逻辑游戏。玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个粗线宫内的数字均含1-9，并且不重复。输入：包含已知数字的9X9盘面数组[空缺位以数字0表示]输出：完整的9X9盘面数组def solver(board, rows, cols, squs, i, j): if i&gt;=9: return True if board[i][j]!='0': return solver(board, rows, cols, squs, (i*9+j+1)//9, (i*9+j+1)%9) for n in &#123;'1','2','3','4','5','6','7','8','9'&#125;-(rows[i]|cols[j]|squs[i//3*3+j//3]): board[i][j] = n rows[i].add(n) cols[j].add(n) squs[i//3*3+j//3].add(n) if not solver(board, rows, cols, squs, (i*9+j+1)//9, (i*9+j+1)%9): board[i][j] = '0' rows[i].remove(n) cols[j].remove(n) squs[i//3*3+j//3].remove(n) else: return True return False while True: try: board = [] for i in range(9): board.append(input().split()) rows, cols, squs = [set() for i in range(9)], [set() for i in range(9)], [set() for i in range(9)] for i, row in enumerate(board): for j, num in enumerate(row): if num!='0': rows[i].add(num) cols[j].add(num) squs[i//3*3+j//3].add(num) solver(board, rows, cols, squs, 0, 0) for i in range(9): print(' '.join(board[i])) except: break给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。给出多个名字，计算每个名字最大可能的“漂亮度”。from collections import Counterwhile True: try: a=int(input()) for i in range(a): c,start,res=Counter(input()),26,0 for j in c.most_common(): res+=j[1]*start start-=1 print(res) except: break编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。但是要保证汉字不被截半个，如\"我ABC\"4，应该截为\"我AB\"，输入\"我ABC汉DEF\"6，应该输出为\"我ABC\"而不是\"我ABC+汉的半个\"。 while True: try: a,b=input().split() print(a[:int(b)]) except: break问题描述：有4个线程和1个公共的字符数组。线程1的功能就是向数组输出A，线程2的功能就是向字符输出B，线程3的功能就是向数组输出C，线程4的功能就是向数组输出D。要求按顺序向数组赋值ABCDABCDABCD，ABCD的个数由线程函数1的参数指定。while True: try: print(\"ABCD\"*int(input())) except: break请实现如下接口 /* 功能：四则运算 * 输入：strExpression：字符串格式的算术表达式，如: \"3+2*&#123;1+2*[-4/(8-6)+7]&#125;\" * 返回：算术表达式的计算结果 */print(eval(input()))while True: try: a,b,c=input(),input().split(),int(input()) print(b[-c] if c!=0 else 0) except: breakLevenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离的算法是首先由俄国科学家Levenshtein提出的，故又叫Levenshtein Distance。Ex：字符串A:abcdefg字符串B: abcdef通过增加或是删掉字符”g”的方式达到目的。这两种方案都需要一次操作。把这个操作所需要的次数定义为两个字符串的距离。要求：给定任意两个字符串，写出一个算法计算它们的编辑距离。# -*- coding: utf-8 -*-# !/usr/bin/python3# 解题思路：动态规划dp[i][j]表示st1[0:j - 1]和st2[0:i - 1]的最小距离；# 那么st1和st2的距离与dp[i][j], dp[i - 1][j]和dp[i][j - 1]有关；# 如果st1[j] == st2[i], dp[i + 1][j + 1] = dp[i - 1][j - 1];# 如果st1[j] != st2[i], dp[i + 1][j + 1] = min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1);# 边界条件：第0行和第0列表示空字符串分别于st1和st2的子字符串的距离，dp[i][0] = i, dp[0][j] = j while True: try: st1 = input() st2 = input() if len(st1) &lt; len(st2): st1, st2 = st2, st1 m = len(st1) n = len(st2) res = [[0 for i in range(m + 1)] for i in range(n + 1)] for i in range(n + 1): res[i][0] = i for j in range(m + 1): res[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if st1[j - 1] == st2[i - 1]: res[i][j] = res[i - 1][j - 1] else: res[i][j] = min(res[i - 1][j - 1] + 1, res[i - 1][j] + 1, res[i][j - 1] + 1) print(res[n][m]) except: break 1 1 1 1 1 2 3 2 1 1 3 6 7 6 3 11 4 10 16 19 16 10 4 1以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数，左上角数到右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3。输入n(n &lt;= 1000000000)import sys while True: try: string = sys.stdin.readline() line = int(string) if line == 1 or line == 2: print -1 elif line == 3: print 2 elif line%4==1 or line%4==3: print 2 elif line%4==2: print 4 else: print 3 except: break#找规律吧，小伙伴们~给定一个字符串描述的算术表达式，计算出结果值。输入字符串长度不超过100，合法的字符包括”+, -, *, /, (, )”，”0-9”，字符串内容的合法性及表达式语法的合法性由做题者检查。本题目只涉及整型计算。print(eval(input()))","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"Write code every day 03","slug":"study python 3day","date":"2019-12-21T12:00:00.000Z","updated":"2020-01-13T13:07:08.389Z","comments":true,"path":"2019/12/21/study python 3day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/21/study%20python%203day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683计算字符串最后一个单词的长度，单词以空格隔开。a=input().split()print(len(a[-1])if len(a)&gt;1 else len(a[0]))写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。a=input().lower()b=input().lower()print(a.count(b))明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。while True: try: a,sep=int(input()),set() for i in range(a):sep.add(int(input())) for r in sorted(sep):print(r) except: break •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。a=input()b=input()def print_item(s): if len(s)&lt;=8: print(s+'0'*(8-len(s))) else: while len(s)&gt;8: print(s[:8]) s=s[8:] print(s+'0'*(8-len(s)))print_item(a)print_item(b) 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）while True: try: print(int(input(),16)) except: break功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）最后一个数后面也要有空格a, res = int(input()), []for i in range(2, a // 2 + 1): while a % i == 0: a = a / i res.append(i)print(\" \".join(map(str, res)) + \" \" if res else str(a) + \" \")写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。print(round(float(input())+0.001)) 数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。from collections import defaultdictwhile True: try: a,dd=int(input()),defaultdict(int) for i in range(a): key,value=map(int,input().split()) dd[key]+=value for i in sorted(dd.keys()): print(str(i)+' '+str(dd[i])) except: break输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。result=\"\"s=str(input())for i in s[::-1]: if i not in result: result+=i print(result)编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。print(len(set([i for i in input() if ord(i)in range(128)])))输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001s=str(input())print(s[::-1])写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。print(str(input())[::-1])将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符print(\" \".join(input().split()[::-1])) 给定n个字符串，请对n个字符串按照字典序排列。n,s=int(input()),[]for i in range(n):s.append(input())for i in sorted(s):print(i) 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。print(bin(int(input())).count(\"1\")) 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。import sysdx = [-1, 0, 0, 1]dy = [0, -1, 1, 0]for line in sys.stdin: x, y = 0, 0 for cmd in line.split(';'): cmd = cmd.strip() if cmd and cmd[0] in 'ASWD': try: n = int(cmd[1:]) x += n * dx['ASWD'.find(cmd[0])] y += n * dy['ASWD'.find(cmd[0])] #print cmd, n, x, y except: pass print(\"%d,%d\"% (x, y))请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。所有的IP地址划分为 A,B,C,D,E五类A类地址1.0.0.0~126.255.255.255;B类地址128.0.0.0~191.255.255.255;C类地址192.0.0.0~223.255.255.255;D类地址224.0.0.0~239.255.255.255；E类地址240.0.0.0~255.255.255.255私网IP范围是：10.0.0.0～10.255.255.255172.16.0.0～172.31.255.255192.168.0.0～192.168.255.255子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）import re def isLegalIP(IP): if not IP or IP == \"\": return False pattern = re.compile(r\"^\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;$\") match = pattern.match(IP) if not match: return False nums = IP.split(\".\") for num in nums: n = int(num) if n&lt;0 or n&gt;255: return False return True def CatagoryIP(IP): if not IP or IP == \"\": return False nums = IP.split(\".\") # A if 126 &gt;= int(nums[0]) &gt;= 1: return \"A\" # B if 191 &gt;= int(nums[0]) &gt;= 128: return \"B\" # C if 223 &gt;= int(nums[0]) &gt;= 192: return \"C\" # D if 239 &gt;= int(nums[0]) &gt;= 224: return \"D\" # E if 255 &gt;= int(nums[0]) &gt;= 240: return \"E\" return False def isPrivateIP(IP): if not IP or IP == \"\": return False nums = IP.split(\".\") if int(nums[0]) == 10: return True if int(nums[0]) == 172: if 31 &gt;= int(nums[1]) &gt;= 16: return True if int(nums[0]) == 192 and int(nums[1]) == 168: return True return False def isLegalMaskCode(Mask): if not Mask or Mask == \"\": return False if not isLegalIP(Mask): return False binaryMask = \"\".join(map(lambda x: bin(int(x))[2:].zfill(8), Mask.split(\".\"))) indexOfFirstZero = binaryMask.find(\"0\") indexOfLastOne = binaryMask.rfind(\"1\") if indexOfLastOne &gt; indexOfFirstZero: return False return True try: A, B, C, D, E, Err, P = [0, 0, 0, 0, 0, 0, 0] while True: s = raw_input() IP, Mask = s.split(\"~\") if not isLegalIP(IP) or not isLegalMaskCode(Mask): Err += 1 else: if isPrivateIP(IP): P += 1 cat = CatagoryIP(IP) if cat == \"A\": A += 1 if cat == \"B\": B += 1 if cat == \"C\": C += 1 if cat == \"D\": D += 1 if cat == \"E\": E += 1 except: print A, B, C, D, E, Err, P pass开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。处理： 1、 记录最多8条错误记录，循环记录，对相同的错误记录（净文件名称和行号完全匹配）只记录一条，错误计数增加；2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；3、 输入的文件可能带路径，记录文件名称不能带路径。#使用Python字典判断是否为重复出现的错误信息，输出的重点问题在于输出最后八条记录时，输出的应该为8条不重复的记录，filelist应该在每条错误信息第一次出现时记录，重复出现不记录error = dict()filelist = []while True: try: record = ' '.join(''.join(input().split('\\\\')[-1]).split()) filename = record.split() if len(filename[0]) &gt;= 16: filename[0] = filename[0][-16:] record = ' '.join(filename) if record not in error.keys(): error[record] = 1 filelist.append(record) else: error[record] += 1 except: breakkey = filelist[-8:]for each in key: print(' '.join(each.split()),error[each])密码要求:1.长度超过8位2.包括大小写字母.数字.其它符号,以上四种至少三种3.不能有相同长度超2的子串重复import sysimport re for line in sys.stdin: line = line.strip() #1 if len(line) &lt;= 8: print(\"NG\") continue #2 count = 0 if re.search('[0-9]',line): count += 1 if re.search('[a-z]',line): count += 1 if re.search('[A-Z]',line): count += 1 if re.search('[^a-zA-Z0-9]',line): count += 1 if count &lt; 3: print(\"NG\") continue #3: if re.search(r'.*(...)(.*\\1)', line): print(\"NG\") continue print(\"OK\")密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦d=&#123; \"abc\":2, \"def\":3, \"ghi\":4, \"jkl\":5, \"mno\":6, \"pqrs\":7, \"tuv\":8, \"wxyz\":9, &#125;while True: try: a,res=input(),\"\" for i in a: if i.isupper(): if i!=\"Z\": res+=chr(ord(i.lower())+1) else: res+=\"a\" elif i.islower(): for j in d.keys(): if i in j: res+=str(d[j]) break else: res+=i print(res) except: break 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？while True: try: a=int(input()) if a!=0: print(a//2) except: break实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。from collections import defaultdictwhile True: try: a = input() dd = defaultdict(int) for i in a: dd[i] += 1 for i in dd: if dd[i] == min(dd.values()): a = a.replace(i, \"\") print(a) except: break计算最少出列多少位同学，使得剩下的同学排成合唱队形说明：N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足存在i（1&lt;=i&lt;=K）使得T1&lt;T2&lt;......&lt;Ti-1&lt;Ti&gt;Ti+1&gt;......&gt;TK。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。def get_index(nums,target): low,high=0,len(nums)-1 pos=len(nums) while low&lt;high: mid=(low+high)//2 if nums[mid]&lt;target: low=mid+1 else: high=mid pos=mid return posdef increase_lis(l,res): n=len(l) temp=[10**10]*n temp[0]=l[0] res+=[1] for i in range(1,n): pos=get_index(temp,l[i]) res+=[pos+1] temp[pos]=l[i] return reswhile True: try: n=int(input()) a=list(map(int,input().strip().split())) dp_1,dp_2=[],[] dp_1=increase_lis(a,dp_1) new_list=a[::-1] dp_2=increase_lis(new_list,dp_2) maxValue=max([dp_1[i]+dp_2[n-i-1] for i in range(n)]) print(n-maxValue+1) except: break信息社会，有海量的数据需要分析处理，比如公安局分析身份证号码、 QQ 用户、手机号码、银行帐号等信息及活动记录。 采集输入大数据和分类规则，通过大数据分类处理程序，将大数据分类输出。while True: try: a=input().split()[1:] b=map(str,sorted(map(int,set(input().split()[1:])))) totalNum=0 res=\"\" for num in b: singleRes,count=\"\",0 for i,v in enumerate(a): if num in v: singleRes+=str(i)+\" \"+v+\" \" totalNum+=2 count+=1 if count: singleRes=num+\" \"+str(count)+\" \"+singleRes totalNum+=2 res+=singleRes print((str(totalNum)+\" \"+res).rstrip()) except: break 编写一个程序，将输入字符串中的字符按如下规则排序。规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。如，输入： Type 输出： epTy规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。如，输入： BabA 输出： aABb规则 3 ：非英文字母的其它字符保持原来的位置。如，输入： By?e 输出： Be?ywhile True: try: a = input() # res是最终返回的字符串的列表形式，char是提取的英文字母。 res, char = [False] * len(a), [] # 经过这个循环，把相应的非英文字母及其位置存储到了res中。并且把英文字母提取出来了。 for i, v in enumerate(a): if v.isalpha(): char.append(v) else: res[i] = v # 使用lambda表达式排序，暴力有效。 char.sort(key=lambda c: c.lower()) # 将char中对应的字符填到res中。 for i, v in enumerate(res): if not v: res[i] = char[0] char.pop(0) print(\"\".join(res)) except: break 先输入字典中单词的个数，再输入n个单词作为字典单词。输入一个单词，查找其在字典中兄弟单词的个数再输入数字nfrom collections import defaultdict while True: try: dd = defaultdict(list) a = input().split() # words是输入的单词，lookup是要查找的单词，num是要查找兄弟单词的索引，brothers是找到的兄弟单词列表 words, lookup, num, brothers = a[1:1 + int(a[0])], a[-2], int(a[-1]), [] for i in words: dd[\"\".join(sorted(i))].append(i) for i in dd[\"\".join(sorted(lookup))]: if i != lookup: brothers.append(i) # 下面这两行坑的老子调了半个小时。 print(len(brothers)) if brothers and num &lt;= len(brothers): print(sorted(brothers)[num - 1]) except: break题目描述若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。输入:有一个正偶数N（N≤100），表示待挑选的自然数的个数。后面给出具体的数字，范围为[2,30000]。输出:输出一个整数K，表示你求得的“最佳方案”组成“素数伴侣”的对数。链接：https://www.nowcoder.com/questionTerminal/b9eae162e02f4f928eac37d7699b352e?f=discussion来源：牛客网def issu(x): tem = 2 while tem**2&lt;=x: if x%tem==0: return False tem+=1 return Truedef find(a,l1,l2,l3): for i in range(0,len(l3)): if issu(a+l3[i]) and l1[i]==0: l1[i]=1 if l2[i]==0 or find(l2[i],l1,l2,l3): l2[i] = a return True return False try: while True: n = input() n = int(n) l = list(map(int,input().split())) ji,ou = [],[] for i in range(n): if l[i]%2==0: ou.append(l[i]) else: ji.append(l[i]) result = 0 match = [0]*len(ou) for i in range(0,len(ji)): used = [0]*len(ou) if find(ji[i],used,match,ou): result+=1 print(result)except: pass题目描述1、对输入的字符串进行加解密，并输出。2加密方法为：当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；其他字符不做变化。3、解密方法为加密的逆过程。接口描述： 实现接口，每个接口实现1个基本操作：void Encrypt (char aucPassword[], char aucResult[])：在该函数中实现字符串加密并输出说明：1、字符串以\\0结尾。2、字符串最长100个字符。int unEncrypt (char result[], char password[])：在该函数中实现字符串解密并输出说明：1、字符串以\\0结尾。 2、字符串最长100个字符。while True: try: a, b = input(), input() resA, resB = \"\", \"\" for i in a: if i.isupper(): if i != \"Z\": resA += chr(ord(i) + 1).lower() else: resA += \"a\" elif i.islower(): if i != \"z\": resA += chr(ord(i) + 1).upper() else: resA += \"A\" elif i.isdigit(): if i != \"9\": resA += chr(ord(i) + 1) else: resA += \"0\" for i in b: if i.isupper(): if i != \"A\": resB += chr(ord(i) - 1).lower() else: resB += \"z\" elif i.islower(): if i != \"a\": resB += chr(ord(i) - 1).upper() else: resB += \"Z\" elif i.isdigit(): if i != \"0\": resB += chr(ord(i) - 1) else: resB += \"9\" print(resA) print(resB) except: break按照指定规则对输入的字符串进行处理。详细描述：将输入的两个字符串合并。对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标意思是字符在字符串中的位置。对排序后的字符串进行操作，如果字符为‘0’——‘9’或者‘A’——‘F’或者‘a’——‘f’，则对他们所代表的16进制的数进行BIT倒序的操作，并转换为相应的大写字符。如字符为‘4’，为0100b，则翻转后为0010b，也就是2。转换后的字符为‘2’； 如字符为‘7’，为0111b，则翻转后为1110b，也就是e。转换后的字符为大写‘E’。while True: try: dic = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"] s = input().replace(\" \", \"\") #s是输入的合并后的字符串 ss = \"\" #ss为最终返回的字符串 odd, even = \"\", \"\" # 字符串的奇数子串和偶数子串 # 经过下面的循环，提取奇数与偶数的子串。 for i, v in enumerate(s): if i % 2 == 0: even += v else: odd += v # 奇数与偶数部分排序 odd = \"\".join(sorted(odd)) even = \"\".join(sorted(even)) # 如果字符串在0123456789abcdefABCDEF范围内，对其做变换，否则不做任何处理。 for i in range(len(even)): if even[i] in \"0123456789abcdefABCDEF\": ss += dic[int(bin(dic.index(even[i].upper())).replace(\"0b\", \"\").rjust(4, \"0\")[::-1], 2)] else: ss += even[i] if len(odd) != i: #注意偶数串可能比奇数串长一个字符，所以要做一下判断。 if odd[i] in \"0123456789abcdefABCDEF\": ss += dic[int(bin(dic.index(odd[i].upper())).replace(\"0b\", \"\").rjust(4, \"0\")[::-1], 2)] else: ss += odd[i] print(ss) except: break 12","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"Write code every day 02","slug":"study python 2day","date":"2019-12-20T12:00:00.000Z","updated":"2020-01-15T06:34:08.128Z","comments":true,"path":"2019/12/20/study python 2day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/20/study%20python%202day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#1.将元祖（123）和集合&#123;5,4,6&#125;合并成一个列表list((1,2,3))+list(&#123;4,5,6&#125;)#2.在列表[1,2,3,4,5]首尾分别添加整型元素7和0a=[1,2,3,4,5]a.insert(0,7)a.append(0)#3.反转列表 [0,1,2,3,4,5,6,7] a=[0,1,2,3,4,5,6,7]b=a.reverse()b=a[::-1]#4.反转列表 [0,1,2,3,4,5,6,7] 后给出中元素 5 的索引号[0,1,2,3,4,5,6,7].[::-1].index(5)#5.分别统计列表 [True,False,0,1,2] 中 True,False,0,1,2的元素个数，发现python无法区分True和1a=[True,False,0,1,2]a.count(True),a.count(False),a.count(0),a.count(1),a.count(2)#6.从列表 [True,1,0,‘x’,None,‘x’,False,2,True] 中删除元素‘x’,remove参数为值a=[True,1,0,‘x’,None,‘x’,False,2,True]for i in range(a.count()): a.remove('x')print(a)#7. 从列表 [True,1,0,‘x’,None,‘x’,False,2,True] 中删除索引号为4的元素，pop参数为索引a=[True,1,0,‘x’,None,‘x’,False,2,True]a.pop(4)print(a)#删除列表中索引号为奇数（或偶数）的元素,使用dela=list(range(10))del a[::2]a=list(range(10))del a[1::2]print(a)print(b)print(c)#清空列表中的所有元素。a=list(range(10))a.clear()#10. 对列表 [3,0,8,5,7] 分别做升序和降序排列。a=[3,0,8,5,7]a.sort()a.sort(reverse=true) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#11.将列表 [3,0,8,5,7] 中大于 5 元素置为1，其余元素置为0[1 if item&gt;5 else 0 for item in [3,0,8,5,7]]#12.遍历列表 [‘x’,‘y’,‘z’]，打印每一个元素及其对应的索引号for index,value in enumerate(['x','y','z']): print('index=&#123;&#125;,value=&#123;&#125;'.format(index,value))for index,value in enumerate(['x','y','z']): print('index=%d,value=%s'%(index,value))#13.将列表 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 拆分为奇数组和偶数组两个列表a=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]b=a[1::2]c=a[::2]#14. 分别根据每一行的首元素和尾元素大小对二维列表 [[6, 5], [3, 7], [2, 8]] 排序a=[[6, 5], [3, 7], [2, 8]]b=sorted(a,key=lambda x:x[0])# 根据每一行的首元素排序，默认reverse=Falsec=sorted(a,key=lambda x:x[-1])# 根据每一行的尾元素排序，设置reverse=True实现逆序#15. 从列表 [1,4,7,2,5,8] 索引为3的位置开始，依次插入列表 [‘x’,‘y’,‘z’] 的所有元素a=[1,4,7,2,5,8]a[3:3]=['x','y','z']# 如果写成a[3:4]，索引为3的元素2被替换成'x','y','z'print(a)#16. 快速生成由 [5,50) 区间内的整数组成的列表。a=[range(5,50)]#17. 若 a = [1,2,3]，令 b = a，执行 b[0] = 9， a[0]亦被改变。为何？如何避免？a=[1,2,3]b=a# 对象a和对象b在内存中是同一个，所以会出现关联id(a)==id(b)b=a.copy()# 正确的做法是复制一个新的对象id(b)==id(a)#18.将列表 [‘x’,‘y’,‘z’] 和 [1,2,3] 转成 [(‘x’,1),(‘y’,2),(‘z’,3)] 的形式[(a,b) for a,b in zip(['x','y','z'],[1,2,3])]#19.以列表形式返回字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中所有的键a=&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;for i in a.keys(): print(i)#20. 以列表形式返回字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中所有的值a=&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;[key for key in a.values()] 123456789101112131415161718192021222324252627282930313233343536373839#21. 以列表形式返回字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中所有键值对组成的元组a&#x3D;&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;[key for key in a.items()]# d.items()返回的类型是&lt;class &#39;dict_items&#39;&gt;，不能使用索引#22. 向字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中追加 ‘David’: 19 键值对，更新 Cecil 的值为17。a&#x3D;&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;a.update(&#123;‘David’: 19&#125;)a.update(&#123;&#39;cecil&#39;:17&#125;)#23 删除字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中的Beth键后，清空该字典a&#x3D;&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;a.pop(&#39;Beth&#39;)a.clear()#24. 判断 David 和 Alice 是否在字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125; 中d&#x3D;&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;&#39;David&#39;in d&#39;Alice&#39;in d#25. 遍历字典 &#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;，打印键值对a&#x3D;&#123;‘Alice’: 20, ‘Beth’: 18, ‘Cecil’: 21&#125;for key in d: print(key,d[key])#26. 若 a &#x3D; dict()，令 b &#x3D; a，执行 b.update(&#123;‘x’:1&#125;)， a亦被改变。为何？如何避免？a&#x3D;dict()b&#x3D;aid(b)&#x3D;&#x3D;id(a)b.copy(a)id(b)&#x3D;&#x3D;id(a)#27. 以列表 [‘A’,‘B’,‘C’,‘D’,‘E’,‘F’,‘G’,‘H’] 中的每一个元素为键，默认值都是0，创建一个字典。a&#x3D;dict.fromkeys([‘A’,‘B’,‘C’,‘D’,‘E’,‘F’,‘G’,‘H’],0)#28. 将二维结构 [[‘a’,1],[‘b’,2]] 和 ((‘x’,3),(‘y’,4)) 转成字典dict([[‘a’,1],[‘b’,2]])dict(((‘x’,3),(‘y’,4)))#29. 将元组 (1,2) 和 (3,4) 合并成一个元组(1,2)+(3,4)#30. 将空间坐标元组 (1,2,3) 的三个元素解包对应到变量 x,y,zx,y,z&#x3D;(1,2,3) 123456789101112131415161718192021222324252627282930313233343536373839404142#31. 返回元组 (‘Alice’,‘Beth’,‘Cecil’) 中 ‘Cecil’ 元素的索引号(‘Alice’,‘Beth’,‘Cecil’).index('Cecil')#32. 返回元组 (2,5,3,2,4) 中元素 2 的个数a=(2,5,3,2,4)a.count(2)#33. 判断 ‘Cecil’ 是否在元组 (‘Alice’,‘Beth’,‘Cecil’) 中'Cecil' in (‘Alice’,‘Beth’,‘Cecil’)#34. 返回在元组 (2,5,3,7) 索引号为2的位置插入元素 9 之后的新元组(*(2,5,3,7)[::2],9,*(2,5,3,7)[2:])#35. 创建一个空集合，增加 &#123;‘x’,‘y’,‘z’&#125; 三个元素。a=set()a.update(&#123;'x','y','z'&#125;)#36. 删除集合 &#123;‘x’,‘y’,‘z’&#125; 中的 ‘z’ 元素，增加元素 ‘w’，然后清空整个集合。a=&#123;'x','y','z'&#125;a.remove('z')a.update('w')#a.add('w')a.clear()#37. 返回集合 &#123;‘A’,‘D’,‘B’&#125; 中未出现在集合 &#123;‘D’,‘E’,‘C’&#125; 中的元素（差集）a=&#123;'A','D','B'&#125;b=&#123;'D','E','C'&#125;a.difference(b)#a-b#38返回两个集合 &#123;‘A’,‘D’,‘B’&#125; 和 &#123;‘D’,‘E’,‘C’&#125; a=&#123;'A','D','B'&#125;b=&#123;'D','E','C'&#125;a.union(b)#39. 返回两个集合 &#123;‘A’,‘D’,‘B’&#125; 和 &#123;‘D’,‘E’,‘C’&#125; 的交集a=&#123;'A','D','B'&#125;b=&#123;'D','E','C'&#125;a.intersection(b)#40.返回两个集合 &#123;‘A’,‘D’,‘B’&#125; 和 &#123;‘D’,‘E’,‘C’&#125; 未重复的元素的集合a=&#123;'A','D','B'&#125;b=&#123;'D','E','C'&#125;a.symmetric_difference(b) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289#41. 判断两个集合 &#123;‘A’,‘D’,‘B’&#125; 和 &#123;‘D’,‘E’,‘C’&#125; 是否有重复元素。a=&#123;‘A’,‘D’,‘B’&#125;b=&#123;‘D’,‘E’,‘C’&#125;a.isdisjoint(b)#判断集合 &#123;‘A’,‘C’&#125; 是否是集合 &#123;‘D’,‘C’,‘E’,‘A’&#125; 的子集a=&#123;‘A’,‘C’&#125; b=&#123;‘D’,‘C’,‘E’,‘A’&#125;a.issubset(b)#43. 去除数组 [1,2,5,2,3,4,5,‘x’,4,‘x’] 中的重复元素。list[set([1,2,5,2,3,4,5,‘x’,4,‘x’])]#44. 返回字符串 ‘abCdEfg’ 的全部大写、全部小写和大小互换形式。s='abCdEfg's.upper()s.lower()s.swapcase()#45. 判断字符串 ‘abCdEfg’ 是否首字母大写，字母是否全部小写，字母是否全部大写。s=s='abCdEfg's.istitle()s.isupper()s.islower()#46. 返回字符串 ‘this is python’ 首字母大写以及字符串内每个单词首字母大写形式。s='this is python's.capitalize()s.title()#47. 判断字符串 ‘this is python’ 是否以 ‘this’ 开头，又是否以 ‘python’ 结尾s='this is python's.startswith()s.endswith()#48. 返回字符串 ‘this is python’ 中 ‘is’ 的出现次数s='this is python's.count('is')#49. 返回字符串 ‘this is python’ 中 ‘is’ 首次出现和最后一次出现的位置。s='this is python's.find('is')#返回首次出现的索引，未找到则返回-1s.rfind('is')#返回最后一次出现的索引，未找到则返回-1#50. 将字符串 ‘this is python’ 切片成3个单词s='this is python's.split()study Python 2day yes 21/100#51. 返回字符串 ‘blog.csdn.net/xufive/article/details/102946961’ 按路径分隔符切片的结果s='blog.csdn.net/xufive/article/details/102946961's.split('/')#52.将字符串 ‘2.72, 5, 7, 3.14’ 以半角逗号切片后，再将各个元素转成浮点型或整形。s='2.72,5,7,3.14'[float(item) if '.' in item else int(item) for item in s.split(',')]#53. 判断字符串 ‘adS12K56’ 是否完全为字母数字，是否全为数字，是否全为字母，是否全为ASCII码。s='adS12K56's.isalnum()s.digit()s.isascii()#54. 将字符串 ‘there is python’ 中的 ‘is’ 替换为 ‘are’。s='there is python's.replace('is','are')#55. 清除字符串 ‘\\t python \\n’ 左侧、右侧，以及左右两侧的空白字符。s='\\t python \\n'#strip()函数移除头尾指定字符，默认移除空格s.lstrip()s.rstrip()s.strip()#56. 将三个全英文字符串（比如，‘ok’, ‘hello’, ‘thank you’）分行打印，实现左对齐、右对齐和居中对齐效果。s=('ok','hello','thank you')len_max=([len(item) for item in a])for item in a: print('\"%s\"'%item.ljust(len_max))s=('ok','hello','thank you')len_max=([len(item) for item in a])for item in a: print('\"%s\"'%item.rjust(len_max))s=('ok','hello','thank you')len_max=([len(item) for item in a])for item in a: print('\"%s\"'%item.center(len_max))#57. 将三个字符串（比如，‘Hello, 我是David’, ‘OK, 好’, ‘很高兴认识你’）分行打印，实现左对齐、右对齐和居中效果。s='hello,我是David'，'ok,好'，'很高兴认识你'len_s=[len(item) for item in s]len_s_gbk=[len(item.encode('gbk'))for item in s]c_num=[a-b for a,b in zip(lem_s_gbk,len_s)]len_max=max(len_s_gbk)for s,c in zip(s,c_num) print('\"%s\"'%s.ljust(len_max-c))s='hello,我是David'，'ok,好'，'很高兴认识你'len_s=[len(item) for item in s]len_s_gbk=[len(item.encode('gbk') for item in s)]c_num=[a-b for a,b in zip([len_s_gbk,len_s])]len_max=max(len_s_gbk)for s,c in zip(s,c_num): pring('\"%s\"'%s.rjust(len_max-c))s='hello,我是David'，'ok,好'，'很高兴认识你'len_s=[len(item) for item in s]len_s_gbk=[len(item.encode('gbk') for item in s)]c_num=[a-b for a,b in zip([len_s_gbk,len_s])]len_max=max(len_s_gbk)for s,c in zip(s,c_num): pring('\"%s\"'%s.center(len_max-c))#58. 将三个字符串 ‘15’, ‘127’, ‘65535’ 左侧补0成同样长度。a=['15','127',''65535]len_max=max([len(item) for item in a])for i in a: print(i.zfill(len_max))#59. 提取 url 字符串 ‘https://blog.csdn.net/xufive’ 中的协议名。s='https://blog.csdn.net/xufive's1=s.split('/')[0][::-1]#60. 将列表 [‘a’,‘b’,‘c’] 中各个元素用’|'连接成一个字符串。s1='|'.join(abc) #61. 将字符串 ‘abc’ 相邻的两个字母之间加上’-’，生成新的字符串。'-'.join(abc)#62. 从键盘输入手机号码，输出形如 ‘Mobile: 186 6677 7788’ 的字符串。def print_mobile(): num=input('输入你的手机号码：') print('mobile: %s %s %s'%(num[:3],num[3:7],num[7:]))#63. 从键盘输入年月日时分秒，输出形如 ‘2019-05-01 12:00:00’ 的字符串。def print_datetime(): dt=input('请输入年月日时分秒，中间以空格分隔：') Y,M,D,h,m,s=int(Y),int(M),int(D),int(h),int(m),int(s) print('%04d-%02d-%02d %02d:%02d:%02d'%(Y,M,D,h,m,s)#64. 给定两个浮点数 3.1415926 和 2.7182818，格式化输出字符串 ‘pi = 3.1416, e = 2.7183’'pi=%0.4f,e=%0.4f'%(3.1415926,2.7182818)#65. 将 0.00774592 和 356800000 格式化输出为科学计数法字符串。'%e,%E'%(0.00774592,356800000)#66. 将十进制整数 240 格式化为八进制和十六进制的字符串。'%O'%240'%x'%240#67. 将十进制整数 240 转为二进制、八进制、十六进制的字符串。bin(240)oct(240)hex(240)#68. 将字符串 ‘10100’ 按照二进制、八进制、十进制、十六进制转为整数。int('10100',base=2)int('10100',base=8)int('10100',base=16)#69. 求二进制整数1010、八进制整数65、十进制整数52、十六进制整数b4的和。0b1010+0o65+52+0xb4#70. 将列表 [0,1,2,3.14,‘x’,None,’’,list(),&#123;5&#125;] 中各个元素转为布尔型。[bool(item) for item in [0,1,2,3.14,‘x’,None,’’,list(),&#123;5&#125;]] #71. 返回字符 ‘a’ 和 ‘A’ 的ASCII编码值。ord('a')ord('A')#72. 返回ASCII编码值为 57 和 122 的字符。chr(57)chr(122)#73. 将二维列表 [[0.468,0.975,0.446],[0.718,0.826,0.359]] 写成名为 csv_data 的 csv 格式的文件，并尝试用 excel 打开它。with open(r'd:\\csv_data.csv','w') as fp: for row in [[0.468,0.975,0.446],[0.718,0.826,0.359]]: line_len=fp.write('%s\\n'%(','join([str(col) for col in row])))#74. 从 csv_data.csv 文件中读出二维列表。date=list()with open(r'd:\\csv_data.csv','r') as fp: for line in fp.readline(): date.append([float(item) for item in line.strip(',')])#75. 向 csv_data.csv 文件追加二维列表 [[1.468,1.975,1.446],[1.718,1.826,1.359]]，然后读出所有数据。with open(r'd:\\csv_data.csv','w') as fp: for row in [[0.468,0.975,0.446],[0.718,0.826,0.359]]: fp.write('%s\\n'%(','.join(str(col) for col in row)))date=list()with open(r'd:\\csv_data.csv','r') as fp: for line in fp.readline(): date.append([float(item) for item in line.split(',')])#76. 交换变量 x 和 y 的值。x,y=1,2x,y=y,x#77. 判断给定的参数 x 是否是整形。x=3.14isinstance(x,int)#78. 判断给定的参数 x 是否为列表或元组。x=list()y=tuple()isinstance(x,(list,tuple))isinstance(y,(list,tuple))#79. 判断 ‘https://blog.csdn.net’ 是否以 ‘http://’ 或 ‘https://’ 开头。若是，则返回 ‘http’ 或 ‘https’；否则，返回None。def get_url_start(url): if url.startswitch(('http://','https://')) return url.split(':')[0] else: None#80. 判断 ‘https://blog.csdn.net’ 是否以 ‘.com’ 或 ‘.net’ 结束。若是，则返回 ‘com’ 或 ‘net’；否则，返回Nonedef get_url_start(url): if url.endswitch(('.com','.net')) return url.split('.')[-1] else: None #81. 将列表 [3,‘a’,5.2,4,&#123;&#125;,9,[]] 中 大于3的整数或浮点数置为1，其余置为0。[1 if item&gt;3 and isinstance(item,(int,float)) else 0 for item in [3,‘a’,5.2,4,&#123;&#125;,9,[]]]#82. a,b 是两个数字，返回其中较小者或最大者。a=ab=2max(a,b)min(a,b)#83. 找到列表 [8,5,2,4,3,6,5,5,1,4,5] 中出现最频繁的数字以及出现的次数。s=[8,5,2,4,3,6,5,5,1,4,5]v_max=max(set(a),key=a.count)a.count(v_max)#84. 将二维列表 [[1], [‘a’,‘b’], [2.3, 4.5, 6.7]] 转为 一维列表。sum([[1], [‘a’,‘b’], [2.3, 4.5, 6.7]])#85. 将等长的键列表和值列表转为字典。keys=[1,2,3]values=['a','b','c']dict(zip(keys,values))#86. 使用链状比较操作符重写逻辑表达式 a &gt; 10 and a &lt; 20。#87. 写一个函数，以0.1秒的间隔不换行打印30次由函数参数传入的字符，实现类似打字机的效果。def print_slow(ch,n=30,delay=0.1): for i in range(n): print(ch,end='',flush=True) time.sleep(delay)#89. 返回数字列表中的最大值和最小值。inport randoma=[random.random() for i in range(5)]min(a)max(a)#90. 计算 5 的 3.5 方和 3 的立方根。pow(5,3.5)pow(3,1/3) #91. 对 3.1415926 四舍五入，保留小数点后5位。round(3.1415926,5)#92. 判断两个对象是在内存中是否是同一个。a=1b=aid(a)==id(b)#93. 返回给定对象的属性和方法。a=()for item in dir(a): print(item)#94. 计算字符串表达式 ‘(2+3)*5’ 的值。eval('(2+3)*5')#95. 实现字符串 ‘x=&#123;“name”:“David”, “age”:18&#125;’ 包含的代码功能。exec('x=&#123;\"name\":\"David\", \"age\":18&#125;')#96. 使用 map 函数求列表 [2,3,4,5] 中每个元素的立方根。[item for item in map(lanbda x:pow(x,1/3),[2,3,4,5])] #[pow(item,3) for item in [2,3,4,5]]#97. 使用 sys.stdin.readline() 写一个和 input() 函数功能完全相同的函数。import sysdef my_input(prompt): print(prompt,end='') return sys.stdin.readline().strip()","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]},{"title":"Write code every day 01","slug":"study python 1day","date":"2019-12-19T12:00:00.000Z","updated":"2020-01-13T12:56:52.518Z","comments":true,"path":"2019/12/19/study python 1day/","link":"","permalink":"https://yanxigun99.github.io/2019/12/19/study%20python%201day/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#!/usr/bin/pythonprint(\"Hello, World!\");a=[1,2,3]b=a.copy()b[0]=9print(id(a)==id(b))print(a)print(b)print([(a,b) for a,b in zip(['x','y','z'],[1,2,3])])print(a)print(b)a=&#123;'ming':20,'zi':30,'tian':60&#125;print([key for key in a.keys()])print([value for value in a.values()])print([key for key in a.items()])a.update(&#123;'ming':19&#125;)print(a)a.pop('zi')print(a)a.clear()print(a)a=&#123;'ming':20,'zi':30,'tian':60&#125;print('ming'in a)for key in a: print(key,a[key],sep='-&gt;') b=ab.update(&#123;'ming':10&#125;)print(a)print(b)a=&#123;'ming':20,'zi':30,'tian':60&#125;b=a.copy()b.update(&#123;'ming':10&#125;)print(a)print(b)c=dict.fromkeys(['q','w','e','r','t','y','u','i','o','p'],0)print(c)print(dict([[1,2],[3,4]]))print((1,2)+(3,4))x,y,z=(1,2,3)print(x,y,z,sep='*')print(('x','y','z').index('y'))print((1,2,2,2,3,4,5,1,2,3).count(2))print('q' in ('q','w','e','r','t'))print(*(2,3,4,5)[:2],9,*(2,3,4,5)[2:])a=set()a.update(&#123;1,2,3&#125;)print(a)a=&#123;1,2,3,4&#125;print(a)a.remove(1)print(a)a.add(6)print(a)a.clear()print(a)a=&#123;1,2,3,4,5,6&#125;b=&#123;3,4,5,6,7,8,9&#125;print(a.difference(b))print(a-b)print(a.union(b))print(a.intersection(b))print(a.symmetric_difference(b))print(a.symmetric_difference(b))print(a.isdisjoint(b))print(not a.isdisjoint(b))a=&#123;1,2,3,4&#125;b=&#123;1,2,3,4,5,6,7&#125;print(a.issubset(b))print(list(set([1,2,3,2,3,4,5,2,1,2,3,4])))s='fhafhdHUWhoU'print(s)print(s.upper())print(s.lower())print(s.swapcase())print(s.istitle())print(s.isupper())print(s.islower())s='this is python'print(s.capitalize())print(s.title())s='this is python'print(s.startswith('this'))print(s.endswith('python'))print(s.startswith('is'))s='this is python'print(s.count('is'))print(s.find('is'))print(s.rfind('is'))print(s.split())s='blog.csdn.net/xufive/article/details/102946961'print(s.split('/'))s='2.14,4,5,6.28'print([float(item) if '.' in item else int(item) for item in s.split(',')])print([float(item) if '.' in item else int(item) for item in s.split(',')])s='shfa12hdsdjhf43'print(s.isalnum())print(s.isdigit())s='this is python'print(s.replace('is','are'))s='we python \\t'print(s)print(s.lstrip())print(s.strip())print(s.rstrip())a=['this','ok','yes this ok']max_len=max([len(item) for item in a])print(max_len)for item in a: print('\"%s\"'%item.ljust(max_len))for item in a: print('\"%s\"'%item.rjust(max_len))for item in a: print('\"%s\"'%item.center(max_len))a=['Hello, 我是David', 'OK, 好', '很高兴认识你']a_len=[len(item)for item in a]print(a_len)a_len_gbk=[len(item.encode('gbk')) for item in a]a_len_gbk=[len(item.encode('gbk')) for item in a]c_len=[b-a for a,b in zip(a_len,a_len_gbk)]print(a_len_gbk)print(c_len)len_max=max(a_len_gbk)print(len_max)for s,c in zip(a,c_len): print('\"%s\"'%s.ljust(len_max))for s,c in zip(a,c_len): print('\"%s\"'%s.ljust(len_max-c))for s,c in zip(a,c_len): print('\"%s\"'%s.rjust(len_max-c))for s,c in zip(a,c_len): print('\"%s\"'%s.center(len_max-c)) a=['123','23123','1']len_max=max([len(item) for item in a])print(len_max)for i in a: print(i.zfill(len_max))for item in a: print(item.zfill(len_max))print('https://blog.csdn.net/xufive'.split('/',2)[0][:-1])print('https://blog.cscn.net/dsafa'.split('//')[0][:-1] 12345678910111213141516171819a=['a','b','c']print('|'.join(a))print('-'.join(a))'''def print_mobile(): num = input('请输入手机号码：') print('Mobile: %s %s %s'%(num[:3], num[3:7], num[7:]))print_mobile()def print_mobile(): num=input('请输入你的号码') print('mobile:%s %s %s'%(num[:3],num[3,7],num[7:]))'''def print_datetime(): num=input('place input the date:') Y,M,D,h,m,s=num.split() Y,M,D,h,m,s=int(Y),int(M),int(D),int(h),int(m),int(s) print('%04d-%02d')","categories":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}],"tags":[{"name":"code","slug":"code","permalink":"https://yanxigun99.github.io/tags/code/"}],"keywords":[{"name":"300 lines of code","slug":"300-lines-of-code","permalink":"https://yanxigun99.github.io/categories/300-lines-of-code/"}]}]}